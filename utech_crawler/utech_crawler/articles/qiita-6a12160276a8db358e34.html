<!DOCTYPE html><html xmlns:og="http://ogp.me/ns#"><head><meta charset="UTF-8" /><title>C++11 パーサコンビネータ 超入門 - Qiita</title><meta content="width=device-width,initial-scale=1" name="viewport" /><meta content="構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。

C++ではBoost.Spiritが有名ですが、この記事ではHaskellのParsecを参考にしています。もちろんHaskellやモナドの知識は前提としません。それと断らずにモナドに由来する何かは出て来ますが、それが見抜けなくても問題ありません。興味があれば以下の記事を参照して..." name="description" /><meta content="summary" name="twitter:card" /><meta content="@Qiita" name="twitter:site" /><meta content="7shi" name="twitter:creator" /><meta content="C++11 パーサコンビネータ 超入門 - Qiita" property="og:title" /><meta content="article" property="og:type" /><meta content="http://qiita.com/7shi/items/6a12160276a8db358e34" property="og:url" /><meta content="http://cdn.qiita.com/assets/qiita-fb-2887e7b4aad86fd8c25cea84846f2236.png" property="og:image" /><meta content="構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。

C++では[Boost.Spirit](..." property="og:description" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><link rel="shortcut icon" type="image/x-icon" href="http://cdn.qiita.com/assets/favicons/public/production-4ff10c1e1e2b5fcb353ff9cafdd56c70.ico" /><link rel="apple-touch-icon" type="image/png" href="http://cdn.qiita.com/assets/favicons/public/apple-touch-icon-f9a6afad761ec2306e10db2736187c8b.png" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link rel="stylesheet" media="all" href="http://cdn.qiita.com/assets/public-e8d29e8ff1879118096f0f5877946857.min.css" /><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="UacNrOjy885rc1mXycxclOIdy0sbdV26kEmaGl1q468/JZb0c9zKhZSg7Iu5OeLNglrv+IyxB02sl5PhvGTtaQ==" /></head><body class="without-js" id=""><noscript><iframe height="0" src="//www.googletagmanager.com/ns.html?id=GTM-TBQWPN" style="display:none;visibility:hidden" width="0"></iframe></noscript><script>
  document.body.className = document.body.className.replace('without-js', '') + ' with-js';
  window.Qiita = {"asset_host":"cdn.qiita.com","TLD":"com","controller_path":"public/items","controller_action":"public/items#show","controller":"items","action":"show","env":"production","flash":{},"is_landing_page":false,"is_team_page":false,"root_domain":"qiita.com","variant":null,"config":{"mixpanel":{"career":"dd35af27e959781713d63fd7ca898a8d","per_team":"c0a2116368b33b44b5029ebd2cc9b094","public":"be87616606b0e26a87689099aab2c4e5","team":"b7c0342acba2dbc8742484d98788efb3"},"default_locale":"ja","locale":"en"},"team":null,"user":null,"GIT_BRANCH":null,"DEBUG":false};

</script>
<div class="headerContainer headerContainer-public" role="navigation"><div data-react-class="T.HeaderContainer" data-react-props="{&quot;user&quot;:null,&quot;team&quot;:null,&quot;news&quot;:{&quot;type&quot;:&quot;募集&quot;,&quot;content&quot;:&quot;QiitaやQiita:Teamを良くしたいエンジニア&quot;,&quot;url&quot;:&quot;http://increments.co.jp/jobs/engineers?utm_source=qiita\u0026utm_medium=header_news&quot;},&quot;initial_unread_count&quot;:null,&quot;siteid_image&quot;:&quot;http://cdn.qiita.com/siteid-reverse.png&quot;,&quot;is_team_page&quot;:false,&quot;on_team_setting&quot;:false,&quot;show_post_menu&quot;:true,&quot;show_search_menu&quot;:true,&quot;is_fluid&quot;:false,&quot;locale&quot;:&quot;en&quot;}"></div></div><div id="main"><ol class="itemBreadcrumbs" itemscope="" itemtype="http://schema.org/BreadcrumbList"><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/"><span itemprop="name">Qiita</span></a><meta content="1" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/items"><span itemprop="name">Items</span></a><meta content="2" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/tags/C++11"><span itemprop="name">C++11</span></a><meta content="3" itemprop="position" /></li></ol><article itemscope="" itemtype="http://schema.org/Article"><div class="ArticleMainHeader "><div class="container"></div><div class="container"><div class="row s-flex-align-center"><div class="col-sm-9"><h1 class="ArticleMainHeader__title">C++11 パーサコンビネータ 超入門</h1><ul class="TagList"><li class="TagList__item" data-count="322"><a class="u-link-unstyled TagList__label" href="/tags/C++11"><img alt="C++11" class="TagList__icon" src="//cdn.qiita.com/assets/icons/medium/missing-2e17009a0b32a6423572b0e6dc56727e.png" /><span>C++11</span></a></li></ul></div><div class="col-sm-3"><div class="itemsShowHeaderStock"><ul class="list-unstyled itemsShowHeaderStock_statusList"><li><div class="itemsShowHeaderStock_count stock"><span class="fa fa-thumbs-up"></span><span class="js-likecount">38</span></div><div class="itemsShowHeaderStock_countText">Like</div></li><li><div class="itemsShowHeaderStock_count" content="0 UserComments" itemprop="interactionCount"><span class="fa fa-comment"></span>0</div><div class="itemsShowHeaderStock_countText">Comment</div></li></ul></div><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:38,&quot;uuid&quot;:&quot;6a12160276a8db358e34&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-header&quot;}"></div><ul class="list-inline ArticleMainHeader__users"><li class="js-hovercard" data-hovercard-target-name="unsolvedprobrem"><a itemprop="url" href="/unsolvedprobrem"><img alt="unsolvedprobrem" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/34654/profile-images/1478738737" /></a></li><li class="js-hovercard" data-hovercard-target-name="qb0C80aE"><a itemprop="url" href="/qb0C80aE"><img alt="qb0C80aE" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/45715/profile-images/1482123489" /></a></li><li class="js-hovercard" data-hovercard-target-name="oroshi"><a itemprop="url" href="/oroshi"><img alt="oroshi" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/50790/profile-images/1483948028" /></a></li><li class="js-hovercard" data-hovercard-target-name="yatanokarasu"><a itemprop="url" href="/yatanokarasu"><img alt="yatanokarasu" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/85486/profile-images/1473703445" /></a></li><li class="js-hovercard" data-hovercard-target-name="npaint1a"><a itemprop="url" href="/npaint1a"><img alt="npaint1a" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/101750/profile-images/1473708487" /></a></li><li class="js-hovercard" data-hovercard-target-name="midoriya"><a itemprop="url" href="/midoriya"><img alt="midoriya" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/61692/profile-images/1473695734" /></a></li><li class="js-hovercard" data-hovercard-target-name="EqualL2"><a itemprop="url" href="/EqualL2"><img alt="EqualL2" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/71548/profile-images/1473698862" /></a></li><li class="js-hovercard" data-hovercard-target-name="iwadon"><a itemprop="url" href="/iwadon"><img alt="iwadon" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/2070/profile-images/1484641283" /></a></li><li class="js-hovercard" data-hovercard-target-name="kou_tana77"><a itemprop="url" href="/kou_tana77"><img alt="kou_tana77" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/45958/profile-images/1473690481" /></a></li><li class="js-hovercard" data-hovercard-target-name="hamu502"><a itemprop="url" href="/hamu502"><img alt="hamu502" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38910/profile-images/1473687923" /></a></li><li><a href="/7shi/items/6a12160276a8db358e34/likers"><span class="fa fa-ellipsis-h"></span></a></li></ul></div></div></div></div><div class="ArticleAsideHeader"><div class="container"><div class="u-flex u-space-between"><div class="u-flex u-flex-wrap"><div class="u-flex u-align-center s-pdv-5 u-flex-wrap"><div class="ArticleAsideHeader__author"><a href="/7shi"><img class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" alt="1473685823" /></a> <a class="u-link-unstyled" href="/7shi">7shi</a> </div><div class="ArticleAsideHeader__date"><span data-toggle="tooltip" title="posted at 2015-11-27">Edited at <time datetime="2016-12-27T02:34:35+09:00" itemprop="dateModified">2016-12-27</time></span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"><div class="ArticleAsideHeader__revision"> <a data-toggle="tooltip" title="Revisions" href="/7shi/items/6a12160276a8db358e34/revisions"><span class="fa fa-history"></span></a><span class="ArticleAsideHeader__revisionCount">28</span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"></div></div><div class="u-flex u-align-center s-flex-justiry-between s-pdv-5 u-shrink-0"><div class="ArticleAsideHeader__stock"><div class="js-stockbutton" data-position="top" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h fa-lg"></span></a><ul class="dropdown-menu dropdown-menu-right"><li class="dropdown__item--mobile"><a href="/7shi/items/6a12160276a8db358e34/revisions"><span class="fa fa-fw fa-history"></span> Revisions<span>(28)</span></a></li><li><a href="/7shi/items/6a12160276a8db358e34.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><span class="fa fa-fw fa-flag"></span> Report article</a></li></ul></div></div></div></div></div><div class="container"><div class="row" id="article-body-wrapper"><div class="col-sm-9"><section class="markdownContent markdownContent-headingEnabled js-task-list-container clearfix position-relative" id="item-6a12160276a8db358e34" itemprop="articleBody"><p>構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。</p>

<p>C++では<a href="http://boost-spirit.com/home/" rel="nofollow noopener" target="_blank">Boost.Spirit</a>が有名ですが、この記事ではHaskellのParsecを参考にしています。もちろんHaskellやモナドの知識は前提としません。それと断らずにモナドに由来する何かは出て来ますが、それが見抜けなくても問題ありません。興味があれば以下の記事を参照してください。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" id="reference-cab19670931aa7c8b0fa">Haskell 構文解析 超入門</a> 2015.07.31</li>
</ul>

<p>今回はラムダ式を多用するためC++11以降を対象とします。ラムダ式なしで実装するとあまりにも冗長になり過ぎて、便利さよりも煩雑さが勝ってしまうためです。興味があれば、以下のリポジトリを参照してください。</p>

<ul>
<li><a href="https://bitbucket.org/7shi/parsecpp" class="autolink" rel="nofollow noopener" target="_blank">https://bitbucket.org/7shi/parsecpp</a></li>
</ul>

<p>この記事には続編があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/f86f2f7ad68cfff1b399" id="reference-b20365ccfd419e30f2bb">C++11 パーサコンビネータ 超入門 2</a> 2015.11.30</li>
</ul>

<p>この記事にはJava版があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/68228e19552c271bea81" id="reference-28b785f74e6669908671">Java パーサコンビネータ 超入門</a> 2016.05.12</li>
<li>
<a href="http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142" id="reference-acf3d67357cc43d5eeb1">Java パーサコンビネータ 超入門 2</a> 2016.05.14</li>
</ul>

<p>この記事には関連記事があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/04c2991239894687ef2f" id="reference-3a0c8307a3794ac552b5">JSONパーサーを作る</a> 2016.12.26</li>
</ul>

<h1>
<span id="コンセプト" class="fragment"></span><a href="#%E3%82%B3%E3%83%B3%E3%82%BB%E3%83%97%E3%83%88"><i class="fa fa-link"></i></a>コンセプト</h1>

<p>パーサコンビネータは、単純な部品（パーサ）の組み合わせ（コンビネーション）で構文を解析します。</p>

<p>文字列からアルファベットと数字を分離する例です。<code>#include</code>している<a href="https://bitbucket.org/snippets/7shi/o9dep/revisions/4282afab8b71b96924335c39f8433358ec9c33a4" rel="nofollow noopener" target="_blank">parsecpp.cpp</a>はこの記事で1から作ります。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc123"</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">s1a</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">s1b</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">digit</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">s1b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcde9"</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">s2a</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">s2b</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">digit</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s2a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">s2b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc,123
abcde,9
</pre></div>
</div>

<p>このコードの読み方を説明します。</p>

<ol>
<li>処理対象の文字列<code>"abc123"</code>を<code>s1</code>に代入</li>
<li>
<code>s1</code>から、連続（<code>many</code>）するアルファベット（<code>alpha</code>）を取り出して<code>s1a</code>に代入</li>
<li>
<code>s1</code>の後続の文字列から、連続（<code>many</code>）する数字（<code>digit</code>）を取り出して<code>s1b</code>に代入</li>
<li>
<code>s1a</code>と<code>s1b</code>の中身を確認</li>
<li>別の文字列を同様に処理</li>
</ol>

<p><code>alpha</code>や<code>digit</code>は1文字だけを読み込むパーサです。それらを<code>many</code>というコンビネータと組み合わせることで、複数文字を処理する<code>many(alpha)</code>や<code>many(digit)</code>というパーサを作ります。</p>

<p>正規表現と似たようなものをコードで表現したとイメージすれば良いかもしれません。たとえば<code>many(digit)</code>は正規表現の<code>[0-9]*</code>に相当します。</p>

<table>
<thead>
<tr>
<th>コード</th>
<th>対応する正規表現</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>digit</code></td>
<td><code>[0-9]</code></td>
</tr>
<tr>
<td><code>many</code></td>
<td><code>*</code></td>
</tr>
<tr>
<td><code>many(digit)</code></td>
<td><code>[0-9]*</code></td>
</tr>
</tbody>
</table>

<p>これだけ見ると正規表現の方が簡潔ですが、コードで表現することで複雑なパターンにも対応しやすいという強みがあります。</p>

<p><code>s1</code>や<code>s2</code>は処理するたびに文字を読み進めます。値渡しでは変更（副作用）が加えられないため<code>&amp;s1</code>のようにポインタで渡します。</p>

<p>※ この辺の設計は副作用を排除したHaskellのParsecとは異なりますが、C++で実装しやすくするためのアレンジです。Haskellと完全に同じものをC++で実装したわけではありません。</p>

<h1>
<span id="基礎編" class="fragment"></span><a href="#%E5%9F%BA%E7%A4%8E%E7%B7%A8"><i class="fa fa-link"></i></a>基礎編</h1>

<p>簡単な所から少しずつパーサコンビネータを作り始めます。</p>

<h2>
<span id="1文字取得" class="fragment"></span><a href="#1%E6%96%87%E5%AD%97%E5%8F%96%E5%BE%97"><i class="fa fa-link"></i></a>1文字取得</h2>

<p>指定した文字列から先頭の1文字を取得します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="kt">char</span> <span class="nf">anyChar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">anyChar</span><span class="p">(</span><span class="s">"abc"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
</pre></div>
</div>

<p><code>anyChar</code>が最初のパーサです。</p>

<h3>
<span id="連続呼び出し" class="fragment"></span><a href="#%E9%80%A3%E7%B6%9A%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97"><i class="fa fa-link"></i></a>連続呼び出し</h3>

<p><code>anyChar</code>を連続呼び出しすることで複数文字を取得できるように拡張します。</p>

<p>ポインタをポインタで渡して読み取り後に1文字進めれば、次の呼び出しで次の文字が取得できます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="kt">char</span> <span class="nf">anyChar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">anyChar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">anyChar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
b
</pre></div>
</div>

<p><code>anyChar</code>を2回繰り返すことで、先頭から2文字取得しています。</p>

<h2>
<span id="型エイリアス" class="fragment"></span><a href="#%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9"><i class="fa fa-link"></i></a>型エイリアス</h2>

<p>ポインタのポインタは直感的に分かりにくいので、型エイリアスを導入します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="kt">char</span> <span class="nf">anyChar</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">anyChar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">anyChar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
b
</pre></div>
</div>

<p><code>using</code>での型エイリアスはC++11で導入されました。<code>typedef</code>の機能強化版です。</p>

<h2>
<span id="関数化" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E5%8C%96"><i class="fa fa-link"></i></a>関数化</h2>

<p>2文字取得する部分を関数化します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="kt">char</span> <span class="nf">anyChar</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test1</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 関数化</span>
    <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">});</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">anyChar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test1</span>  <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
bc
</pre></div>
</div>

<p><code>test1</code>は<code>anyChar</code>を組み合わせて作られていますが、利用側からは<code>anyChar</code>と<code>test1</code>が同じように扱えるのがポイントです。ただし戻り値の型が異なるのには注意が必要です。</p>

<h3>
<span id="組み合わせ" class="fragment"></span><a href="#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B"><i class="fa fa-link"></i></a>組み合わせ</h3>

<p><code>test1</code>は、別の箇所で<code>anyChar</code>と組み合わせて利用できます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="kt">char</span> <span class="nf">anyChar</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test1</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">});</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test2</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 追加</span>
    <span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">anyChar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">Source</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
</pre></div>
</div>

<p><code>test1</code>は<code>anyChar</code>を2つ組み合わせて作ったパーサです。<code>test2</code>は<code>test1</code>と<code>anyChar</code>を組み合わせて作ったパーサです。このように簡単なパーサを組み合わせて複雑なパーサを作っていくのが、パーサコンビネータの基本的な考え方です。</p>

<p><code>main</code>の中で<code>anyChar</code>と<code>test1</code>と<code>test2</code>が同列に並んでいますが、どれもパーサとして同じような位置付けだと見立ててください。</p>

<h2>
<span id="テスト関数" class="fragment"></span><a href="#%E3%83%86%E3%82%B9%E3%83%88%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>テスト関数</h2>

<p><code>main()</code>でのテストが煩雑になって来たので、テスト用の関数<code>parseTest</code>を作成します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 追加</span>
<span class="kt">void</span> <span class="n">parseTest</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)(</span><span class="n">Source</span> <span class="o">*</span><span class="p">),</span> <span class="k">const</span> <span class="n">Source</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test1</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">});</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test2</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">anyChar</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test1</span>  <span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span>  <span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
</pre></div>
</div>

<p><code>parseTest</code>にはパーサの関数（<code>anyChar</code>など）を渡しますが、異なる戻り値を受け付けるようにテンプレートを用いて多相化しています。</p>

<h3>
<span id="型エイリアス-1" class="fragment"></span><a href="#%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9-1"><i class="fa fa-link"></i></a>型エイリアス</h3>

<p>関数ポインタの書き方は複雑なので、型エイリアスを定義します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>         <span class="c1">// 追加</span>
<span class="k">using</span> <span class="n">Parser</span> <span class="o">=</span> <span class="n">T</span> <span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="p">);</span>  <span class="c1">// T: 戻り値, (...): 引数</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parseTest</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Source</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test1</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">});</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test2</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">anyChar</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test1</span>  <span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span>  <span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
</pre></div>
</div>

<p>このように<code>using</code>はテンプレートと併用することができます。関数ポインタ型の表現方法も、名前と型が分離されており読みやすいです。これらは<code>typedef</code>に対する改善点です。詳細は次の記事が参考になります。</p>

<ul>
<li>
<a href="/Linda_pp" class="user-mention js-hovercard" title="Linda_pp" data-hovercard-target-type="user" data-hovercard-target-name="Linda_pp">@Linda_pp</a>: <a href="http://qiita.com/Linda_pp/items/44a67c64c14cba00eef1" id="reference-dcebd1367fac31c3cfdc">typedef は C++11 ではオワコン</a> 2014.12.21</li>
</ul>

<h2>
<span id="例外" class="fragment"></span><a href="#%E4%BE%8B%E5%A4%96"><i class="fa fa-link"></i></a>例外</h2>

<p>文字列の末尾に達したかどうかをチェックしていないのは問題です。番兵（<code>'\0'</code>）を確認して例外を発生させるように修正します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Parser</span> <span class="o">=</span> <span class="n">T</span> <span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parseTest</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Source</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// 例外処理</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">**</span><span class="n">s</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span> <span class="k">throw</span> <span class="s">"too short"</span><span class="p">;</span>  <span class="c1">// 例外発生</span>
    <span class="o">++*</span><span class="n">s</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test1</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">});</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test2</span><span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span><span class="p">,</span> <span class="s">"12"</span> <span class="p">);</span>  <span class="c1">// 文字数不足</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span><span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
too short
123
</pre></div>
</div>

<h2>
<span id="stdfunction" class="fragment"></span><a href="#stdfunction"><i class="fa fa-link"></i></a>std::function</h2>

<p>C++11ではラムダ式がサポートされました。ここから先ではラムダ式を多用しますが、関数ポインタでは扱えません。そのため関数ポインタを<code>std::function</code>で置き換えます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;functional&gt;  </span><span class="c1">// 追加</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Parser</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span> <span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// 修正</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parseTest</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Source</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// ラムダ式化</span>
    <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">**</span><span class="n">s</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span> <span class="k">throw</span> <span class="s">"too short"</span><span class="p">;</span>
    <span class="o">++*</span><span class="n">s</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// ラムダ式化</span>
    <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">});</span>
<span class="p">};</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// ラムダ式化</span>
    <span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span><span class="p">,</span> <span class="s">"12"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span><span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
too short
123
</pre></div>
</div>

<p><code>std::function</code>に対して関数を渡しても自動で変換されますが、テンプレートで多相化されていると明示的な変換が必要になります。その面倒を避けるため<code>anyChar</code>などをラムダ式化しています。</p>

<h2>
<span id="条件取得" class="fragment"></span><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%96%E5%BE%97"><i class="fa fa-link"></i></a>条件取得</h2>

<p><code>anyChar</code>は無条件で文字を取得していましたが、条件が指定できる<code>satisfy</code>を追加します。引数で渡された関数を<code>[=]</code>でキャプチャしたクロージャを返します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;functional&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Parser</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span> <span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parseTest</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Source</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">**</span><span class="n">s</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span> <span class="k">throw</span> <span class="s">"too short"</span><span class="p">;</span>
    <span class="o">++*</span><span class="n">s</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">satisfy</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 追加</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">**</span><span class="n">s</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span> <span class="k">throw</span> <span class="s">"too short"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="k">throw</span> <span class="s">"not satisfy"</span><span class="p">;</span>
        <span class="o">++*</span><span class="n">s</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">isDigit</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">satisfy</span><span class="p">(</span><span class="n">isDigit</span><span class="p">),</span> <span class="s">"abc"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">satisfy</span><span class="p">(</span><span class="n">isDigit</span><span class="p">),</span> <span class="s">"123"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
1
</pre></div>
</div>

<p>今回の機能追加に直接関係ない<code>test1</code>と<code>test2</code>は削除しました。</p>

<h3>
<span id="共通化" class="fragment"></span><a href="#%E5%85%B1%E9%80%9A%E5%8C%96"><i class="fa fa-link"></i></a>共通化</h3>

<p><code>anyChar</code>と<code>satisfy</code>でほとんどの処理が重複しています。<code>anyChar</code>は無条件の<code>satisfy</code>として定義することで共通化を図ります。</p>

<p>※ 前方参照（使用箇所よりも下で定義された関数を使用すること）できないため、<code>anyChar</code>は<code>satisfy</code>の下に移動します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;functional&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Parser</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span> <span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parseTest</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Source</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">satisfy</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">**</span><span class="n">s</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span> <span class="k">throw</span> <span class="s">"too short"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="k">throw</span> <span class="s">"not satisfy"</span><span class="p">;</span>
        <span class="o">++*</span><span class="n">s</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="n">satisfy</span><span class="p">([](</span><span class="kt">char</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">});</span>  <span class="c1">// 移動・修正</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">anyChar</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
</pre></div>
</div>

<h2>
<span id="ファイル分割" class="fragment"></span><a href="#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2"><i class="fa fa-link"></i></a>ファイル分割</h2>

<p>コードが長くなって来たため、汎用部分を別ファイルに分離します。ファイル名の<code>parsecpp</code>は<code>ParseC++</code>のつもりです。</p>

<div class="code-frame" data-lang="c++">
<div class="code-lang"><span class="bold">parsecpp.cpp</span></div>
<div class="highlight"><pre>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;functional&gt;</span>

<span class="k">using</span> <span class="n">Source</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Parser</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span> <span class="p">(</span><span class="n">Source</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parseTest</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Source</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">satisfy</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">**</span><span class="n">s</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span> <span class="k">throw</span> <span class="s">"too short"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="k">throw</span> <span class="s">"not satisfy"</span><span class="p">;</span>
        <span class="o">++*</span><span class="n">s</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="n">satisfy</span><span class="p">([](</span><span class="kt">char</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>

<p>簡単のためヘッダではなく直に<code>#include</code>して使います。</p>

<p>※ もし実用化するのであればヘッダも作成する必要がありますが、今回は説明が目的として割り切ります。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">anyChar</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
</pre></div>
</div>

<h2>
<span id="文字判定" class="fragment"></span><a href="#%E6%96%87%E5%AD%97%E5%88%A4%E5%AE%9A"><i class="fa fa-link"></i></a>文字判定</h2>

<p>文字を指定して判定するパーサを実装します。Parsecでは<code>char</code>ですが、型と被るため<code>char1</code>に名前を変更します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="n">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">char1</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">satisfy</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="n">ch</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>

<p><code>char1</code>は引数<code>ch</code>を<code>[=]</code>でキャプチャしたクロージャを返しているのがポイントです。今後このようなパターンがよく出て来ます。</p>

<p>動作を確認します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="s">"abc"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="s">"123"</span><span class="p">);</span>  <span class="c1">// NG</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
not satisfy
</pre></div>
</div>

<h2>
<span id="事前定義" class="fragment"></span><a href="#%E4%BA%8B%E5%89%8D%E5%AE%9A%E7%BE%A9"><i class="fa fa-link"></i></a>事前定義</h2>

<p><code>satisfy</code>で条件を指定するのは冗長なので、よく使うパターンを事前定義します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="kt">bool</span> <span class="nf">isDigit</span>   <span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isUpper</span>   <span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">'A'</span> <span class="o">&lt;=</span> <span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isLower</span>   <span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">'a'</span> <span class="o">&lt;=</span> <span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isAlpha</span>   <span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">isUpper</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">||</span> <span class="n">isLower</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isAlphaNum</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">isAlpha</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">||</span> <span class="n">isDigit</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isLetter</span>  <span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">isAlpha</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'_'</span><span class="p">;</span>   <span class="p">}</span>

<span class="k">auto</span> <span class="n">digit</span>    <span class="o">=</span> <span class="n">satisfy</span><span class="p">(</span><span class="n">isDigit</span>   <span class="p">);</span>
<span class="k">auto</span> <span class="n">upper</span>    <span class="o">=</span> <span class="n">satisfy</span><span class="p">(</span><span class="n">isUpper</span>   <span class="p">);</span>
<span class="k">auto</span> <span class="n">lower</span>    <span class="o">=</span> <span class="n">satisfy</span><span class="p">(</span><span class="n">isLower</span>   <span class="p">);</span>
<span class="k">auto</span> <span class="n">alpha</span>    <span class="o">=</span> <span class="n">satisfy</span><span class="p">(</span><span class="n">isAlpha</span>   <span class="p">);</span>
<span class="k">auto</span> <span class="n">alphaNum</span> <span class="o">=</span> <span class="n">satisfy</span><span class="p">(</span><span class="n">isAlphaNum</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">letter</span>   <span class="o">=</span> <span class="n">satisfy</span><span class="p">(</span><span class="n">isLetter</span>  <span class="p">);</span>
</pre></div>
</div>

<p>動作を確認します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">digit</span> <span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">digit</span> <span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>  <span class="c1">// NG</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
1
a
not satisfy
</pre></div>
</div>

<h2>
<span id="組み合わせ判定" class="fragment"></span><a href="#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E5%88%A4%E5%AE%9A"><i class="fa fa-link"></i></a>組み合わせ判定</h2>

<p>先ほど追加したパーサを組み合わせて、先頭から「アルファベット」「数字」「数字」という組み合わせを判定するパーサを作ります。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">test3</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">letter</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">digit</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">x3</span> <span class="o">=</span> <span class="n">digit</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">});</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"abc"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"123"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"a23"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"a234"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
not satisfy
a23
a23
</pre></div>
</div>

<h2>
<span id="コンビネータの定義" class="fragment"></span><a href="#%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%AE%E5%AE%9A%E7%BE%A9"><i class="fa fa-link"></i></a>コンビネータの定義</h2>

<p>パーサ同士を組み合わせて新しいパーサを作り出す関数を<strong>コンビネータ</strong>と呼びます。</p>

<p>いくつか便利なコンビネータを定義します。</p>

<h3>
<span id="結合" class="fragment"></span><a href="#%E7%B5%90%E5%90%88"><i class="fa fa-link"></i></a>結合</h3>

<p>パーサを結合する演算子<code>+</code>を定義してparsecpp.cppに追加します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">y</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>

<p><code>test3</code>がとても簡単になります。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">digit</span> <span class="o">+</span> <span class="n">digit</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"abc"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"123"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"a23"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"a234"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
not satisfy
a23
a23
</pre></div>
</div>

<p>処理が関数を定義しなくても組み合わせで表現されています。この感覚がつかめれば、パーサコンビネータが見えて来ます。</p>

<h3>
<span id="繰り返し" class="fragment"></span><a href="#%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97"><i class="fa fa-link"></i></a>繰り返し</h3>

<p>掛け算の演算子で繰り返し回数を指定できるようにします。掛け算の順序を気にしなくても済むように、2つのパターンを定義します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="n">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>

<p><code>test3</code>が更に簡単になります。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">letter</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">digit</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"abc"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"123"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"a23"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span><span class="p">,</span> <span class="s">"a234"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
not satisfy
a23
a23
</pre></div>
</div>

<p>コンビネータの定義はラムダ式を返す関数になっていて少し複雑ですが、利用側はとても簡単に書けます。</p>

<h2>
<span id="many" class="fragment"></span><a href="#many"><i class="fa fa-link"></i></a>many</h2>

<p>繰り返しに関連して、最初のコンセプトで出て来た<code>many</code>を実装してみます。</p>

<p><code>many</code>は指定したパーサを0回以上適用して返すコンビネータです。エラーになるまで読み進めれば実装できます。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">many</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(;;)</span> <span class="n">ret</span> <span class="o">+=</span> <span class="n">p</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>

<p>先頭からアルファベットだけを抜き出してみます。1文字も一致しなくても、エラーにはならずに空文字列が返ります。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">test4</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test4</span><span class="p">,</span> <span class="s">"abc123"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test4</span><span class="p">,</span> <span class="s">"123abc"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc
     ← 空行
</pre></div>
</div>

<p>最初に出て来たサンプルも動きます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc123"</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">s1a</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">s1b</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">digit</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">s1b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcde9"</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">s2a</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">s2b</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">digit</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s2a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">s2b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc,123
abcde,9
</pre></div>
</div>

<h2>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h2>

<p>ここまでがパーサコンビネータの動作原理を理解するために最低限必要な実装です。</p>

<p>このセクションで登場したテストを1つにまとめます。</p>

<ul>
<li><a href="https://bitbucket.org/snippets/7shi/o9dep/revisions/645de09ce4f9e53e4dbab48f403521b12f2d0af7" rel="nofollow noopener" target="_blank">ここまでの parsecpp.cpp</a></li>
</ul>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">anyChar</span> <span class="o">+</span> <span class="n">anyChar</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">test1</span> <span class="o">+</span> <span class="n">anyChar</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">letter</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">digit</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test4</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">anyChar</span>   <span class="p">,</span> <span class="s">"abc"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test1</span>     <span class="p">,</span> <span class="s">"abc"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span>     <span class="p">,</span> <span class="s">"abc"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span>     <span class="p">,</span> <span class="s">"12"</span>    <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span>     <span class="p">,</span> <span class="s">"123"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="s">"abc"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="s">"123"</span>   <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">digit</span>     <span class="p">,</span> <span class="s">"abc"</span>   <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">digit</span>     <span class="p">,</span> <span class="s">"123"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">letter</span>    <span class="p">,</span> <span class="s">"abc"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">letter</span>    <span class="p">,</span> <span class="s">"123"</span>   <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span>     <span class="p">,</span> <span class="s">"abc"</span>   <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span>     <span class="p">,</span> <span class="s">"123"</span>   <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span>     <span class="p">,</span> <span class="s">"a23"</span>   <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span>     <span class="p">,</span> <span class="s">"a234"</span>  <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test4</span>     <span class="p">,</span> <span class="s">"abc123"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test4</span>     <span class="p">,</span> <span class="s">"123abc"</span><span class="p">);</span>

    <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc123"</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">s1a</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">s1b</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">digit</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">s1b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abcde9"</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">s2a</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">alpha</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">s2b</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">digit</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s2a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">s2b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
too short
123
a
not satisfy
not satisfy
1
a
not satisfy
not satisfy
not satisfy
a23
a23
abc

abc,123
abcde,9
</pre></div>
</div>

<p>最初にコンセプトで提示したコードを見たときはモヤっとしていた部分も、少しはすっきりしたでしょうか。</p>

<h1>
<span id="選択" class="fragment"></span><a href="#%E9%81%B8%E6%8A%9E"><i class="fa fa-link"></i></a>選択</h1>

<p>非常によく使うのが選択のコンビネータです。</p>

<p>便利なだけでなく、色々と悩ましい問題があるのを見ていきます。</p>

<h2>
<span id="単純な実装" class="fragment"></span><a href="#%E5%8D%98%E7%B4%94%E3%81%AA%E5%AE%9F%E8%A3%85"><i class="fa fa-link"></i></a>単純な実装</h2>

<p>「または」を表現する演算子<code>||</code>を実装します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">||</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">ret</span><span class="p">;</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">p1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">p2</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>

<p><code>||</code>を使えば「アルファベットまたは数字」のような選択的なパーサが構築できます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">test5</span> <span class="o">=</span> <span class="n">letter</span> <span class="o">||</span> <span class="n">digit</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test5</span><span class="p">,</span> <span class="s">"a"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test5</span><span class="p">,</span> <span class="s">"1"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test5</span><span class="p">,</span> <span class="s">"!"</span><span class="p">);</span>  <span class="c1">// NG</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
1
not satisfy
</pre></div>
</div>

<h3>
<span id="manyとの組み合わせ" class="fragment"></span><a href="#many%E3%81%A8%E3%81%AE%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B"><i class="fa fa-link"></i></a>manyとの組み合わせ</h3>

<p>選択的パーサを<code>many</code>で繰り返すこともできます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">test6</span> <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">letter</span> <span class="o">||</span> <span class="n">digit</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test6</span><span class="p">,</span> <span class="s">"abc123"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test6</span><span class="p">,</span> <span class="s">"123abc"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc123
123abc
</pre></div>
</div>

<h2>
<span id="結合と選択" class="fragment"></span><a href="#%E7%B5%90%E5%90%88%E3%81%A8%E9%81%B8%E6%8A%9E"><i class="fa fa-link"></i></a>結合と選択</h2>

<p><code>||</code>を少し使ってみると、直感に反した動きに気付きます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">test7</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span><span class="p">,</span> <span class="s">"ab"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span><span class="p">,</span> <span class="s">"cb"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span><span class="p">,</span> <span class="s">"acb"</span><span class="p">);</span>  <span class="c1">// ???</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
cb
cb
</pre></div>
</div>

<p><code>test7</code>を素直に見ると「<code>"ab"</code>または<code>"cb"</code>」となり、確かにその両方にマッチします。しかし<code>"acb"</code>にもマッチしてしまいます。これは<code>||</code>に達する前に<code>'a'</code>だけは読み進めてしまったため、<code>||</code>の後のパターンにマッチしてしまうためです。</p>

<h2>
<span id="エラー化" class="fragment"></span><a href="#%E3%82%A8%E3%83%A9%E3%83%BC%E5%8C%96"><i class="fa fa-link"></i></a>エラー化</h2>

<p>このようなケースはParsecではエラーになります。</p>

<p><code>左 || 右</code>として、左のパーサが内部で複数のパーサから構成されるとき、そのうち1つでも成功してその後で失敗したなら、右のパーサは処理されずにエラーになるという仕様です。</p>

<p>最初の状態を保持しておいて、<code>||</code>の前で読み進めていれば例外を再送します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（修正）</span></div>
<div class="highlight"><pre>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">||</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">ret</span><span class="p">;</span>
        <span class="n">Source</span> <span class="n">bak</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>           <span class="c1">// 追加</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">p1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">!=</span> <span class="n">bak</span><span class="p">)</span> <span class="k">throw</span><span class="p">;</span>  <span class="c1">// 追加</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">p2</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>

<p>先ほどと同じコードを試すと、最後がエラーになります。Parsecと同じで意図した動きです。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">test7</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span><span class="p">,</span> <span class="s">"ab"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span><span class="p">,</span> <span class="s">"cb"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span><span class="p">,</span> <span class="s">"acb"</span><span class="p">);</span>  <span class="c1">// NG</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
cb
not satisfy
</pre></div>
</div>

<h2>
<span id="共通部分" class="fragment"></span><a href="#%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86"><i class="fa fa-link"></i></a>共通部分</h2>

<p>選択肢の先頭に共通部分があった場合、意図せずエラーになることがあります。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span><span class="p">,</span> <span class="s">"ab"</span> <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span><span class="p">,</span> <span class="s">"ac"</span> <span class="p">);</span>  <span class="c1">// NG</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
</pre></div>
</div>

<p>このようなケースでは、共通部分を括り出すことで対処できます。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test9</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">||</span> <span class="n">c</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span><span class="p">,</span> <span class="s">"ac"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test9</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test9</span><span class="p">,</span> <span class="s">"ac"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
ab
ac
</pre></div>
</div>

<p>別の方法として状態を巻き戻す方法もあります。</p>

<h2>
<span id="バックトラック" class="fragment"></span><a href="#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>バックトラック</h2>

<p>パースに失敗したとき、状態を巻き戻して別の方法でパースをやり直すことを<strong>バックトラック</strong>と呼びます。</p>

<h3>
<span id="tryp" class="fragment"></span><a href="#tryp"><i class="fa fa-link"></i></a>tryp</h3>

<p>Parsecでバックトラックするには対象となるパーサを<code>try</code>で囲みます。例外処理の<code>try</code>と名前が被るため、ここでは<code>tryp</code>に名前を変更します。（<code>p</code>はParserの頭文字です）</p>

<p><code>tryp</code>の中で失敗すれば元の状態に戻してから例外を再送します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tryp</span><span class="p">(</span><span class="k">const</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">ret</span><span class="p">;</span>
        <span class="n">Source</span> <span class="n">bak</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">bak</span><span class="p">;</span>
            <span class="k">throw</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>

<p><code>||</code>の左側を<code>tryp</code>で囲めば、失敗してもバックトラックしてから右側が処理されます。</p>

<p>先ほどの<code>test8</code>と<code>test9</code>と挙動を比較します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">test8</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>  <span class="o">||</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test9</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">||</span> <span class="n">c</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">test10</span> <span class="o">=</span> <span class="n">tryp</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">||</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span> <span class="p">,</span> <span class="s">"ab"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span> <span class="p">,</span> <span class="s">"ac"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test9</span> <span class="p">,</span> <span class="s">"ab"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test9</span> <span class="p">,</span> <span class="s">"ac"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test10</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test10</span><span class="p">,</span> <span class="s">"ac"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
ab
ac
ab
ac
</pre></div>
</div>

<p><code>test9</code>と<code>test10</code>は同じ動きです。</p>

<h2>
<span id="string" class="fragment"></span><a href="#string"><i class="fa fa-link"></i></a>string</h2>

<p>1文字ずつ<code>char1</code>でパースすると面倒なため、文字列で指定できる<code>string</code>を実装します。</p>

<div class="code-frame" data-lang="cpp">
<div class="code-lang"><span class="bold">parsecpp.cpp（追加）</span></div>
<div class="highlight"><pre>
<span class="n">Parser</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">string</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Source</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">char1</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>

<p>内部では1文字ずつ処理されているため、途中の失敗をバックトラックするには<code>tryp</code>が必要です。</p>

<p>挙動を確認します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">test11</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="s">"ab"</span><span class="p">)</span> <span class="o">||</span> <span class="n">string</span><span class="p">(</span><span class="s">"ac"</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">test12</span> <span class="o">=</span> <span class="n">tryp</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"ab"</span><span class="p">))</span> <span class="o">||</span> <span class="n">string</span><span class="p">(</span><span class="s">"ac"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test11</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test11</span><span class="p">,</span> <span class="s">"ac"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test12</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test12</span><span class="p">,</span> <span class="s">"ac"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
ab
ac
</pre></div>
</div>

<h2>
<span id="まとめ-1" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81-1"><i class="fa fa-link"></i></a>まとめ</h2>

<p>このセクションで登場したテストを1つにまとめます。</p>

<ul>
<li><a href="https://bitbucket.org/snippets/7shi/o9dep/revisions/daff7dd17df16439d6adf1622367ef5bee57a739" rel="nofollow noopener" target="_blank">ここまでの parsecpp.cpp</a></li>
</ul>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">test5</span>  <span class="o">=</span> <span class="n">letter</span> <span class="o">||</span> <span class="n">digit</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test6</span>  <span class="o">=</span> <span class="n">many</span><span class="p">(</span><span class="n">letter</span> <span class="o">||</span> <span class="n">digit</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">test7</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test8</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test9</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">||</span> <span class="n">c</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">test10</span> <span class="o">=</span> <span class="n">tryp</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">||</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test11</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="s">"ab"</span><span class="p">)</span> <span class="o">||</span> <span class="n">string</span><span class="p">(</span><span class="s">"ac"</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">test12</span> <span class="o">=</span> <span class="n">tryp</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"ab"</span><span class="p">))</span> <span class="o">||</span> <span class="n">string</span><span class="p">(</span><span class="s">"ac"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test5</span> <span class="p">,</span> <span class="s">"a"</span>     <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test5</span> <span class="p">,</span> <span class="s">"1"</span>     <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test5</span> <span class="p">,</span> <span class="s">"!"</span>     <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test6</span> <span class="p">,</span> <span class="s">"abc123"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test6</span> <span class="p">,</span> <span class="s">"123abc"</span><span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span> <span class="p">,</span> <span class="s">"ab"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span> <span class="p">,</span> <span class="s">"cb"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span> <span class="p">,</span> <span class="s">"acb"</span>   <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span> <span class="p">,</span> <span class="s">"ab"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span> <span class="p">,</span> <span class="s">"ac"</span>    <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test9</span> <span class="p">,</span> <span class="s">"ab"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test9</span> <span class="p">,</span> <span class="s">"ac"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test10</span><span class="p">,</span> <span class="s">"ab"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test10</span><span class="p">,</span> <span class="s">"ac"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test11</span><span class="p">,</span> <span class="s">"ab"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test11</span><span class="p">,</span> <span class="s">"ac"</span>    <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test12</span><span class="p">,</span> <span class="s">"ab"</span>    <span class="p">);</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test12</span><span class="p">,</span> <span class="s">"ac"</span>    <span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
1
not satisfy
abc123
123abc
ab
cb
not satisfy
ab
not satisfy
ab
ac
ab
ac
ab
not satisfy
ab
ac
</pre></div>
</div>

<h1>
<span id="エラー表示" class="fragment"></span><a href="#%E3%82%A8%E3%83%A9%E3%83%BC%E8%A1%A8%E7%A4%BA"><i class="fa fa-link"></i></a>エラー表示</h1>

<p>エラーが<code>too short</code>や<code>not satisfy</code>では分かりにくいので改善します。</p>

<p>このセクションは修正箇所が多いため差分と全体の両方を示します。</p>

<h2>
<span id="クラス化" class="fragment"></span><a href="#%E3%82%AF%E3%83%A9%E3%82%B9%E5%8C%96"><i class="fa fa-link"></i></a>クラス化</h2>

<p><code>Source</code>をクラス化します。</p>

<p>差分を示します。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- parsecpp.cpp.orig</span>
<span class="gi">+++ parsecpp.cpp</span>
<span class="gu">@@ -2,7 +2,26 @@</span>
 #include &lt;string&gt;
 #include &lt;functional&gt;

<span class="gd">-using Source = const char *;</span>
<span class="gi">+class Source {</span>
<span class="gi">+    const char *s;</span>
<span class="gi">+public:</span>
<span class="gi">+    Source(const char *s) : s(s) {}</span>
<span class="gi">+    char peek() {</span>
<span class="gi">+        char ch = *s;</span>
<span class="gi">+        if (!ch) throw "too short";</span>
<span class="gi">+        return ch;</span>
<span class="gi">+    }</span>
<span class="gi">+    void next() {</span>
<span class="gi">+        peek();</span>
<span class="gi">+        ++s;</span>
<span class="gi">+    }</span>
<span class="gi">+    bool operator==(const Source &amp;src) const {</span>
<span class="gi">+        return s == src.s;</span>
<span class="gi">+    }</span>
<span class="gi">+    bool operator!=(const Source &amp;src) const {</span>
<span class="gi">+        return !(*this == src);</span>
<span class="gi">+    }</span>
<span class="gi">+};</span>

 template &lt;typename T&gt;
 using Parser = std::function&lt;T (Source *)&gt;;
<span class="gu">@@ -19,10 +38,9 @@</span>

 Parser&lt;char&gt; satisfy(const std::function&lt;bool (char)&gt; &amp;f) {
     return [=](Source *s) {
<span class="gd">-        char ch = **s;</span>
<span class="gd">-        if (!ch) throw "too short";</span>
<span class="gi">+        char ch = s-&gt;peek();</span>
         if (!f(ch)) throw "not satisfy";
<span class="gd">-        ++*s;</span>
<span class="gi">+        s-&gt;next();</span>
         return ch;
     };
 }
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/snippets/7shi/o9dep/revisions/d389835c0cc3798ec3b68bddf7901d1a89d343ca" rel="nofollow noopener" target="_blank">修正後の parsecpp.cpp</a></li>
</ul>

<p><code>satisfy</code>は二重デリファレンスやポインタ演算がなくなり、読みやすくなりました。</p>

<p>まだ動作結果に変化はありません。エラーが出るものだけ抽出して確認します。</p>

<div class="code-frame" data-lang="cpp"><div class="highlight"><pre>
<span class="cp">#include "parsecpp.cpp"</span>

<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">anyChar</span> <span class="o">+</span> <span class="n">anyChar</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">test1</span> <span class="o">+</span> <span class="n">anyChar</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">letter</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">digit</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test5</span>  <span class="o">=</span> <span class="n">letter</span> <span class="o">||</span> <span class="n">digit</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test7</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test8</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">||</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">test11</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="s">"ab"</span><span class="p">)</span> <span class="o">||</span> <span class="n">string</span><span class="p">(</span><span class="s">"ac"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test2</span>     <span class="p">,</span> <span class="s">"12"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">char1</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="s">"123"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">digit</span>     <span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">letter</span>    <span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span>     <span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test3</span>     <span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test5</span>     <span class="p">,</span> <span class="s">"!"</span>  <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test7</span>     <span class="p">,</span> <span class="s">"acb"</span><span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test8</span>     <span class="p">,</span> <span class="s">"ac"</span> <span class="p">);</span>  <span class="c1">// NG</span>
    <span class="n">parseTest</span><span class="p">(</span><span class="n">test11</span>    <span class="p">,</span> <span class="s">"ac"</span> <span class="p">);</span>  <span class="c1">// NG</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
too short
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
</pre></div>
</div>

<h2>
<span id="位置" class="fragment"></span><a href="#%E4%BD%8D%E7%BD%AE"><i class="fa fa-link"></i></a>位置</h2>

<p><code>Source</code>に位置（行と桁）を保持してエラーメッセージに含めます。文字列を作る必要があるため、例外を<code>std::string</code>で送出します。</p>

<p>差分を示します。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- parsecpp.cpp.orig</span>
<span class="gi">+++ parsecpp.cpp</span>
<span class="gu">@@ -1,19 +1,31 @@</span>
 #include &lt;iostream&gt;
<span class="gi">+#include &lt;sstream&gt;</span>
 #include &lt;string&gt;
 #include &lt;functional&gt;

 class Source {
     const char *s;
<span class="gi">+    int line, col;</span>
 public:
<span class="gd">-    Source(const char *s) : s(s) {}</span>
<span class="gi">+    Source(const char *s) : s(s), line(1), col(1) {}</span>
     char peek() {
         char ch = *s;
<span class="gd">-        if (!ch) throw "too short";</span>
<span class="gi">+        if (!ch) throw ex("too short");</span>
         return ch;
     }
     void next() {
<span class="gd">-        peek();</span>
<span class="gi">+        char ch = peek();</span>
<span class="gi">+        if (ch == '\n') {</span>
<span class="gi">+            ++line;</span>
<span class="gi">+            col = 0;</span>
<span class="gi">+        }</span>
         ++s;
<span class="gi">+        ++col;</span>
<span class="gi">+    }</span>
<span class="gi">+    std::string ex(const std::string &amp;e) {</span>
<span class="gi">+        std::ostringstream oss;</span>
<span class="gi">+        oss &lt;&lt; "[line " &lt;&lt; line &lt;&lt; ", col " &lt;&lt; col &lt;&lt; "] " &lt;&lt; e;</span>
<span class="gi">+        return oss.str();</span>
     }
     bool operator==(const Source &amp;src) const {
         return s == src.s;
<span class="gu">@@ -31,7 +43,7 @@</span>
     Source s = src;
     try {
         std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
<span class="gd">-    } catch (const char *e) {</span>
<span class="gi">+    } catch (const std::string &amp;e) {</span>
         std::cout &lt;&lt; e &lt;&lt; std::endl;
     }
 }
<span class="gu">@@ -39,7 +51,7 @@</span>
 Parser&lt;char&gt; satisfy(const std::function&lt;bool (char)&gt; &amp;f) {
     return [=](Source *s) {
         char ch = s-&gt;peek();
<span class="gd">-        if (!f(ch)) throw "not satisfy";</span>
<span class="gi">+        if (!f(ch)) throw s-&gt;ex("not satisfy");</span>
         s-&gt;next();
         return ch;
     };
<span class="gu">@@ -96,7 +108,7 @@</span>
         std::string ret;
         try {
             for (;;) ret += p(s);
<span class="gd">-        } catch (const char *) {}</span>
<span class="gi">+        } catch (const std::string &amp;) {}</span>
         return ret;
     };
 }
<span class="gu">@@ -108,7 +120,7 @@</span>
         Source bak = *s;
         try {
             ret = p1(s);
<span class="gd">-        } catch (const char *) {</span>
<span class="gi">+        } catch (const std::string &amp;) {</span>
             if (*s != bak) throw;
             ret = p2(s);
         }
<span class="gu">@@ -123,7 +135,7 @@</span>
         Source bak = *s;
         try {
             ret = p(s);
<span class="gd">-        } catch (const char *) {</span>
<span class="gi">+        } catch (const std::string &amp;) {</span>
             *s = bak;
             throw;
         }
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/snippets/7shi/o9dep/revisions/800b28ab89fdd850dfef91f7b8dbbddb931cbcea" rel="nofollow noopener" target="_blank">修正後の parsecpp.cpp</a></li>
</ul>

<p>先ほどと同じコードをテストして、エラーの変化を確認します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[line 1, col 3] too short
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
</pre></div>
</div>

<p>どこでエラーが発生したか分かるようになりました。</p>

<h2>
<span id="対象の文字" class="fragment"></span><a href="#%E5%AF%BE%E8%B1%A1%E3%81%AE%E6%96%87%E5%AD%97"><i class="fa fa-link"></i></a>対象の文字</h2>

<p>どの文字でエラーになったかをエラーメッセージに含めます。</p>

<p>差分を示します。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- parsecpp.cpp.orig</span>
<span class="gi">+++ parsecpp.cpp</span>
<span class="gu">@@ -25,6 +25,7 @@</span>
     std::string ex(const std::string &amp;e) {
         std::ostringstream oss;
         oss &lt;&lt; "[line " &lt;&lt; line &lt;&lt; ", col " &lt;&lt; col &lt;&lt; "] " &lt;&lt; e;
<span class="gi">+        if (*s) oss &lt;&lt; ": '" &lt;&lt; *s &lt;&lt; "'";</span>
         return oss.str();
     }
     bool operator==(const Source &amp;src) const {
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/snippets/7shi/o9dep/revisions/47581204d9245b8897a28dbea60cc7928a5692c9" rel="nofollow noopener" target="_blank">修正後の parsecpp.cpp</a></li>
</ul>

<p>先ほどと同じコードをテストして、エラーの変化を確認します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[line 1, col 3] too short
[line 1, col 1] not satisfy: '1'
[line 1, col 1] not satisfy: 'a'
[line 1, col 1] not satisfy: '1'
[line 1, col 2] not satisfy: 'b'
[line 1, col 1] not satisfy: '1'
[line 1, col 1] not satisfy: '!'
[line 1, col 2] not satisfy: 'c'
[line 1, col 2] not satisfy: 'c'
[line 1, col 2] not satisfy: 'c'
</pre></div>
</div>

<p>どの文字でエラーになったのかが分かるようになりました。</p>

<h2>
<span id="失敗の確定" class="fragment"></span><a href="#%E5%A4%B1%E6%95%97%E3%81%AE%E7%A2%BA%E5%AE%9A"><i class="fa fa-link"></i></a>失敗の確定</h2>

<p>失敗を確定させて指定したメッセージで例外を発生させる<code>left</code>を実装します。</p>

<p>※ 英語でrightは「右」の他に「正しい」という意味がありますが、その反対を意図して<code>left</code>と命名されました。ある種の言葉遊びで、英語としての単語に「誤り」という意味があるわけではありません。</p>

<p><code>||</code>と<code>left</code>を組み合わせれば、エラーメッセージがカスタマイズできます。前方参照の関係で定義位置の移動が必要です。</p>

<p>差分を示します。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- parsecpp.cpp.orig</span>
<span class="gi">+++ parsecpp.cpp</span>
<span class="gu">@@ -60,24 +60,6 @@</span>

 auto anyChar = satisfy([](char) { return true; });

<span class="gd">-Parser&lt;char&gt; char1(char ch) {</span>
<span class="gd">-    return satisfy([=](char c) { return c == ch; });</span>
<span class="gd">-}</span>
<span class="gd">-</span>
<span class="gd">-bool isDigit   (char ch) { return '0' &lt;= ch &amp;&amp; ch &lt;= '9'; }</span>
<span class="gd">-bool isUpper   (char ch) { return 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z'; }</span>
<span class="gd">-bool isLower   (char ch) { return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z'; }</span>
<span class="gd">-bool isAlpha   (char ch) { return isUpper(ch) || isLower(ch); }</span>
<span class="gd">-bool isAlphaNum(char ch) { return isAlpha(ch) || isDigit(ch); }</span>
<span class="gd">-bool isLetter  (char ch) { return isAlpha(ch) || ch == '_';   }</span>
<span class="gd">-</span>
<span class="gd">-auto digit    = satisfy(isDigit   );</span>
<span class="gd">-auto upper    = satisfy(isUpper   );</span>
<span class="gd">-auto lower    = satisfy(isLower   );</span>
<span class="gd">-auto alpha    = satisfy(isAlpha   );</span>
<span class="gd">-auto alphaNum = satisfy(isAlphaNum);</span>
<span class="gd">-auto letter   = satisfy(isLetter  );</span>
<span class="gd">-</span>
 template &lt;typename T1, typename T2&gt;
 Parser&lt;std::string&gt; operator+(const Parser&lt;T1&gt; &amp;x, const Parser&lt;T2&gt; &amp;y) {
     return [=](Source *s) {
<span class="gu">@@ -144,11 +126,40 @@</span>
     };
 }

<span class="gi">+template &lt;typename T&gt;</span>
<span class="gi">+Parser&lt;T&gt; left(const std::string &amp;e) {</span>
<span class="gi">+    return [=](Source *s) -&gt; T {</span>
<span class="gi">+        throw s-&gt;ex(e);</span>
<span class="gi">+    };</span>
<span class="gi">+}</span>
<span class="gi">+Parser&lt;char&gt; left(const std::string &amp;e) {</span>
<span class="gi">+    return left&lt;char&gt;(e);</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+Parser&lt;char&gt; char1(char ch) {</span>
<span class="gi">+    return satisfy([=](char c) { return c == ch; })</span>
<span class="gi">+        || left(std::string("not char '") + ch + "'");</span>
<span class="gi">+}</span>
<span class="gi">+</span>
 Parser&lt;std::string&gt; string(const std::string &amp;str) {
     return [=](Source *s) {
         for (auto it = str.begin(); it != str.end(); ++it) {
<span class="gd">-            char1(*it)(s);</span>
<span class="gi">+            (char1(*it) || left("not string \"" + str + "\""))(s);</span>
         }
         return str;
     };
 }
<span class="gi">+</span>
<span class="gi">+bool isDigit   (char ch) { return '0' &lt;= ch &amp;&amp; ch &lt;= '9'; }</span>
<span class="gi">+bool isUpper   (char ch) { return 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z'; }</span>
<span class="gi">+bool isLower   (char ch) { return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z'; }</span>
<span class="gi">+bool isAlpha   (char ch) { return isUpper(ch) || isLower(ch); }</span>
<span class="gi">+bool isAlphaNum(char ch) { return isAlpha(ch) || isDigit(ch); }</span>
<span class="gi">+bool isLetter  (char ch) { return isAlpha(ch) || ch == '_';   }</span>
<span class="gi">+</span>
<span class="gi">+auto digit    = satisfy(isDigit   ) || left("not digit"   );</span>
<span class="gi">+auto upper    = satisfy(isUpper   ) || left("not upper"   );</span>
<span class="gi">+auto lower    = satisfy(isLower   ) || left("not lower"   );</span>
<span class="gi">+auto alpha    = satisfy(isAlpha   ) || left("not alpha"   );</span>
<span class="gi">+auto alphaNum = satisfy(isAlphaNum) || left("not alphaNum");</span>
<span class="gi">+auto letter   = satisfy(isLetter  ) || left("not letter"  );</span>
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/snippets/7shi/o9dep/revisions/4282afab8b71b96924335c39f8433358ec9c33a4" rel="nofollow noopener" target="_blank">修正後の parsecpp.cpp</a></li>
</ul>

<p>型推論の弱さを補うため、<code>left</code>は特殊化したオーバーロードを実装しています。</p>

<p>先ほどと同じコードをテストして、エラーの変化を確認します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[line 1, col 3] too short
[line 1, col 1] not char 'a': '1'
[line 1, col 1] not digit: 'a'
[line 1, col 1] not letter: '1'
[line 1, col 2] not digit: 'b'
[line 1, col 1] not letter: '1'
[line 1, col 1] not digit: '!'
[line 1, col 2] not char 'b': 'c'
[line 1, col 2] not char 'b': 'c'
[line 1, col 2] not string "ab": 'c'
</pre></div>
</div>

<p>エラーの種類が分かるようになりました。説明用にはこれくらいで十分でしょう。</p>

<h1>
<span id="おわりに" class="fragment"></span><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB"><i class="fa fa-link"></i></a>おわりに</h1>

<p>パーサコンビネータの動作イメージがつかめたでしょうか。</p>

<p>今回のようにテストだけではどう応用して良いのか分からないかもしれません。続編で四則演算器を作っているので、そちらも参考にしてください。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/f86f2f7ad68cfff1b399">C++11 パーサコンビネータ 超入門 2</a> 2015.11.30</li>
</ul>
<div class="hidden"><form class="js-task-list-update" action="/7shi/items/6a12160276a8db358e34" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="_method" value="patch" /><input type="hidden" name="authenticity_token" value="UEt4kcduQXRM0VRztqp9R4QgZjV6+DEZ5abw3J4TPJM+yePJXEB4P7MC4W/GX8Me5GdChu08a+7ZePknfx0yVQ==" /><input type="hidden" name="updated_at_confirmation_in_unixtime" id="updated_at_confirmation_in_unixtime" value="1482773675" class="js-task-list-updated-at" /><textarea name="raw_body" id="raw_body" class="js-task-list-field">
構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。

C++では[Boost.Spirit](http://boost-spirit.com/home/)が有名ですが、この記事ではHaskellのParsecを参考にしています。もちろんHaskellやモナドの知識は前提としません。それと断らずにモナドに由来する何かは出て来ますが、それが見抜けなくても問題ありません。興味があれば以下の記事を参照してください。

* [Haskell 構文解析 超入門](http://qiita.com/7shi/items/b8c741e78a96ea2c10fe) 2015.07.31

今回はラムダ式を多用するためC++11以降を対象とします。ラムダ式なしで実装するとあまりにも冗長になり過ぎて、便利さよりも煩雑さが勝ってしまうためです。興味があれば、以下のリポジトリを参照してください。

* https://bitbucket.org/7shi/parsecpp

この記事には続編があります。

* [C++11 パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/f86f2f7ad68cfff1b399) 2015.11.30

この記事にはJava版があります。

* [Java パーサコンビネータ 超入門](http://qiita.com/7shi/items/68228e19552c271bea81) 2016.05.12
* [Java パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142) 2016.05.14

この記事には関連記事があります。

* [JSONパーサーを作る](http://qiita.com/7shi/items/04c2991239894687ef2f) 2016.12.26

# コンセプト

パーサコンビネータは、単純な部品（パーサ）の組み合わせ（コンビネーション）で構文を解析します。

文字列からアルファベットと数字を分離する例です。`#include`している[parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/4282afab8b71b96924335c39f8433358ec9c33a4)はこの記事で1から作ります。

```cpp
#include &quot;parsecpp.cpp&quot;

int main() {
    Source s1 = &quot;abc123&quot;;
    auto s1a = many(alpha)(&amp;s1);
    auto s1b = many(digit)(&amp;s1);
    std::cout &lt;&lt; s1a &lt;&lt; &quot;,&quot; &lt;&lt; s1b &lt;&lt; std::endl;

    Source s2 = &quot;abcde9&quot;;
    auto s2a = many(alpha)(&amp;s2);
    auto s2b = many(digit)(&amp;s2);
    std::cout &lt;&lt; s2a &lt;&lt; &quot;,&quot; &lt;&lt; s2b &lt;&lt; std::endl;
}
```
```text:実行結果
abc,123
abcde,9
```

このコードの読み方を説明します。

1. 処理対象の文字列`&quot;abc123&quot;`を`s1`に代入
2. `s1`から、連続（`many`）するアルファベット（`alpha`）を取り出して`s1a`に代入
3. `s1`の後続の文字列から、連続（`many`）する数字（`digit`）を取り出して`s1b`に代入
4. `s1a`と`s1b`の中身を確認
5. 別の文字列を同様に処理

`alpha`や`digit`は1文字だけを読み込むパーサです。それらを`many`というコンビネータと組み合わせることで、複数文字を処理する`many(alpha)`や`many(digit)`というパーサを作ります。

正規表現と似たようなものをコードで表現したとイメージすれば良いかもしれません。たとえば`many(digit)`は正規表現の`[0-9]*`に相当します。

コード       |対応する正規表現
-------------|----------------
`digit`      |`[0-9]`
`many`       |`*`
`many(digit)`|`[0-9]*`

これだけ見ると正規表現の方が簡潔ですが、コードで表現することで複雑なパターンにも対応しやすいという強みがあります。

`s1`や`s2`は処理するたびに文字を読み進めます。値渡しでは変更（副作用）が加えられないため`&amp;s1`のようにポインタで渡します。

※ この辺の設計は副作用を排除したHaskellのParsecとは異なりますが、C++で実装しやすくするためのアレンジです。Haskellと完全に同じものをC++で実装したわけではありません。

# 基礎編

簡単な所から少しずつパーサコンビネータを作り始めます。

## 1文字取得

指定した文字列から先頭の1文字を取得します。

```cpp
#include &lt;iostream&gt;

char anyChar(const char *s) {
    return *s;
}

int main() {
    std::cout &lt;&lt; anyChar(&quot;abc&quot;) &lt;&lt; std::endl;
}
```
```text:実行結果
a
```

`anyChar`が最初のパーサです。

### 連続呼び出し

`anyChar`を連続呼び出しすることで複数文字を取得できるように拡張します。

ポインタをポインタで渡して読み取り後に1文字進めれば、次の呼び出しで次の文字が取得できます。

```cpp
#include &lt;iostream&gt;

char anyChar(const char **s) {
    return *((*s)++);
}

int main() {
    const char *s = &quot;abc&quot;;
    std::cout &lt;&lt; anyChar(&amp;s) &lt;&lt; std::endl;
    std::cout &lt;&lt; anyChar(&amp;s) &lt;&lt; std::endl;
}
```
```text:実行結果
a
b
```

`anyChar`を2回繰り返すことで、先頭から2文字取得しています。

## 型エイリアス

ポインタのポインタは直感的に分かりにくいので、型エイリアスを導入します。

```cpp
#include &lt;iostream&gt;

using Source = const char *;

char anyChar(Source *s) {
    return *((*s)++);
}

int main() {
    Source s = &quot;abc&quot;;
    std::cout &lt;&lt; anyChar(&amp;s) &lt;&lt; std::endl;
    std::cout &lt;&lt; anyChar(&amp;s) &lt;&lt; std::endl;
}
```
```text:実行結果
a
b
```

`using`での型エイリアスはC++11で導入されました。`typedef`の機能強化版です。

## 関数化

2文字取得する部分を関数化します。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;

using Source = const char *;

char anyChar(Source *s) {
    return *((*s)++);
}

std::string test1(Source *s) {  // 関数化
    char x1 = anyChar(s);
    char x2 = anyChar(s);
    return std::string({x1, x2});
}

int main() {
    Source s = &quot;abc&quot;;
    std::cout &lt;&lt; anyChar(&amp;s) &lt;&lt; std::endl;
    std::cout &lt;&lt; test1  (&amp;s) &lt;&lt; std::endl;
}
```
```text:実行結果
a
bc
```

`test1`は`anyChar`を組み合わせて作られていますが、利用側からは`anyChar`と`test1`が同じように扱えるのがポイントです。ただし戻り値の型が異なるのには注意が必要です。

### 組み合わせ

`test1`は、別の箇所で`anyChar`と組み合わせて利用できます。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;

using Source = const char *;

char anyChar(Source *s) {
    return *((*s)++);
}

std::string test1(Source *s) {
    char x1 = anyChar(s);
    char x2 = anyChar(s);
    return std::string({x1, x2});
}

std::string test2(Source *s) {  // 追加
    auto x1 = test1(s);
    char x2 = anyChar(s);
    return x1 + x2;
}

int main() {
    Source s1 = &quot;abc&quot;;
    std::cout &lt;&lt; anyChar(&amp;s1) &lt;&lt; std::endl;
    Source s2 = &quot;abc&quot;;
    std::cout &lt;&lt; test1(&amp;s2) &lt;&lt; std::endl;
    Source s3 = &quot;abc&quot;;
    std::cout &lt;&lt; test2(&amp;s3) &lt;&lt; std::endl;
}
```
```text:実行結果
a
ab
abc
```

`test1`は`anyChar`を2つ組み合わせて作ったパーサです。`test2`は`test1`と`anyChar`を組み合わせて作ったパーサです。このように簡単なパーサを組み合わせて複雑なパーサを作っていくのが、パーサコンビネータの基本的な考え方です。

`main`の中で`anyChar`と`test1`と`test2`が同列に並んでいますが、どれもパーサとして同じような位置付けだと見立ててください。

## テスト関数

`main()`でのテストが煩雑になって来たので、テスト用の関数`parseTest`を作成します。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;

using Source = const char *;

template &lt;typename T&gt;  // 追加
void parseTest(T (*p)(Source *), const Source &amp;src) {
    Source s = src;
    std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
}

char anyChar(Source *s) {
    return *((*s)++);
}

std::string test1(Source *s) {
    char x1 = anyChar(s);
    char x2 = anyChar(s);
    return std::string({x1, x2});
}

std::string test2(Source *s) {
    auto x1 = test1(s);
    char x2 = anyChar(s);
    return x1 + x2;
}

int main() {
    parseTest(anyChar, &quot;abc&quot;);
    parseTest(test1  , &quot;abc&quot;);
    parseTest(test2  , &quot;abc&quot;);
}
```
```text:実行結果
a
ab
abc
```

`parseTest`にはパーサの関数（`anyChar`など）を渡しますが、異なる戻り値を受け付けるようにテンプレートを用いて多相化しています。

### 型エイリアス

関数ポインタの書き方は複雑なので、型エイリアスを定義します。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;

using Source = const char *;

template &lt;typename T&gt;         // 追加
using Parser = T (Source *);  // T: 戻り値, (...): 引数

template &lt;typename T&gt;
void parseTest(const Parser&lt;T&gt; &amp;p, const Source &amp;src) {
    Source s = src;
    std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
}

char anyChar(Source *s) {
    return *((*s)++);
}

std::string test1(Source *s) {
    char x1 = anyChar(s);
    char x2 = anyChar(s);
    return std::string({x1, x2});
}

std::string test2(Source *s) {
    auto x1 = test1(s);
    char x2 = anyChar(s);
    return x1 + x2;
}

int main() {
    parseTest(anyChar, &quot;abc&quot;);
    parseTest(test1  , &quot;abc&quot;);
    parseTest(test2  , &quot;abc&quot;);
}
```
```text:実行結果
a
ab
abc
```

このように`using`はテンプレートと併用することができます。関数ポインタ型の表現方法も、名前と型が分離されており読みやすいです。これらは`typedef`に対する改善点です。詳細は次の記事が参考になります。

* @Linda_pp: [typedef は C++11 ではオワコン](http://qiita.com/Linda_pp/items/44a67c64c14cba00eef1) 2014.12.21

## 例外

文字列の末尾に達したかどうかをチェックしていないのは問題です。番兵（`&#39;\0&#39;`）を確認して例外を発生させるように修正します。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;

using Source = const char *;

template &lt;typename T&gt;
using Parser = T (Source *);

template &lt;typename T&gt;
void parseTest(const Parser&lt;T&gt; &amp;p, const Source &amp;src) {
    Source s = src;
    try {
        std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
    } catch (const char *e) {    // 例外処理
        std::cout &lt;&lt; e &lt;&lt; std::endl;
    }
}

char anyChar(Source *s) {
    char ch = **s;
    if (!ch) throw &quot;too short&quot;;  // 例外発生
    ++*s;
    return ch;
}

std::string test1(Source *s) {
    char x1 = anyChar(s);
    char x2 = anyChar(s);
    return std::string({x1, x2});
}

std::string test2(Source *s) {
    auto x1 = test1(s);
    char x2 = anyChar(s);
    return x1 + x2;
}

int main() {
    parseTest(test2, &quot;12&quot; );  // 文字数不足
    parseTest(test2, &quot;123&quot;);
}
```
```text:実行結果
too short
123
```

## std::function

C++11ではラムダ式がサポートされました。ここから先ではラムダ式を多用しますが、関数ポインタでは扱えません。そのため関数ポインタを`std::function`で置き換えます。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;  // 追加

using Source = const char *;

template &lt;typename T&gt;
using Parser = std::function&lt;T (Source *)&gt;;  // 修正

template &lt;typename T&gt;
void parseTest(const Parser&lt;T&gt; &amp;p, const Source &amp;src) {
    Source s = src;
    try {
        std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
    } catch (const char *e) {
        std::cout &lt;&lt; e &lt;&lt; std::endl;
    }
}

Parser&lt;char&gt; anyChar = [](Source *s) {       // ラムダ式化
    char ch = **s;
    if (!ch) throw &quot;too short&quot;;
    ++*s;
    return ch;
};

Parser&lt;std::string&gt; test1 = [](Source *s) {  // ラムダ式化
    char x1 = anyChar(s);
    char x2 = anyChar(s);
    return std::string({x1, x2});
};

Parser&lt;std::string&gt; test2 = [](Source *s) {  // ラムダ式化
    auto x1 = test1(s);
    char x2 = anyChar(s);
    return x1 + x2;
};

int main() {
    parseTest(test2, &quot;12&quot; );  // NG
    parseTest(test2, &quot;123&quot;);
}
```
```text:実行結果
too short
123
```

`std::function`に対して関数を渡しても自動で変換されますが、テンプレートで多相化されていると明示的な変換が必要になります。その面倒を避けるため`anyChar`などをラムダ式化しています。

## 条件取得

`anyChar`は無条件で文字を取得していましたが、条件が指定できる`satisfy`を追加します。引数で渡された関数を`[=]`でキャプチャしたクロージャを返します。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;

using Source = const char *;

template &lt;typename T&gt;
using Parser = std::function&lt;T (Source *)&gt;;

template &lt;typename T&gt;
void parseTest(const Parser&lt;T&gt; &amp;p, const Source &amp;src) {
    Source s = src;
    try {
        std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
    } catch (const char *e) {
        std::cout &lt;&lt; e &lt;&lt; std::endl;
    }
}

Parser&lt;char&gt; anyChar = [](Source *s) {
    char ch = **s;
    if (!ch) throw &quot;too short&quot;;
    ++*s;
    return ch;
};

Parser&lt;char&gt; satisfy(const std::function&lt;bool (char)&gt; &amp;f) {  // 追加
    return [=](Source *s) {
        char ch = **s;
        if (!ch) throw &quot;too short&quot;;
        if (!f(ch)) throw &quot;not satisfy&quot;;
        ++*s;
        return ch;
    };
}

bool isDigit(char ch) { return &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;; }

int main() {
    parseTest(satisfy(isDigit), &quot;abc&quot;);  // NG
    parseTest(satisfy(isDigit), &quot;123&quot;);
}
```
```text:実行結果
not satisfy
1
```

今回の機能追加に直接関係ない`test1`と`test2`は削除しました。

### 共通化

`anyChar`と`satisfy`でほとんどの処理が重複しています。`anyChar`は無条件の`satisfy`として定義することで共通化を図ります。

※ 前方参照（使用箇所よりも下で定義された関数を使用すること）できないため、`anyChar`は`satisfy`の下に移動します。

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;

using Source = const char *;

template &lt;typename T&gt;
using Parser = std::function&lt;T (Source *)&gt;;

template &lt;typename T&gt;
void parseTest(const Parser&lt;T&gt; &amp;p, const Source &amp;src) {
    Source s = src;
    try {
        std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
    } catch (const char *e) {
        std::cout &lt;&lt; e &lt;&lt; std::endl;
    }
}

Parser&lt;char&gt; satisfy(const std::function&lt;bool (char)&gt; &amp;f) {
    return [=](Source *s) {
        char ch = **s;
        if (!ch) throw &quot;too short&quot;;
        if (!f(ch)) throw &quot;not satisfy&quot;;
        ++*s;
        return ch;
    };
}

auto anyChar = satisfy([](char) { return true; });  // 移動・修正

int main() {
    parseTest(anyChar, &quot;abc&quot;);
}
```
```text:実行結果
a
```

## ファイル分割

コードが長くなって来たため、汎用部分を別ファイルに分離します。ファイル名の`parsecpp`は`ParseC++`のつもりです。

```parsecpp.cpp
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;

using Source = const char *;

template &lt;typename T&gt;
using Parser = std::function&lt;T (Source *)&gt;;

template &lt;typename T&gt;
void parseTest(const Parser&lt;T&gt; &amp;p, const Source &amp;src) {
    Source s = src;
    try {
        std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
    } catch (const char *e) {
        std::cout &lt;&lt; e &lt;&lt; std::endl;
    }
}

Parser&lt;char&gt; satisfy(const std::function&lt;bool (char)&gt; &amp;f) {
    return [=](Source *s) {
        char ch = **s;
        if (!ch) throw &quot;too short&quot;;
        if (!f(ch)) throw &quot;not satisfy&quot;;
        ++*s;
        return ch;
    };
}

auto anyChar = satisfy([](char) { return true; });
```

簡単のためヘッダではなく直に`#include`して使います。

※ もし実用化するのであればヘッダも作成する必要がありますが、今回は説明が目的として割り切ります。

```cpp
#include &quot;parsecpp.cpp&quot;

int main() {
    parseTest(anyChar, &quot;abc&quot;);
}
```
```text:実行結果
a
```

## 文字判定

文字を指定して判定するパーサを実装します。Parsecでは`char`ですが、型と被るため`char1`に名前を変更します。

```cpp:parsecpp.cpp（追加）
Parser&lt;char&gt; char1(char ch) {
    return satisfy([=](char c) { return c == ch; });
}
```

`char1`は引数`ch`を`[=]`でキャプチャしたクロージャを返しているのがポイントです。今後このようなパターンがよく出て来ます。

動作を確認します。

```cpp
#include &quot;parsecpp.cpp&quot;

int main() {
    parseTest(char1(&#39;a&#39;), &quot;abc&quot;);
    parseTest(char1(&#39;a&#39;), &quot;123&quot;);  // NG
}
```
```text:実行結果
a
not satisfy
```

## 事前定義

`satisfy`で条件を指定するのは冗長なので、よく使うパターンを事前定義します。

```cpp:parsecpp.cpp（追加）
bool isDigit   (char ch) { return &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;; }
bool isUpper   (char ch) { return &#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;; }
bool isLower   (char ch) { return &#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;; }
bool isAlpha   (char ch) { return isUpper(ch) || isLower(ch); }
bool isAlphaNum(char ch) { return isAlpha(ch) || isDigit(ch); }
bool isLetter  (char ch) { return isAlpha(ch) || ch == &#39;_&#39;;   }

auto digit    = satisfy(isDigit   );
auto upper    = satisfy(isUpper   );
auto lower    = satisfy(isLower   );
auto alpha    = satisfy(isAlpha   );
auto alphaNum = satisfy(isAlphaNum);
auto letter   = satisfy(isLetter  );
```

動作を確認します。

```cpp
#include &quot;parsecpp.cpp&quot;

int main() {
    parseTest(digit , &quot;abc&quot;);  // NG
    parseTest(digit , &quot;123&quot;);
    parseTest(letter, &quot;abc&quot;);
    parseTest(letter, &quot;123&quot;);  // NG
}
```
```text:実行結果
not satisfy
1
a
not satisfy
```

## 組み合わせ判定

先ほど追加したパーサを組み合わせて、先頭から「アルファベット」「数字」「数字」という組み合わせを判定するパーサを作ります。

```cpp
#include &quot;parsecpp.cpp&quot;

Parser&lt;std::string&gt; test3 = [](Source *s) {
    char x1 = letter(s);
    char x2 = digit(s);
    char x3 = digit(s);
    return std::string({x1, x2, x3});
};

int main() {
    parseTest(test3, &quot;abc&quot; );  // NG
    parseTest(test3, &quot;123&quot; );  // NG
    parseTest(test3, &quot;a23&quot; );
    parseTest(test3, &quot;a234&quot;);
}
```
```text:実行結果
not satisfy
not satisfy
a23
a23
```

## コンビネータの定義

パーサ同士を組み合わせて新しいパーサを作り出す関数を**コンビネータ**と呼びます。

いくつか便利なコンビネータを定義します。

### 結合

パーサを結合する演算子`+`を定義してparsecpp.cppに追加します。

```cpp:parsecpp.cpp（追加）
template &lt;typename T1, typename T2&gt;
Parser&lt;std::string&gt; operator+(const Parser&lt;T1&gt; &amp;x, const Parser&lt;T2&gt; &amp;y) {
    return [=](Source *s) {
        std::string ret;
        ret += x(s);
        ret += y(s);
        return ret;
    };
}
```

`test3`がとても簡単になります。

```cpp
#include &quot;parsecpp.cpp&quot;

auto test3 = letter + digit + digit;

int main() {
    parseTest(test3, &quot;abc&quot; );  // NG
    parseTest(test3, &quot;123&quot; );  // NG
    parseTest(test3, &quot;a23&quot; );
    parseTest(test3, &quot;a234&quot;);
}
```
```text:実行結果
not satisfy
not satisfy
a23
a23
```

処理が関数を定義しなくても組み合わせで表現されています。この感覚がつかめれば、パーサコンビネータが見えて来ます。

### 繰り返し

掛け算の演算子で繰り返し回数を指定できるようにします。掛け算の順序を気にしなくても済むように、2つのパターンを定義します。

```cpp:parsecpp.cpp（追加）
template &lt;typename T&gt;
Parser&lt;std::string&gt; operator*(int n, const Parser&lt;T&gt; &amp;x) {
    return [=](Source *s) {
        std::string ret;
        for (int i = 0; i &lt; n; ++i) {
            ret += x(s);
        }
        return ret;
    };
}
template &lt;typename T&gt;
Parser&lt;std::string&gt; operator*(const Parser&lt;T&gt; &amp;x, int n) {
    return n * x;
}
```

`test3`が更に簡単になります。

```cpp
#include &quot;parsecpp.cpp&quot;

auto test3 = letter + 2 * digit;

int main() {
    parseTest(test3, &quot;abc&quot; );  // NG
    parseTest(test3, &quot;123&quot; );  // NG
    parseTest(test3, &quot;a23&quot; );
    parseTest(test3, &quot;a234&quot;);
}
```
```text:実行結果
not satisfy
not satisfy
a23
a23
```

コンビネータの定義はラムダ式を返す関数になっていて少し複雑ですが、利用側はとても簡単に書けます。

## many

繰り返しに関連して、最初のコンセプトで出て来た`many`を実装してみます。

`many`は指定したパーサを0回以上適用して返すコンビネータです。エラーになるまで読み進めれば実装できます。

```cpp:parsecpp.cpp（追加）
template &lt;typename T&gt;
Parser&lt;std::string&gt; many(const Parser&lt;T&gt; &amp;p) {
    return [=](Source *s) {
        std::string ret;
        try {
            for (;;) ret += p(s);
        } catch (const char *) {}
        return ret;
    };
}
```

先頭からアルファベットだけを抜き出してみます。1文字も一致しなくても、エラーにはならずに空文字列が返ります。

```cpp
#include &quot;parsecpp.cpp&quot;

auto test4 = many(alpha);

int main() {
    parseTest(test4, &quot;abc123&quot;);
    parseTest(test4, &quot;123abc&quot;);
}
```
```text:実行結果
abc
     ← 空行
```

最初に出て来たサンプルも動きます。

```cpp
#include &quot;parsecpp.cpp&quot;

int main() {
    Source s1 = &quot;abc123&quot;;
    auto s1a = many(alpha)(&amp;s1);
    auto s1b = many(digit)(&amp;s1);
    std::cout &lt;&lt; s1a &lt;&lt; &quot;,&quot; &lt;&lt; s1b &lt;&lt; std::endl;

    Source s2 = &quot;abcde9&quot;;
    auto s2a = many(alpha)(&amp;s2);
    auto s2b = many(digit)(&amp;s2);
    std::cout &lt;&lt; s2a &lt;&lt; &quot;,&quot; &lt;&lt; s2b &lt;&lt; std::endl;
}
```
```text:実行結果
abc,123
abcde,9
```

## まとめ

ここまでがパーサコンビネータの動作原理を理解するために最低限必要な実装です。

このセクションで登場したテストを1つにまとめます。

* [ここまでの parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/645de09ce4f9e53e4dbab48f403521b12f2d0af7)

```cpp
#include &quot;parsecpp.cpp&quot;

auto test1 = anyChar + anyChar;
auto test2 = test1 + anyChar;
auto test3 = letter + 2 * digit;
auto test4 = many(alpha);

int main() {
    parseTest(anyChar   , &quot;abc&quot;   );
    parseTest(test1     , &quot;abc&quot;   );
    parseTest(test2     , &quot;abc&quot;   );
    parseTest(test2     , &quot;12&quot;    );  // NG
    parseTest(test2     , &quot;123&quot;   );
    parseTest(char1(&#39;a&#39;), &quot;abc&quot;   );
    parseTest(char1(&#39;a&#39;), &quot;123&quot;   );  // NG
    parseTest(digit     , &quot;abc&quot;   );  // NG
    parseTest(digit     , &quot;123&quot;   );
    parseTest(letter    , &quot;abc&quot;   );
    parseTest(letter    , &quot;123&quot;   );  // NG
    parseTest(test3     , &quot;abc&quot;   );  // NG
    parseTest(test3     , &quot;123&quot;   );  // NG
    parseTest(test3     , &quot;a23&quot;   );
    parseTest(test3     , &quot;a234&quot;  );
    parseTest(test4     , &quot;abc123&quot;);
    parseTest(test4     , &quot;123abc&quot;);

    Source s1 = &quot;abc123&quot;;
    auto s1a = many(alpha)(&amp;s1);
    auto s1b = many(digit)(&amp;s1);
    std::cout &lt;&lt; s1a &lt;&lt; &quot;,&quot; &lt;&lt; s1b &lt;&lt; std::endl;

    Source s2 = &quot;abcde9&quot;;
    auto s2a = many(alpha)(&amp;s2);
    auto s2b = many(digit)(&amp;s2);
    std::cout &lt;&lt; s2a &lt;&lt; &quot;,&quot; &lt;&lt; s2b &lt;&lt; std::endl;
}
```
```text:実行結果
a
ab
abc
too short
123
a
not satisfy
not satisfy
1
a
not satisfy
not satisfy
not satisfy
a23
a23
abc

abc,123
abcde,9
```

最初にコンセプトで提示したコードを見たときはモヤっとしていた部分も、少しはすっきりしたでしょうか。

# 選択

非常によく使うのが選択のコンビネータです。

便利なだけでなく、色々と悩ましい問題があるのを見ていきます。

## 単純な実装

「または」を表現する演算子`||`を実装します。

```cpp:parsecpp.cpp（追加）
template &lt;typename T&gt;
const Parser&lt;T&gt; operator||(const Parser&lt;T&gt; &amp;p1, const Parser&lt;T&gt; &amp;p2) {
    return [=](Source *s) {
        T ret;
        try {
            ret = p1(s);
        } catch (const char *) {
            ret = p2(s);
        }
        return ret;
    };
}
```

`||`を使えば「アルファベットまたは数字」のような選択的なパーサが構築できます。

```cpp
#include &quot;parsecpp.cpp&quot;

auto test5 = letter || digit;

int main() {
    parseTest(test5, &quot;a&quot;);
    parseTest(test5, &quot;1&quot;);
    parseTest(test5, &quot;!&quot;);  // NG
}
```
```text:実行結果
a
1
not satisfy
```

### manyとの組み合わせ

選択的パーサを`many`で繰り返すこともできます。

```cpp
#include &quot;parsecpp.cpp&quot;

auto test6 = many(letter || digit);

int main() {
    parseTest(test6, &quot;abc123&quot;);
    parseTest(test6, &quot;123abc&quot;);
}
```
```text:実行結果
abc123
123abc
```

## 結合と選択

`||`を少し使ってみると、直感に反した動きに気付きます。

```cpp
#include &quot;parsecpp.cpp&quot;

auto a = char1(&#39;a&#39;);
auto b = char1(&#39;b&#39;);
auto c = char1(&#39;c&#39;);

auto test7 = a + b || c + b;

int main() {
    parseTest(test7, &quot;ab&quot; );
    parseTest(test7, &quot;cb&quot; );
    parseTest(test7, &quot;acb&quot;);  // ???
}
```
```text:実行結果
ab
cb
cb
```

`test7`を素直に見ると「`&quot;ab&quot;`または`&quot;cb&quot;`」となり、確かにその両方にマッチします。しかし`&quot;acb&quot;`にもマッチしてしまいます。これは`||`に達する前に`&#39;a&#39;`だけは読み進めてしまったため、`||`の後のパターンにマッチしてしまうためです。

## エラー化

このようなケースはParsecではエラーになります。

`左 || 右`として、左のパーサが内部で複数のパーサから構成されるとき、そのうち1つでも成功してその後で失敗したなら、右のパーサは処理されずにエラーになるという仕様です。

最初の状態を保持しておいて、`||`の前で読み進めていれば例外を再送します。

```cpp:parsecpp.cpp（修正）
template &lt;typename T&gt;
const Parser&lt;T&gt; operator||(const Parser&lt;T&gt; &amp;p1, const Parser&lt;T&gt; &amp;p2) {
    return [=](Source *s) {
        T ret;
        Source bak = *s;           // 追加
        try {
            ret = p1(s);
        } catch (const char *) {
            if (*s != bak) throw;  // 追加
            ret = p2(s);
        }
        return ret;
    };
}
```

先ほどと同じコードを試すと、最後がエラーになります。Parsecと同じで意図した動きです。

```cpp
#include &quot;parsecpp.cpp&quot;

auto a = char1(&#39;a&#39;);
auto b = char1(&#39;b&#39;);
auto c = char1(&#39;c&#39;);

auto test7 = a + b || c + b;

int main() {
    parseTest(test7, &quot;ab&quot; );
    parseTest(test7, &quot;cb&quot; );
    parseTest(test7, &quot;acb&quot;);  // NG
}
```
```text:実行結果
ab
cb
not satisfy
```

## 共通部分

選択肢の先頭に共通部分があった場合、意図せずエラーになることがあります。

```cpp
#include &quot;parsecpp.cpp&quot;

auto a = char1(&#39;a&#39;);
auto b = char1(&#39;b&#39;);
auto c = char1(&#39;c&#39;);

auto test8 = a + b || a + c;

int main() {
    parseTest(test8, &quot;ab&quot; );
    parseTest(test8, &quot;ac&quot; );  // NG
}
```
```text:実行結果
ab
not satisfy
```

このようなケースでは、共通部分を括り出すことで対処できます。

```cpp
#include &quot;parsecpp.cpp&quot;

auto a = char1(&#39;a&#39;);
auto b = char1(&#39;b&#39;);
auto c = char1(&#39;c&#39;);

auto test8 = a + b || a + c;
auto test9 = a + (b || c);

int main() {
    parseTest(test8, &quot;ab&quot;);
    parseTest(test8, &quot;ac&quot;);  // NG
    parseTest(test9, &quot;ab&quot;);
    parseTest(test9, &quot;ac&quot;);
}
```
```text:実行結果
ab
not satisfy
ab
ac
```

別の方法として状態を巻き戻す方法もあります。

## バックトラック

パースに失敗したとき、状態を巻き戻して別の方法でパースをやり直すことを**バックトラック**と呼びます。

### tryp

Parsecでバックトラックするには対象となるパーサを`try`で囲みます。例外処理の`try`と名前が被るため、ここでは`tryp`に名前を変更します。（`p`はParserの頭文字です）

`tryp`の中で失敗すれば元の状態に戻してから例外を再送します。

```cpp:parsecpp.cpp（追加）
template &lt;typename T&gt;
Parser&lt;T&gt; tryp(const Parser&lt;T&gt; &amp;p) {
    return [=](Source *s) {
        T ret;
        Source bak = *s;
        try {
            ret = p(s);
        } catch (const char *) {
            *s = bak;
            throw;
        }
        return ret;
    };
}
```

`||`の左側を`tryp`で囲めば、失敗してもバックトラックしてから右側が処理されます。

先ほどの`test8`と`test9`と挙動を比較します。

```cpp
#include &quot;parsecpp.cpp&quot;

auto a = char1(&#39;a&#39;);
auto b = char1(&#39;b&#39;);
auto c = char1(&#39;c&#39;);

auto test8  = a + b  || a + c;
auto test9  = a + (b || c);
auto test10 = tryp(a + b) || a + c;

int main() {
    parseTest(test8 , &quot;ab&quot;);
    parseTest(test8 , &quot;ac&quot;);  // NG
    parseTest(test9 , &quot;ab&quot;);
    parseTest(test9 , &quot;ac&quot;);
    parseTest(test10, &quot;ab&quot;);
    parseTest(test10, &quot;ac&quot;);
}
```
```text:実行結果
ab
not satisfy
ab
ac
ab
ac
```

`test9`と`test10`は同じ動きです。

## string

1文字ずつ`char1`でパースすると面倒なため、文字列で指定できる`string`を実装します。

```cpp:parsecpp.cpp（追加）
Parser&lt;std::string&gt; string(const std::string &amp;str) {
    return [=](Source *s) {
        for (auto it = str.begin(); it != str.end(); ++it) {
            char1(*it)(s);
        }
        return str;
    };
}
```

内部では1文字ずつ処理されているため、途中の失敗をバックトラックするには`tryp`が必要です。

挙動を確認します。

```cpp
#include &quot;parsecpp.cpp&quot;

auto test11 = string(&quot;ab&quot;) || string(&quot;ac&quot;);
auto test12 = tryp(string(&quot;ab&quot;)) || string(&quot;ac&quot;);

int main() {
    parseTest(test11, &quot;ab&quot;);
    parseTest(test11, &quot;ac&quot;);  // NG
    parseTest(test12, &quot;ab&quot;);
    parseTest(test12, &quot;ac&quot;);
}
```
```text:実行結果
ab
not satisfy
ab
ac
```

## まとめ

このセクションで登場したテストを1つにまとめます。

* [ここまでの parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/daff7dd17df16439d6adf1622367ef5bee57a739)

```cpp
#include &quot;parsecpp.cpp&quot;

auto a = char1(&#39;a&#39;);
auto b = char1(&#39;b&#39;);
auto c = char1(&#39;c&#39;);

auto test5  = letter || digit;
auto test6  = many(letter || digit);
auto test7  = a + b || c + b;
auto test8  = a + b || a + c;
auto test9  = a + (b || c);
auto test10 = tryp(a + b) || a + c;
auto test11 = string(&quot;ab&quot;) || string(&quot;ac&quot;);
auto test12 = tryp(string(&quot;ab&quot;)) || string(&quot;ac&quot;);

int main() {
    parseTest(test5 , &quot;a&quot;     );
    parseTest(test5 , &quot;1&quot;     );
    parseTest(test5 , &quot;!&quot;     );  // NG
    parseTest(test6 , &quot;abc123&quot;);
    parseTest(test6 , &quot;123abc&quot;);
    parseTest(test7 , &quot;ab&quot;    );
    parseTest(test7 , &quot;cb&quot;    );
    parseTest(test7 , &quot;acb&quot;   );  // NG
    parseTest(test8 , &quot;ab&quot;    );
    parseTest(test8 , &quot;ac&quot;    );  // NG
    parseTest(test9 , &quot;ab&quot;    );
    parseTest(test9 , &quot;ac&quot;    );
    parseTest(test10, &quot;ab&quot;    );
    parseTest(test10, &quot;ac&quot;    );
    parseTest(test11, &quot;ab&quot;    );
    parseTest(test11, &quot;ac&quot;    );  // NG
    parseTest(test12, &quot;ab&quot;    );
    parseTest(test12, &quot;ac&quot;    );
}
```
```text:実行結果
a
1
not satisfy
abc123
123abc
ab
cb
not satisfy
ab
not satisfy
ab
ac
ab
ac
ab
not satisfy
ab
ac
```

# エラー表示

エラーが`too short`や`not satisfy`では分かりにくいので改善します。

このセクションは修正箇所が多いため差分と全体の両方を示します。

## クラス化

`Source`をクラス化します。

差分を示します。

```diff
--- parsecpp.cpp.orig
+++ parsecpp.cpp
@@ -2,7 +2,26 @@
 #include &lt;string&gt;
 #include &lt;functional&gt;
 
-using Source = const char *;
+class Source {
+    const char *s;
+public:
+    Source(const char *s) : s(s) {}
+    char peek() {
+        char ch = *s;
+        if (!ch) throw &quot;too short&quot;;
+        return ch;
+    }
+    void next() {
+        peek();
+        ++s;
+    }
+    bool operator==(const Source &amp;src) const {
+        return s == src.s;
+    }
+    bool operator!=(const Source &amp;src) const {
+        return !(*this == src);
+    }
+};
 
 template &lt;typename T&gt;
 using Parser = std::function&lt;T (Source *)&gt;;
@@ -19,10 +38,9 @@
 
 Parser&lt;char&gt; satisfy(const std::function&lt;bool (char)&gt; &amp;f) {
     return [=](Source *s) {
-        char ch = **s;
-        if (!ch) throw &quot;too short&quot;;
+        char ch = s-&gt;peek();
         if (!f(ch)) throw &quot;not satisfy&quot;;
-        ++*s;
+        s-&gt;next();
         return ch;
     };
 }
```

* [修正後の parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/d389835c0cc3798ec3b68bddf7901d1a89d343ca)

`satisfy`は二重デリファレンスやポインタ演算がなくなり、読みやすくなりました。

まだ動作結果に変化はありません。エラーが出るものだけ抽出して確認します。

```cpp
#include &quot;parsecpp.cpp&quot;

auto a = char1(&#39;a&#39;);
auto b = char1(&#39;b&#39;);
auto c = char1(&#39;c&#39;);

auto test1 = anyChar + anyChar;
auto test2 = test1 + anyChar;
auto test3 = letter + 2 * digit;
auto test5  = letter || digit;
auto test7  = a + b || c + b;
auto test8  = a + b || a + c;
auto test11 = string(&quot;ab&quot;) || string(&quot;ac&quot;);

int main() {
    parseTest(test2     , &quot;12&quot; );  // NG
    parseTest(char1(&#39;a&#39;), &quot;123&quot;);  // NG
    parseTest(digit     , &quot;abc&quot;);  // NG
    parseTest(letter    , &quot;123&quot;);  // NG
    parseTest(test3     , &quot;abc&quot;);  // NG
    parseTest(test3     , &quot;123&quot;);  // NG
    parseTest(test5     , &quot;!&quot;  );  // NG
    parseTest(test7     , &quot;acb&quot;);  // NG
    parseTest(test8     , &quot;ac&quot; );  // NG
    parseTest(test11    , &quot;ac&quot; );  // NG
}
```
```text:実行結果
too short
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
```

## 位置

`Source`に位置（行と桁）を保持してエラーメッセージに含めます。文字列を作る必要があるため、例外を`std::string`で送出します。

差分を示します。

```diff
--- parsecpp.cpp.orig
+++ parsecpp.cpp
@@ -1,19 +1,31 @@
 #include &lt;iostream&gt;
+#include &lt;sstream&gt;
 #include &lt;string&gt;
 #include &lt;functional&gt;
 
 class Source {
     const char *s;
+    int line, col;
 public:
-    Source(const char *s) : s(s) {}
+    Source(const char *s) : s(s), line(1), col(1) {}
     char peek() {
         char ch = *s;
-        if (!ch) throw &quot;too short&quot;;
+        if (!ch) throw ex(&quot;too short&quot;);
         return ch;
     }
     void next() {
-        peek();
+        char ch = peek();
+        if (ch == &#39;\n&#39;) {
+            ++line;
+            col = 0;
+        }
         ++s;
+        ++col;
+    }
+    std::string ex(const std::string &amp;e) {
+        std::ostringstream oss;
+        oss &lt;&lt; &quot;[line &quot; &lt;&lt; line &lt;&lt; &quot;, col &quot; &lt;&lt; col &lt;&lt; &quot;] &quot; &lt;&lt; e;
+        return oss.str();
     }
     bool operator==(const Source &amp;src) const {
         return s == src.s;
@@ -31,7 +43,7 @@
     Source s = src;
     try {
         std::cout &lt;&lt; p(&amp;s) &lt;&lt; std::endl;
-    } catch (const char *e) {
+    } catch (const std::string &amp;e) {
         std::cout &lt;&lt; e &lt;&lt; std::endl;
     }
 }
@@ -39,7 +51,7 @@
 Parser&lt;char&gt; satisfy(const std::function&lt;bool (char)&gt; &amp;f) {
     return [=](Source *s) {
         char ch = s-&gt;peek();
-        if (!f(ch)) throw &quot;not satisfy&quot;;
+        if (!f(ch)) throw s-&gt;ex(&quot;not satisfy&quot;);
         s-&gt;next();
         return ch;
     };
@@ -96,7 +108,7 @@
         std::string ret;
         try {
             for (;;) ret += p(s);
-        } catch (const char *) {}
+        } catch (const std::string &amp;) {}
         return ret;
     };
 }
@@ -108,7 +120,7 @@
         Source bak = *s;
         try {
             ret = p1(s);
-        } catch (const char *) {
+        } catch (const std::string &amp;) {
             if (*s != bak) throw;
             ret = p2(s);
         }
@@ -123,7 +135,7 @@
         Source bak = *s;
         try {
             ret = p(s);
-        } catch (const char *) {
+        } catch (const std::string &amp;) {
             *s = bak;
             throw;
         }
```

* [修正後の parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/800b28ab89fdd850dfef91f7b8dbbddb931cbcea)

先ほどと同じコードをテストして、エラーの変化を確認します。

```text:実行結果
[line 1, col 3] too short
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
```

どこでエラーが発生したか分かるようになりました。

## 対象の文字

どの文字でエラーになったかをエラーメッセージに含めます。

差分を示します。

```diff
--- parsecpp.cpp.orig
+++ parsecpp.cpp
@@ -25,6 +25,7 @@
     std::string ex(const std::string &amp;e) {
         std::ostringstream oss;
         oss &lt;&lt; &quot;[line &quot; &lt;&lt; line &lt;&lt; &quot;, col &quot; &lt;&lt; col &lt;&lt; &quot;] &quot; &lt;&lt; e;
+        if (*s) oss &lt;&lt; &quot;: &#39;&quot; &lt;&lt; *s &lt;&lt; &quot;&#39;&quot;;
         return oss.str();
     }
     bool operator==(const Source &amp;src) const {
```

* [修正後の parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/47581204d9245b8897a28dbea60cc7928a5692c9)

先ほどと同じコードをテストして、エラーの変化を確認します。

```text:実行結果
[line 1, col 3] too short
[line 1, col 1] not satisfy: &#39;1&#39;
[line 1, col 1] not satisfy: &#39;a&#39;
[line 1, col 1] not satisfy: &#39;1&#39;
[line 1, col 2] not satisfy: &#39;b&#39;
[line 1, col 1] not satisfy: &#39;1&#39;
[line 1, col 1] not satisfy: &#39;!&#39;
[line 1, col 2] not satisfy: &#39;c&#39;
[line 1, col 2] not satisfy: &#39;c&#39;
[line 1, col 2] not satisfy: &#39;c&#39;
```

どの文字でエラーになったのかが分かるようになりました。

## 失敗の確定

失敗を確定させて指定したメッセージで例外を発生させる`left`を実装します。

※ 英語でrightは「右」の他に「正しい」という意味がありますが、その反対を意図して`left`と命名されました。ある種の言葉遊びで、英語としての単語に「誤り」という意味があるわけではありません。

`||`と`left`を組み合わせれば、エラーメッセージがカスタマイズできます。前方参照の関係で定義位置の移動が必要です。

差分を示します。

```diff
--- parsecpp.cpp.orig
+++ parsecpp.cpp
@@ -60,24 +60,6 @@
 
 auto anyChar = satisfy([](char) { return true; });
 
-Parser&lt;char&gt; char1(char ch) {
-    return satisfy([=](char c) { return c == ch; });
-}
-
-bool isDigit   (char ch) { return &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;; }
-bool isUpper   (char ch) { return &#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;; }
-bool isLower   (char ch) { return &#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;; }
-bool isAlpha   (char ch) { return isUpper(ch) || isLower(ch); }
-bool isAlphaNum(char ch) { return isAlpha(ch) || isDigit(ch); }
-bool isLetter  (char ch) { return isAlpha(ch) || ch == &#39;_&#39;;   }
-
-auto digit    = satisfy(isDigit   );
-auto upper    = satisfy(isUpper   );
-auto lower    = satisfy(isLower   );
-auto alpha    = satisfy(isAlpha   );
-auto alphaNum = satisfy(isAlphaNum);
-auto letter   = satisfy(isLetter  );
-
 template &lt;typename T1, typename T2&gt;
 Parser&lt;std::string&gt; operator+(const Parser&lt;T1&gt; &amp;x, const Parser&lt;T2&gt; &amp;y) {
     return [=](Source *s) {
@@ -144,11 +126,40 @@
     };
 }
 
+template &lt;typename T&gt;
+Parser&lt;T&gt; left(const std::string &amp;e) {
+    return [=](Source *s) -&gt; T {
+        throw s-&gt;ex(e);
+    };
+}
+Parser&lt;char&gt; left(const std::string &amp;e) {
+    return left&lt;char&gt;(e);
+}
+
+Parser&lt;char&gt; char1(char ch) {
+    return satisfy([=](char c) { return c == ch; })
+        || left(std::string(&quot;not char &#39;&quot;) + ch + &quot;&#39;&quot;);
+}
+
 Parser&lt;std::string&gt; string(const std::string &amp;str) {
     return [=](Source *s) {
         for (auto it = str.begin(); it != str.end(); ++it) {
-            char1(*it)(s);
+            (char1(*it) || left(&quot;not string \&quot;&quot; + str + &quot;\&quot;&quot;))(s);
         }
         return str;
     };
 }
+
+bool isDigit   (char ch) { return &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;; }
+bool isUpper   (char ch) { return &#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;; }
+bool isLower   (char ch) { return &#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;; }
+bool isAlpha   (char ch) { return isUpper(ch) || isLower(ch); }
+bool isAlphaNum(char ch) { return isAlpha(ch) || isDigit(ch); }
+bool isLetter  (char ch) { return isAlpha(ch) || ch == &#39;_&#39;;   }
+
+auto digit    = satisfy(isDigit   ) || left(&quot;not digit&quot;   );
+auto upper    = satisfy(isUpper   ) || left(&quot;not upper&quot;   );
+auto lower    = satisfy(isLower   ) || left(&quot;not lower&quot;   );
+auto alpha    = satisfy(isAlpha   ) || left(&quot;not alpha&quot;   );
+auto alphaNum = satisfy(isAlphaNum) || left(&quot;not alphaNum&quot;);
+auto letter   = satisfy(isLetter  ) || left(&quot;not letter&quot;  );
```

* [修正後の parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/4282afab8b71b96924335c39f8433358ec9c33a4)

型推論の弱さを補うため、`left`は特殊化したオーバーロードを実装しています。

先ほどと同じコードをテストして、エラーの変化を確認します。

```text:実行結果
[line 1, col 3] too short
[line 1, col 1] not char &#39;a&#39;: &#39;1&#39;
[line 1, col 1] not digit: &#39;a&#39;
[line 1, col 1] not letter: &#39;1&#39;
[line 1, col 2] not digit: &#39;b&#39;
[line 1, col 1] not letter: &#39;1&#39;
[line 1, col 1] not digit: &#39;!&#39;
[line 1, col 2] not char &#39;b&#39;: &#39;c&#39;
[line 1, col 2] not char &#39;b&#39;: &#39;c&#39;
[line 1, col 2] not string &quot;ab&quot;: &#39;c&#39;
```

エラーの種類が分かるようになりました。説明用にはこれくらいで十分でしょう。

# おわりに

パーサコンビネータの動作イメージがつかめたでしょうか。

今回のようにテストだけではどう応用して良いのか分からないかもしれません。続編で四則演算器を作っているので、そちらも参考にしてください。

* [C++11 パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/f86f2f7ad68cfff1b399) 2015.11.30
</textarea><input type="submit" name="commit" value="Save changes" data-disable-with="Save changes" /></form></div></section></div><div class="col-sm-3"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="C++11 パーサコンビネータ 超入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/6a12160276a8db358e34" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="C++11 パーサコンビネータ 超入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/6a12160276a8db358e34" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/6a12160276a8db358e34" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/6a12160276a8db358e34" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div><section class="itemsShowAuthorInfo" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><a href="/7shi"><img alt="" class="itemsShowAuthorInfo_userIcon" itemprop="image" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" /></a><div class="itemsShowAuthorInfo_profileStats"><strong class="itemsShowAuthorInfo_userName" itemprop="name"><a itemprop="url" href="/7shi">7shi</a></strong><div class="itemsShowAuthorInfo_contribution"><span class="itemsShowAuthorInfo_count">2522</span><span class="itemsShowAuthorInfo_unit">Contribution</span></div><div data-react-class="T.UserFollowButton" data-react-props="{&quot;url_name&quot;:&quot;7shi&quot;,&quot;initial_followed_by&quot;:false,&quot;size&quot;:&quot;btn-xs&quot;,&quot;position&quot;:&quot;author-info&quot;}"></div></div><section class="itemsShowAuthorPopularItems"><h5 class="itemsShowAuthorPopularItems_sectionTitle">Popular Posts</h5><ul class="itemsShowAuthorPopularItems_posts list-unstyled"><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/145f1234f8ec2af923ef">Haskell 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/547b6137d7a3c482fe68">モナド則がちょっと分かった？</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/cac7b3e9b90bf91b00cc">文字列で学ぶC++入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/85afd7bbd5d6c4115ad6">Haskell アクション 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/d1e5a0c22be6cf61d286">Haskell IDE Leksah 入門</a></li></ul></section></section><div class="scroll-chaser"><div class="google-adsense"><style>.test-text-responsible { width: 200px; height: 200px; }@media(min-width: 1200px) {  .test-text-responsible { width: 250px; height: 250px; }}@media(max-width: 979px) and (min-width: 768px) {  .test-text-responsible { width: 120px; height: 240px; }}@media(max-width: 767px) {  .test-text-responsible { width: 320px; height: 50px; }}</style><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle test-text-responsible" data-ad-client="ca-pub-8127218772604357" data-ad-slot="3880091879" style="display:inline-block"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div><div data-react-class="T.Toc" data-react-props="{&quot;body&quot;:&quot;\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%B3%E3%83%B3%E3%82%BB%E3%83%97%E3%83%88\&quot;\u003eコンセプト\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9F%BA%E7%A4%8E%E7%B7%A8\&quot;\u003e基礎編\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#1%E6%96%87%E5%AD%97%E5%8F%96%E5%BE%97\&quot;\u003e1文字取得\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%80%A3%E7%B6%9A%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97\&quot;\u003e連続呼び出し\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9\&quot;\u003e型エイリアス\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0%E5%8C%96\&quot;\u003e関数化\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B\&quot;\u003e組み合わせ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%86%E3%82%B9%E3%83%88%E9%96%A2%E6%95%B0\&quot;\u003eテスト関数\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9-1\&quot;\u003e型エイリアス\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BE%8B%E5%A4%96\&quot;\u003e例外\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#stdfunction\&quot;\u003estd::function\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%9D%A1%E4%BB%B6%E5%8F%96%E5%BE%97\&quot;\u003e条件取得\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%85%B1%E9%80%9A%E5%8C%96\&quot;\u003e共通化\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2\&quot;\u003eファイル分割\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%96%87%E5%AD%97%E5%88%A4%E5%AE%9A\&quot;\u003e文字判定\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BA%8B%E5%89%8D%E5%AE%9A%E7%BE%A9\&quot;\u003e事前定義\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E5%88%A4%E5%AE%9A\&quot;\u003e組み合わせ判定\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%AE%E5%AE%9A%E7%BE%A9\&quot;\u003eコンビネータの定義\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%90%E5%90%88\&quot;\u003e結合\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97\&quot;\u003e繰り返し\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#many\&quot;\u003emany\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%BE%E3%81%A8%E3%82%81\&quot;\u003eまとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%81%B8%E6%8A%9E\&quot;\u003e選択\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%8D%98%E7%B4%94%E3%81%AA%E5%AE%9F%E8%A3%85\&quot;\u003e単純な実装\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#many%E3%81%A8%E3%81%AE%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B\&quot;\u003emanyとの組み合わせ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%90%E5%90%88%E3%81%A8%E9%81%B8%E6%8A%9E\&quot;\u003e結合と選択\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%A8%E3%83%A9%E3%83%BC%E5%8C%96\&quot;\u003eエラー化\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86\&quot;\u003e共通部分\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF\&quot;\u003eバックトラック\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#tryp\&quot;\u003etryp\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#string\&quot;\u003estring\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%BE%E3%81%A8%E3%82%81-1\&quot;\u003eまとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%A8%E3%83%A9%E3%83%BC%E8%A1%A8%E7%A4%BA\&quot;\u003eエラー表示\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AF%E3%83%A9%E3%82%B9%E5%8C%96\&quot;\u003eクラス化\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BD%8D%E7%BD%AE\&quot;\u003e位置\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%AF%BE%E8%B1%A1%E3%81%AE%E6%96%87%E5%AD%97\&quot;\u003e対象の文字\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A4%B1%E6%95%97%E3%81%AE%E7%A2%BA%E5%AE%9A\&quot;\u003e失敗の確定\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB\&quot;\u003eおわりに\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n&quot;,&quot;wrapper&quot;:&quot;#article-body-wrapper&quot;}"></div></div></div><div class="row"><div class="col-sm-9"><div class="ArticleFooter__menu"><div class="s-flex-align-center"><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:38,&quot;show_count&quot;:true,&quot;uuid&quot;:&quot;6a12160276a8db358e34&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-footer&quot;}"></div><div class="ArticleFooter__userList"><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="unsolvedprobrem"><a itemprop="url" href="/unsolvedprobrem"><img alt="unsolvedprobrem" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/34654/profile-images/1478738737" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="qb0C80aE"><a itemprop="url" href="/qb0C80aE"><img alt="qb0C80aE" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/45715/profile-images/1482123489" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="oroshi"><a itemprop="url" href="/oroshi"><img alt="oroshi" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/50790/profile-images/1483948028" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="yatanokarasu"><a itemprop="url" href="/yatanokarasu"><img alt="yatanokarasu" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/85486/profile-images/1473703445" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="npaint1a"><a itemprop="url" href="/npaint1a"><img alt="npaint1a" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/101750/profile-images/1473708487" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="midoriya"><a itemprop="url" href="/midoriya"><img alt="midoriya" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/61692/profile-images/1473695734" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="EqualL2"><a itemprop="url" href="/EqualL2"><img alt="EqualL2" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/71548/profile-images/1473698862" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="iwadon"><a itemprop="url" href="/iwadon"><img alt="iwadon" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/2070/profile-images/1484641283" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="kou_tana77"><a itemprop="url" href="/kou_tana77"><img alt="kou_tana77" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/45958/profile-images/1473690481" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="hamu502"><a itemprop="url" href="/hamu502"><img alt="hamu502" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38910/profile-images/1473687923" /></a></div></div><div class="ArticleFooter__user"><a href="/7shi/items/6a12160276a8db358e34/likers"><span class="fa fa-ellipsis-h"></span></a></div></div></div><div class="u-flex u-align-center"><div class="ArticleFooter__stock"><div class="js-stockbutton" data-position="footer_menu" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="ArticleFooter__editRequest"><a class="u-link-no-underline" data-toggle="tooltip" title="You can propose improvements about the article to the author 💪" href="/drafts/6a12160276a8db358e34/edit"><span class="fa fa-send-o fa-lg"></span> <span>Edit request</span></a></div><div class="dropdown ArticleFooter__dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h"></span></a><ul class="dropdown-menu dropdown-menu-right"><li><a href="/7shi/items/6a12160276a8db358e34.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><i class="fa fa-fw fa-flag"></i> Report article</a></li></ul></div></div></div><ul class="references js-referencesView"><li class="references_header"><i class="fa fa-fw fa-link"></i> Linked from these articles</li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/b8c741e78a96ea2c10fe#_reference-8dbacbfc62ad15772237"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell 構文解析 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-11-27T23:51:38+00:00">over 1 year ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/f86f2f7ad68cfff1b399#_reference-e975649fb888c3350adc"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />C++11 パーサコンビネータ 超入門 2</a><time class="references_datetime js-dateTimeView" datetime="2015-11-30T09:20:02+00:00">over 1 year ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/68228e19552c271bea81#_reference-21cd06d3fac30fc2b771"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Java パーサコンビネータ 超入門</a><time class="references_datetime js-dateTimeView" datetime="2016-05-12T05:23:39+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/39a9ddffcc5bdf2c0142#_reference-6d063f69981c5cc92f36"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Java パーサコンビネータ 超入門 2</a><time class="references_datetime js-dateTimeView" datetime="2016-05-13T16:54:03+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/04c2991239894687ef2f#_reference-3bed51bf5cd6a1f4b57e"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />JSONパーサーを作る</a><time class="references_datetime js-dateTimeView" datetime="2016-12-26T13:38:03+00:00">2 months ago</time></li></ul><div class="itemsShowBody_articleColumnFooter"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="C++11 パーサコンビネータ 超入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/6a12160276a8db358e34" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="C++11 パーサコンビネータ 超入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/6a12160276a8db358e34" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/6a12160276a8db358e34" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/6a12160276a8db358e34" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div></div><div class="itemsShowComment_wrapper" id="comments"><div data-react-class="T.CommentListContainer" data-react-props="{&quot;currentUser&quot;:null,&quot;initialComments&quot;:[],&quot;monthly_public_image_uploadable_size_limit&quot;:null,&quot;total_uploaded_public_image_size_in_current_month&quot;:null,&quot;item&quot;:{&quot;id&quot;:346063,&quot;uuid&quot;:&quot;6a12160276a8db358e34&quot;,&quot;suspended&quot;:false,&quot;secret&quot;:false},&quot;owner&quot;:{&quot;url_name&quot;:&quot;7shi&quot;},&quot;is_team&quot;:false,&quot;is_project&quot;:false,&quot;logged_in&quot;:false,&quot;polling&quot;:false,&quot;mention_candidates&quot;:[{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}]}">Comments Loading...</div></div></div></div></div></article><div class="js-report-form modal fade reportForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Report article</h4></div><div class="modal-body"><form action="/reports" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="1n6SVLfzgzqOorl0kPvFrvl/JkNP+g8fuPJLqPmT+da4/AkMLN26cXFxDGjgDnv3mTgC8Ng+VeiELEJTGJ33EA==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/6a12160276a8db358e34" /><input type="hidden" name="item_uuid" id="item_uuid" value="6a12160276a8db358e34" /><p>Help us understand the problem. What is going on with this item?</p><br /><div class="form-group"><ul class="list-unstyled"><li><label><input type="radio" name="report_type" id="report_type_spam" value="spam" required="required" /> It&#39;s spam </label></li><li><label><input type="radio" name="report_type" id="report_type_harassment" value="harassment" required="required" /> It&#39;s abusive or harmful </label></li><li><label><input type="radio" name="report_type" id="report_type_inappropriate_content" value="inappropriate_content" required="required" /> It contains inappropriate content </label></li></ul></div><div class="reportForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary reportForm_submitButton"><i class="fa fa-send"></i> Submit</button></div></form></div></div></div></div><script id="js-item" type="application/json">{ "url": "http://qiita.com/7shi/items/6a12160276a8db358e34", "id": 346063, "uuid": "6a12160276a8db358e34" }</script><script class="js-user" type="application/json">{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}</script><script language="JavaScript" src="//cdn.bigmining.com/private/js/qiita_bigmining.js" type="text/javascript"></script></div><footer class="footer"><div class="footer_inner"><div class="footer_container"><ul class="footer_links-left"><li class="footer_link"><a class="footer_copyright" href="http://increments.co.jp">© 2011-2017 Increments Inc.</a></li><li class="footer_link"><a href="http://qiita.com/terms">Terms</a></li><li class="footer_link"><a href="http://qiita.com/privacy">Privacy</a></li><li class="footer_link"><a href="http://help.qiita.com">Help</a></li><li class="footer_link"><a href="https://increments.zendesk.com/anonymous_requests/new">Contact</a></li></ul><ul class="footer_links-right"><li class="footer_link"><a href="http://qiita.com/about">About</a></li><li class="footer_link"><a href="/users">Users</a></li><li class="footer_link"><a href="/tags">Tags</a></li><li class="footer_link"><a href="http://blog.qiita.com">Blog</a></li><li class="footer_link"><a href="http://qiita.com/api/v2/docs">API</a></li><li class="footer_link"><a href="https://teams.qiita.com/">Team</a></li><li class="footer_link"><a href="http://kobito.qiita.com">Kobito</a></li><li class="footer_link"><a class="js-public-form-feedback-link" data-target=".js-feedback-form" data-toggle="modal" href=""><i class="fa fa-heart"></i> Feedback <i class="fa fa-caret-down"></i></a></li></ul></div></div></footer><div class="js-feedback-form modal fade feedbackForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Feedback</h4></div><div class="modal-body"><form class="js-feedback-form-form" action="/feedbacks" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="BEDa0dY3JdrLQuBepnks7BgIzb8oXuZRsBvHp5cWxDpqwkGJTRkckTSRVULWjJK1eE/pDL+avKaMxc5cdhjK/A==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/6a12160276a8db358e34" /><div class="form-group"><textarea name="feedback[message]" id="feedback_message" class="form-control js-feedback-form-text-area" placeholder="Please give us any feedback about Qiita." required="required" rows="5">
</textarea></div><div class="feedbackForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary feedbackForm_submitButton"><i class="fa fa-send"></i> Submit</button><p class="feedbackForm_note">We don&#39;t reply to any feedback.<br />If you need help with Qiita, please send a support request from <a href="https://increments.zendesk.com/anonymous_requests/new">here</a>.</p></div><div style="position:fixed;top:-99999px;opacity:0.0001;"><input name="feedback[name]" type="text" /></div></form></div></div></div></div><script>// if (window.mixpanel instanceof Element) {
//   window.mixpanel = [];
// }
// (function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
// for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);</script><script src="http://cdn.qiita.com/assets/public-8c6201a66dc6db6f64a9017391c319bf.min.js"></script><script>
  (function () {
    var script = document.getElementsByTagName('script')[0];
    var load = function (src, id) {
      var el = document.createElement('script');
      el.async = true;
      el.src = src;
      el.id = id;
      script.parentNode.insertBefore(el, script);
    };
      // Optimizely
      load('//cdn.optimizely.com/js/52738645.js', 'optimizely-jssdk');
      // Google Analytics
      window._gaq = window._gaq || [];
      var isCareer = location.hostname.split('.')[0] == 'career';
      if (isCareer) {
        window._gaq.push(['_setAccount', 'UA-24675221-11']);
        window._gaq.push(['_setDomainName', 'qiita.com']);
      } else {
        window._gaq.push(['_setAccount', 'UA-24675221-1']);
      }
      window._gaq.push(['_setCustomVar', 1, 'logged_in', 'false', 2]);
      window._gaq.push(['_trackPageview']);
      var src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      load(src, 'google-analytics-jssdk');
    // Google Analytics - Universal Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-24675221-12', {
          
        });
        ga('set', 'dimension1', 'false');
        ga('set', 'dimension3', 'false');
      ga('require', 'displayfeatures');
      ga('set', 'forceSSL', true);
      ga('send', 'pageview');
    // Google Tag Manager
      (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-TBQWPN');
  })();
</script>
</body></html>