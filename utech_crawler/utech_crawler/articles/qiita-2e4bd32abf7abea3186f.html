<!DOCTYPE html><html xmlns:og="http://ogp.me/ns#"><head><meta charset="UTF-8" /><title>契約による設計から見た例外 - Qiita</title><meta content="width=device-width,initial-scale=1" name="viewport" /><meta content="
正しさは相対的な概念である。 Bertrand Meyer [1]


Bertrand Meyer氏は「契約による設計」という概念から例外を導出し、例外の必要性をエレガントに説明しています。また、彼の説明に則れば今までの議論と比べて例外をいくぶんか形式的に扱えるようになります。契約による設計を学ぶ前に、プログラムの正しさについてもう一度考えてみましょう。


プログラムの正しさ

あるプログラムが正しいかどうかを判定するにはどのようにすれば良いでしょうか。最も簡単な..." name="description" /><meta content="summary" name="twitter:card" /><meta content="@Qiita" name="twitter:site" /><meta content="Kokudori" name="twitter:creator" /><meta content="契約による設計から見た例外 - Qiita" property="og:title" /><meta content="article" property="og:type" /><meta content="http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" property="og:url" /><meta content="http://cdn.qiita.com/assets/qiita-fb-2887e7b4aad86fd8c25cea84846f2236.png" property="og:image" /><meta content="&gt; 正しさは相対的な概念である。 Bertrand Meyer [1]

Bertrand Meyer氏は「契約による設計」という概念から例外を**導出**し、例外の必要性をエレガントに説明しています。また、彼の説明に則れば今までの議..." property="og:description" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><link rel="shortcut icon" type="image/x-icon" href="http://cdn.qiita.com/assets/favicons/public/production-4ff10c1e1e2b5fcb353ff9cafdd56c70.ico" /><link rel="apple-touch-icon" type="image/png" href="http://cdn.qiita.com/assets/favicons/public/apple-touch-icon-f9a6afad761ec2306e10db2736187c8b.png" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link rel="stylesheet" media="all" href="http://cdn.qiita.com/assets/public-e8d29e8ff1879118096f0f5877946857.min.css" /><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="oIRDA7tiK/Ug/bcUnLK2DRhmgOKy9jBjz+zDjt5Bl/POBthbIEwSvt8uAgjsRwhUeCGkUSUyapTzMsp1P0+ZNQ==" /></head><body class="without-js" id=""><noscript><iframe height="0" src="//www.googletagmanager.com/ns.html?id=GTM-TBQWPN" style="display:none;visibility:hidden" width="0"></iframe></noscript><script>
  document.body.className = document.body.className.replace('without-js', '') + ' with-js';
  window.Qiita = {"asset_host":"cdn.qiita.com","TLD":"com","controller_path":"public/items","controller_action":"public/items#show","controller":"items","action":"show","env":"production","flash":{},"is_landing_page":false,"is_team_page":false,"root_domain":"qiita.com","variant":null,"config":{"mixpanel":{"career":"dd35af27e959781713d63fd7ca898a8d","per_team":"c0a2116368b33b44b5029ebd2cc9b094","public":"be87616606b0e26a87689099aab2c4e5","team":"b7c0342acba2dbc8742484d98788efb3"},"default_locale":"ja","locale":"en"},"team":null,"user":null,"GIT_BRANCH":null,"DEBUG":false};

</script>
<div class="headerContainer headerContainer-public" role="navigation"><div data-react-class="T.HeaderContainer" data-react-props="{&quot;user&quot;:null,&quot;team&quot;:null,&quot;news&quot;:{&quot;type&quot;:&quot;Hot&quot;,&quot;content&quot;:&quot;Markdownによる情報共有サービス、Qiita:Team&quot;,&quot;url&quot;:&quot;https://teams.qiita.com?utm_source=qiita\u0026utm_medium=header_news&quot;},&quot;initial_unread_count&quot;:null,&quot;siteid_image&quot;:&quot;http://cdn.qiita.com/siteid-reverse.png&quot;,&quot;is_team_page&quot;:false,&quot;on_team_setting&quot;:false,&quot;show_post_menu&quot;:true,&quot;show_search_menu&quot;:true,&quot;is_fluid&quot;:false,&quot;locale&quot;:&quot;en&quot;}"></div></div><div id="main"><ol class="itemBreadcrumbs" itemscope="" itemtype="http://schema.org/BreadcrumbList"><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/"><span itemprop="name">Qiita</span></a><meta content="1" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/items"><span itemprop="name">Items</span></a><meta content="2" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/tags/%E4%BE%8B%E5%A4%96"><span itemprop="name">例外</span></a><meta content="3" itemprop="position" /></li></ol><article itemscope="" itemtype="http://schema.org/Article"><div class="ArticleMainHeader ArticleMainHeader--adcalItem"><div class="container"></div><div class="container"><div class="row s-flex-align-center"><div class="col-sm-9"><div class="adventCalendarRibbon"><span><a class="adventCalendarRibbon_title" href="/advent-calendar/2014/exception">例外 Advent Calendar 2014</a> Day 3</span></div><h1 class="ArticleMainHeader__title">契約による設計から見た例外</h1><ul class="TagList"><li class="TagList__item" data-count="41"><a class="u-link-unstyled TagList__label" href="/tags/%E4%BE%8B%E5%A4%96"><img alt="例外" class="TagList__icon" src="//cdn.qiita.com/assets/icons/medium/missing-2e17009a0b32a6423572b0e6dc56727e.png" /><span>例外</span></a></li></ul></div><div class="col-sm-3"><div class="itemsShowHeaderStock"><ul class="list-unstyled itemsShowHeaderStock_statusList"><li><div class="itemsShowHeaderStock_count stock"><span class="fa fa-thumbs-up"></span><span class="js-likecount">173</span></div><div class="itemsShowHeaderStock_countText">Like</div></li><li><div class="itemsShowHeaderStock_count" content="14 UserComments" itemprop="interactionCount"><span class="fa fa-comment"></span>14</div><div class="itemsShowHeaderStock_countText">Comment</div></li></ul></div><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:173,&quot;uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-header&quot;}"></div><ul class="list-inline ArticleMainHeader__users"><li class="js-hovercard" data-hovercard-target-name="magicant"><a itemprop="url" href="/magicant"><img alt="magicant" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694" /></a></li><li class="js-hovercard" data-hovercard-target-name="bells17"><a itemprop="url" href="/bells17"><img alt="bells17" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/13148/profile-images/1473682696" /></a></li><li class="js-hovercard" data-hovercard-target-name="funnything"><a itemprop="url" href="/funnything"><img alt="funnything" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/12653/profile-images/1473682479" /></a></li><li class="js-hovercard" data-hovercard-target-name="cigalecigales"><a itemprop="url" href="/cigalecigales"><img alt="cigalecigales" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/48912/profile-images/1473691524" /></a></li><li class="js-hovercard" data-hovercard-target-name="matsu_chara"><a itemprop="url" href="/matsu_chara"><img alt="matsu_chara" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/14260/profile-images/1473683255" /></a></li><li class="js-hovercard" data-hovercard-target-name="daneko0123"><a itemprop="url" href="/daneko0123"><img alt="daneko0123" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/1221/profile-images/1473683109" /></a></li><li class="js-hovercard" data-hovercard-target-name="sisidovski"><a itemprop="url" href="/sisidovski"><img alt="sisidovski" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/6436/profile-images/1473682868" /></a></li><li class="js-hovercard" data-hovercard-target-name="yuba"><a itemprop="url" href="/yuba"><img alt="yuba" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/2852/profile-images/1473682178" /></a></li><li class="js-hovercard" data-hovercard-target-name="yuukigoodman"><a itemprop="url" href="/yuukigoodman"><img alt="yuukigoodman" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/11737/profile-images/1473682135" /></a></li><li class="js-hovercard" data-hovercard-target-name="hirofummy"><a itemprop="url" href="/hirofummy"><img alt="hirofummy" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/6419/profile-images/1473682860" /></a></li><li><a href="/Kokudori/items/2e4bd32abf7abea3186f/likers"><span class="fa fa-ellipsis-h"></span></a></li></ul></div></div></div></div><div class="ArticleAsideHeader"><div class="container"><div class="u-flex u-space-between"><div class="u-flex u-flex-wrap"><div class="u-flex u-align-center s-pdv-5 u-flex-wrap"><div class="ArticleAsideHeader__author"><a href="/Kokudori"><img class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775" alt="1473682775" /></a> <a class="u-link-unstyled" href="/Kokudori">Kokudori</a> </div><div class="ArticleAsideHeader__date"><span data-toggle="tooltip" title="posted at 2014-12-03">Edited at <time datetime="2014-12-05T21:18:37+09:00" itemprop="dateModified">2014-12-05</time></span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"><div class="ArticleAsideHeader__revision"> <a data-toggle="tooltip" title="Revisions" href="/Kokudori/items/2e4bd32abf7abea3186f/revisions"><span class="fa fa-history"></span></a><span class="ArticleAsideHeader__revisionCount">2</span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"></div></div><div class="u-flex u-align-center s-flex-justiry-between s-pdv-5 u-shrink-0"><div class="ArticleAsideHeader__stock"><div class="js-stockbutton" data-position="top" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h fa-lg"></span></a><ul class="dropdown-menu dropdown-menu-right"><li class="dropdown__item--mobile"><a href="/Kokudori/items/2e4bd32abf7abea3186f/revisions"><span class="fa fa-fw fa-history"></span> Revisions<span>(2)</span></a></li><li><a href="/Kokudori/items/2e4bd32abf7abea3186f.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><span class="fa fa-fw fa-flag"></span> Report article</a></li></ul></div></div></div></div></div><div class="container"><div class="row" id="article-body-wrapper"><div class="col-sm-9"><section class="markdownContent markdownContent-headingEnabled js-task-list-container clearfix position-relative" id="item-2e4bd32abf7abea3186f" itemprop="articleBody"><div class="alert alert-warning"><i class="fa fa-clock-o"></i> More than 1 year has passed since last update.</div><blockquote>
<p>正しさは相対的な概念である。 Bertrand Meyer [1]</p>
</blockquote>

<p>Bertrand Meyer氏は「契約による設計」という概念から例外を<strong>導出</strong>し、例外の必要性をエレガントに説明しています。また、彼の説明に則れば今までの議論と比べて例外をいくぶんか形式的に扱えるようになります。契約による設計を学ぶ前に、プログラムの正しさについてもう一度考えてみましょう。</p>

<h2>
<span id="プログラムの正しさ" class="fragment"></span><a href="#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%AD%A3%E3%81%97%E3%81%95"><i class="fa fa-link"></i></a>プログラムの正しさ</h2>

<p>あるプログラムが正しいかどうかを判定するにはどのようにすれば良いでしょうか。最も簡単な方法は、あるプログラムの正しさを形式的に定義する事です。より直接的に言えば、あるプログラムの正しさを簡単な論理式で表現します。その論理式が真ならばそのプログラムは正しい。偽ならばそのプログラムは正しくありません。<br>
これだけだと関数の戻り値を検査すれば良いだけのようにも聞こえます。しかし、そう簡単な話ではありません。純粋でない言語の場合、処理の前後で副作用が発生している可能性があります。例えば、処理を呼び出すたびにデータの内容が書き換わることがあるでしょう。なるほど、戻り値だけを調べるだけでは済まなさそうです。<br>
さらに、ある処理が呼び出される前提となる条件を考える必要があります。例えば整数の除算を考えてみましょう。除算処理は除数に0が来た時のみ失敗します。除数が0でない全ての整数において成功します。処理によっては、呼ばれる前の前提が成否に大きく影響をあたえるものがあります。<br>
これらを加味して、ある処理が呼ばれる前後で成り立つ条件を考えれば、その処理の正しさを表現できたことになるはずです。それらを便宜上「正しさの条件」と呼ぶことにしましょう。<br>
ある処理が呼ばれる前に成立すべき条件を<strong>事前条件</strong>、ある処理が呼び出された後に成立すべき条件を<strong>事後条件</strong>と呼びます。事前条件、処理、事後条件の3組を考えることでその処理の正しさを判定することができます*1。<br>
これで処理の正しさを考えることが出来ました。次に、データの正しさを考えましょう。データが正しくなければ、そのデータを用いた処理も正しくはないでしょう。<br>
データは処理とは違い、呼ぶ呼ばれるの関係にありません。そのため、常に成り立つ1つの条件を考えれば良いでしょう。このような、データが常に満たすべき条件を<strong>不変条件</strong>と呼びます。例えば、自然数の不変条件は「0以上」です*2。<br>
ここで、「成功」と「失敗」をより形式的に定義することができます。成功とは「関係データの不変条件が常に成り立ち、事前条件が成り立ち、処理が呼ばれ、事後条件が成り立つ」場合を指します。失敗とは「関係データの不変条件がいずれかの時点で成り立たない、又は事前条件が成り立たない、又は処理呼び出し後の事後条件が成り立たない」場合を指します。つまり、正しさの条件が成り立てば成功。成り立たなければ失敗です。</p>

<h3>
<span id="例スタック" class="fragment"></span><a href="#%E4%BE%8B%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>例：スタック</h3>

<p>例としてスタックの正しさについて考えてみましょう。スタックを実装する言語は何でもいいのですが、ここではRubyで書いてみましょう。</p>

<div class="code-frame" data-lang="ruby">
<div class="code-lang"><span class="bold">stack.rb</span></div>
<div class="highlight"><pre>
<span class="k">class</span> <span class="nc">Stack</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:arr</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pop</span><span class="p">()</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">slice!</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>

<p>さて、考えるべきは<code>Stack</code>クラスの不変条件と、<code>push</code>と<code>pop</code>の事前条件と事後条件です*3。</p>

<p>最初に<code>Stack</code>クラスの不変条件です。これは<code>arr</code>アクセサが<code>Array</code>相当、つまり<code>&lt;&lt;</code>又は<code>slice!</code>メソッドを持つことです。厳密には<code>arr.&lt;&lt;</code>や<code>arr.slice!</code>の操作についても規定すべきですが、Ruby文化とも合いませんのでここでは省略します。<code>Stack</code>クラスの不変条件は<code>arr.respond_to? '&lt;&lt;' and arr.respond_to? 'slice!'</code>です。</p>

<p>次に<code>push</code>メソッドの事前条件を考えてみましょう。しかし、<code>push</code>メソッドは特に前提となる条件がありません。値を終端に追加するだけですので、当然です。つまり、事前条件がありません。言い換えれば、常に事前条件は満たされます。よって、<code>push</code>メソッドの事前条件は<code>true</code>です。<br>
<code>push</code>メソッドの事後条件は、<code>arr</code>の終端に<code>value</code>を追加したことです。これを論理式で直接表現する事は出来ません。何故なら、追加された事を確かめるには処理が呼び出される前の<code>arr</code>と比較する必要があるからです。そこで、事後条件でのみ、処理が呼び出される前の値にアクセスできるよう<code>old(expr)</code>という構文を導入しましょう。そうすると、事後条件は<code>arr.length - old(arr).length == 1 and arr.last == value</code>と書けます。</p>

<p>そして<code>pop</code>メソッドの事前条件ですが、これは厄介です。<code>arr</code>が空配列の場合はどうでしょう。「空のスタックからpopする」という行為はどのような意味があるのでしょうか。<strong>ひとまずここでは空スタックのpopを正しくないと仮定します</strong>。そうすると、事前条件全体は<code>arr.length != 0</code>と書くことができます。<br>
最後に<code>pop</code>メソッドの事後条件ですが、呼び出される前の<code>arr</code>の終端から値を取り出して返しているかどうかです。しかし、これも直接論理式で表現できません。何故なら、処理が返した値を参照できないからです。そのため、処理が返した戻り値を<code>result()</code>でアクセスできるよう拡張しましょう。そうすると、事後条件は<code>old(arr).length - arr.length == 1 and result() == old(arr).last</code>と書けます。</p>

<p>以上をコメントとして記述してみましょう。</p>

<div class="code-frame" data-lang="ruby">
<div class="code-lang"><span class="bold">stack.rb</span></div>
<div class="highlight"><pre>
<span class="c1"># 不変条件: arr.respond_to? '&lt;&lt;' and arr.respond_to? 'slice!'</span>
<span class="k">class</span> <span class="nc">Stack</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:arr</span><span class="p">)</span>
  <span class="c1"># 事前条件: true</span>
  <span class="c1"># 事後条件: arr.length - old(arr).length == 1 and arr.last == value</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="c1"># 事前条件: arr.length != 0</span>
  <span class="c1"># 事後条件: old(arr).length - arr.length == 1 and result() == old(arr).last</span>
  <span class="k">def</span> <span class="nf">pop</span><span class="p">()</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">slice!</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>

<h2>
<span id="失敗の原因" class="fragment"></span><a href="#%E5%A4%B1%E6%95%97%E3%81%AE%E5%8E%9F%E5%9B%A0"><i class="fa fa-link"></i></a>失敗の原因</h2>

<p>事前条件、事後条件、そして不変条件を考えると、処理が失敗する可能性としては<br>
1. 事前条件が成り立たない<br>
2. 事後条件が成り立たない<br>
3. 不変条件が成り立たない<br>
の3通りの組み合わせであることがわかります。ここでは各々の条件が独立に成り立たない場合について詳しく分析してみましょう。各々の条件の失敗の組み合わせを考える必要はありません。何故なら、これら3つの条件の内、どれか1つの条件でも成り立たなければ処理の失敗が決まるからです。</p>

<h3>
<span id="事前条件が成り立たない" class="fragment"></span><a href="#%E4%BA%8B%E5%89%8D%E6%9D%A1%E4%BB%B6%E3%81%8C%E6%88%90%E3%82%8A%E7%AB%8B%E3%81%9F%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>事前条件が成り立たない</h3>

<p>事前条件が成り立たない場合、処理は失敗します。もし事前条件が表明されていた場合、その処理が失敗するかどうかは処理の呼び出し側から確認できます。事前条件を満たすように呼び出せば成功、そうでなければ失敗です。<br>
だとすれば事前条件を満たすべき責任とは処理の呼び出し側にあるのでしょうか。より端的に言えば、事前条件が偽となる失敗が起きたとすれば、呼び出し側が悪いのでしょうか。<br>
これが成り立つにはある条件が必要です。それは「事前条件で呼び出された全ての処理が呼び出し側から呼び出せること」です。例えば先程のスタックプログラムを考えてみましょう。<code>pop</code>メソッドの事前条件は<code>arr.length != 0</code>です。しかし、<code>Stack</code>の呼び出し側からは<code>arr.length</code>が呼び出せないため、呼び出し側は<code>Stack</code>の<code>pop</code>メソッドを適切に呼び出す事ができません。<br>
では<code>arr.length == 0</code>を返す<code>empty?</code>メソッドを<code>Stack</code>クラスに定義したとします。この場合、<code>pop</code>メソッドの呼び出し側は<code>empty?</code>メソッドを調べることで<strong>安全に</strong><code>pop</code>メソッドを呼び出すことができます。<br>
<code>Stack</code>クラスはこれで呼び出し側にとってもフェアな実装となりました。<code>empty?</code>メソッドは実装が簡潔なので事前、事後条件は省略しています。</p>

<div class="code-frame" data-lang="ruby">
<div class="code-lang"><span class="bold">stack.rb</span></div>
<div class="highlight"><pre>
<span class="c1"># 不変条件: arr.respond_to? '&lt;&lt;' and arr.respond_to? 'slice!'</span>
<span class="k">class</span> <span class="nc">Stack</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:arr</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">empty?</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">end</span>

  <span class="c1"># 事前条件: true</span>
  <span class="c1"># 事後条件: arr.length - old(arr).length == 1 and arr.last == value</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="c1"># 事前条件: not empty?</span>
  <span class="c1"># 事後条件: old(arr).length - arr.length == 1 and result() == old(arr).last</span>
  <span class="k">def</span> <span class="nf">pop</span><span class="p">()</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">slice!</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>

<p>まとめましょう。事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合、事前条件が成り立たない責任は処理の呼び出し側にあります。何故なら、呼び出し側は合法的に事前条件の合否を判断できる手段を有していたにも関わらず、それを怠ったためです。さらに言えば、事前条件が満たせない場合、呼び出し側には回避手段がありますが実装側にはどうしようもありません。<br>
事前条件が成り立つ時、処理は正しく呼ばれていることが保証されます。</p>

<h3>
<span id="事後条件が成り立たない" class="fragment"></span><a href="#%E4%BA%8B%E5%BE%8C%E6%9D%A1%E4%BB%B6%E3%81%8C%E6%88%90%E3%82%8A%E7%AB%8B%E3%81%9F%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>事後条件が成り立たない</h3>

<p>事後条件が成り立たない場合も、処理は失敗します。これはどちらが悪いのでしょう。実装側でしょうか？それとも呼び出し側でしょうか？<br>
事前条件の時は呼び出し側に責任がありました。しかし、「事前条件で呼び出された全ての処理が呼び出し側から呼び出せること」という実装側の責任を果たした上での呼び出し側の責任です。これは、事前条件は引数等呼び出し側がコントロール可能なものを対象としているためです。では、事後条件は何を対象に扱っているかというと、主にその処理の結果です。これは呼び出し側にはどうすることもありません。<br>
事後条件が成り立たない責任は実装側にあります。何故なら、実装側は事後条件を満たすような処理が実装できると表明しているにも関わらず、それを怠ったためです。さらに言えば、呼び出し側には事後条件を正しく満たすような努力の余地がありません。<br>
事後条件が成り立つ時、処理は正しく実装されていることが保証されます。</p>

<h3>
<span id="不変条件が成り立たない" class="fragment"></span><a href="#%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6%E3%81%8C%E6%88%90%E3%82%8A%E7%AB%8B%E3%81%9F%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>不変条件が成り立たない</h3>

<p>不変条件が成り立たない場合も、処理は失敗します。ここで、不変条件が呼び出し側の責任だと仮定してみましょう。であれば、データは外部から不変条件を満たしたり破壊したりすることができます。これは好ましくありません。<strong>カプセル化</strong>とは、不変条件を満たすようなデータの抽象化だと考えることができます。もし適切にカプセル化されているのであれば、呼び出し側からデータの不変条件に手を加えられるべき道理はありません。<br>
不変条件が成り立たない責任は実装側にあります。ここでいう実装側とは、データとそれに関係する処理全ての実装を行ったものを指します。例えばオブジェクト指向プログラミングでは両者は不可分なものとして一体化され、「オブジェクト」と呼ばれます*4。つまり、不変条件はオブジェクトが適切に実装されている限りにおいて、<strong>常に</strong>満たされます。<br>
不変条件が成り立つ時、オブジェクトは正しく実装されていることが保証されます。</p>

<h2>
<span id="契約による設計" class="fragment"></span><a href="#%E5%A5%91%E7%B4%84%E3%81%AB%E3%82%88%E3%82%8B%E8%A8%AD%E8%A8%88"><i class="fa fa-link"></i></a>契約による設計</h2>

<p>今まで、「実装側」と「呼び出し側」という2人のプログラマを登場させました。そして、あるプログラムの失敗を3通りに分け、各々の場合で<strong>どちらが悪いのか</strong>について議論しました。Bertrand Meyer氏は正しさの条件が2者間の<strong>契約</strong>とみなせることに気づきました。契約、つまり呼び出し側の負うべき義務とそれによる権利、実装側の負うべき義務とそれによる権利を正しさの条件から説明できると考えたのです。<br>
以下に3つの条件を契約とみなした時の呼び出し側と実装側の義務と権利についてまとめてみました。とは言え不変条件は登場しません。不変条件は特定処理の呼び出しに関せず常に成り立つべき正しさだからです。</p>

<table>
<thead>
<tr>
<th style="text-align: center">当事者</th>
<th style="text-align: left">義務</th>
<th style="text-align: left">権利(≒利益)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">呼び出し側</td>
<td style="text-align: left">処理を適切に呼び出す(事前条件を満たす)</td>
<td style="text-align: left">処理が成功する(事後条件が満たされる)</td>
</tr>
<tr>
<td style="text-align: center">実装側</td>
<td style="text-align: left">処理やオブジェクトを適切に実装する(事後条件を満たす)</td>
<td style="text-align: left">処理が適切に呼ばれる(事前条件が満たされる)</td>
</tr>
</tbody>
</table>

<p>この考えに則った設計手法を<strong>契約による設計</strong>(DbC: Design by Contract)と呼びます。ここでは例外についてのみ考えるため、設計手法としての契約による設計は扱いません。</p>

<h3>
<span id="空スタックのpopは正しくないのか" class="fragment"></span><a href="#%E7%A9%BA%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%81%AEpop%E3%81%AF%E6%AD%A3%E3%81%97%E3%81%8F%E3%81%AA%E3%81%84%E3%81%AE%E3%81%8B"><i class="fa fa-link"></i></a>空スタックのpopは正しくないのか？</h3>

<p><code>Stack</code>クラスの例では<code>pop</code>メソッドの事前条件を<code>not empty?</code>と<strong>決めました</strong>。しかし、Rubyの<code>Array</code>クラスの<code>pop</code>メソッドは、配列が空の場合<code>nil</code>を返します。もっと言えば、現在の実装<code>arr.alice! -1</code>は<code>arr</code>が空の時<code>nil</code>を返します。これはどちらが正しいのでしょうか？<br>
答えは、場合による、です。「正しさの条件」とは言い換えれば「正しさの定義」です。つまり、ここで述べた3つの条件による「正しさ」とは「仕様」のことです。空スタックの<code>pop</code>を正しいとして<code>nil</code>を返しても良いですし、正しくないとして失敗させても良いです。どのような仕様にするかは要求を鑑みてプログラマが自分で判断する必要があるというだけの話です。契約のメタファーを借りれば、プログラマは要求に合うようにプログラムの正しさを定義する権利があります。もちろん、プログラムを定義した正しさを満たすよう適切に実装する義務の上での権利です。</p>

<h2>
<span id="契約が破られるとき" class="fragment"></span><a href="#%E5%A5%91%E7%B4%84%E3%81%8C%E7%A0%B4%E3%82%89%E3%82%8C%E3%82%8B%E3%81%A8%E3%81%8D"><i class="fa fa-link"></i></a>契約が破られるとき</h2>

<p>契約という概念を考えた時、失敗を以下のように再定義できます。</p>

<blockquote>
<p>ルーチンが契約を満たす状態で実行を終えた場合、そのルーチンコールは成功である。成功しなければ失敗である。 [1]</p>
</blockquote>

<p>そして、契約と失敗から例外を再定義できます。</p>

<blockquote>
<p>ルーチンの失敗によって、そのルーチンの呼び出し側に例外が発生する。 [1]</p>
</blockquote>

<p>前日に述べたように、例外は回復するか通知するかのどちらかです。</p>

<blockquote>
<p>ルーチンの実行中に例外が起き、ルーチンがその例外から回復しない場合に限り、そのルーチンコールは失敗となる。 [1]</p>
</blockquote>

<p>例外から回復とは、その処理の契約を満たすように出来るかということです。回復できれば成功です。できなければ失敗なので、処理の呼び出し元へ例外が投げられます。<br>
Meyer氏は個々の契約の違反は本質的な問題では無いと考えました。つまり、彼の言葉を借りれば「戦闘の1つには負けても戦争そのものに負けたわけではない」のです。ある処理の契約違反を別の処理が尻拭いしてくれれば、それで良いというわけです。<br>
この関係を図にまとめてみました。例外が契約の観点から見事に説明できています。</p>

<p><a href="https://qiita-image-store.s3.amazonaws.com/0/3206/1b56a9ff-821a-a7a1-4547-6883e9613fdb.png" target="_blank" rel="nofollow noopener"><img src="https://qiita-image-store.s3.amazonaws.com/0/3206/1b56a9ff-821a-a7a1-4547-6883e9613fdb.png" alt="例外と失敗.png"></a></p>

<h3>
<span id="責任不在の失敗" class="fragment"></span><a href="#%E8%B2%AC%E4%BB%BB%E4%B8%8D%E5%9C%A8%E3%81%AE%E5%A4%B1%E6%95%97"><i class="fa fa-link"></i></a>責任不在の失敗</h3>

<p><em>以下の文は筆者による私見です。Meyer氏は『オブジェクト指向入門』ではIO操作に対する契約について言及していません。</em></p>

<p>最後に、契約の概念の限界性について述べます。契約の考えに則れば、あらゆる失敗は処理の呼び出し側もしくは処理の実装側の責任でした。責任がどちらか一方に定まるという性質が契約の大原則でした。<br>
ここで、受け取ったパスからファイルの内容を読み取る<code>file_read</code>関数を考えてみましょう。そして、その<code>file_read</code>関数の事前条件を考えます。どのような事前条件が書けるでしょう。<br>
<code>file_read</code>はファイルパスを受け取るので、その受け取ったファイルパスにファイルが存在するかどうかというものを事前条件として考えられそうです。ひとまず<code>is_exist</code>関数の存在を仮定すれば、<code>file_read</code>関数は以下のようになります。</p>

<div class="code-frame" data-lang="ruby">
<div class="code-lang"><span class="bold">file_read.rb</span></div>
<div class="highlight"><pre>
<span class="c1"># 事前条件: is_exist(path)</span>
<span class="k">def</span> <span class="nf">file_read</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>

<p>つまり、<code>file_read</code>関数は、受け取ったパスにファイルが存在している場合は<strong>常に</strong>成功します。そう、こんなことはありえません。我々はどこで道を間違えたのでしょうか。</p>

<p>全ての処理は大きく2種類に分けることができます。契約を満たせば必ず成功するもの。そして、契約を満たしていてもときおり失敗するものです。これは信頼性の問題です。厳密に言えば全ての処理は後者です。つまり、全ての処理は契約を満たしていても常に成功するとは限りません。<br>
整数同士を足し合わせる<code>add</code>関数があるとします。これは整数を受け取る限り、常に成功しそうです。しかし、実際の処理を行うCPUが壊れていれば失敗します。要件にもよりますが、大抵の場合はCPUの誤作動は想定しません。これも正しさ条件の1つです。プログラム全体の事前条件として、CPUは正しく動くという暗黙の条件があるのです。<br>
ではファイルAPIはどうでしょう。同じことで、HDDが不調かもしれません。OSの割り込みによるタイミングの問題で失敗するかもしれません。ファイル操作はCPUよりも不安定なので、大抵の場合はプログラム全体の事前条件として受け入れることはできません。ファイル、DB、HTTP通信等は一般に信頼性が低く、事前条件を満たしても成功するとは限りません。</p>

<p>ここで、無理やり契約の考えを貫いてみましょう。<code>file_read</code>関数を適切に呼び出した場合、つまり事前条件をみたすように呼び出した場合、呼び出し側の義務は終了です。では、その上で<code>file_read</code>関数が失敗すれば実装側の問題なのでしょうか。しかし、契約とは正しさです。正しくない動作とは、つまるところバグです。</p>

<blockquote>
<p>事前条件違反は顧客側(筆者注：この記事で言う呼び出し側)にバグがある証拠である。<br>
事後条件違反は供給者側(筆者注：この記事で言う実装側)にバグがある証拠である。 [1]</p>
</blockquote>

<p>では、<code>file_read</code>関数の失敗は実装者によるバグなのでしょうか。仮にバグだとしてもどうしようもありません。何故ならそのバグは取り除けないからです。どのように慎重に実装を行ったとしても、<code>file_read</code>関数の信頼性を他の処理、例えばスタック操作と同程度にまで引き上げるのは困難です。<br>
<code>file_read</code>関数の存在、もっと一般に、IO操作は契約の概念が適用できません。何故なら、契約を満たしても失敗する可能性があるからです。そして、その失敗は誰の責任でもありません。ただ、運が悪かっただけです。もう一度試してみれば上手くいくかもしれません。</p>

<h2>
<span id="注釈" class="fragment"></span><a href="#%E6%B3%A8%E9%87%88"><i class="fa fa-link"></i></a>注釈</h2>

<p>*1: この3組、及び3組を用いたプログラムの正しさについての研究をTony Hoarが行ったことから、3組を<strong>ホーア・トリプル</strong>と呼ばれ、以下のように書き表します。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre>
{P} C {Q}
</pre></div></div>

<p>Pはprecondition、Qはpostcondition、Cはcommandの意味です。<br>
また、単純なホーア・トリプルではプログラムCの正しさを完全に表現することはできません。何故なら、Cが停止しない可能性があるためです。そのため、単純なホーア・トリプルはプログラムの部分的な正しさしか表現できません。<br>
PやQの停止性については、ここでは考えません。</p>

<p>*2: ここでは自然数を0以上の整数としています。</p>

<p>*3: ここではいくつかの条件を省略しています。本来は<code>{P} C {Q}</code>において<code>C</code>に副作用を認める限り、<code>P</code>, <code>Q</code>はプログラム上のあらゆる作用を記述する必要があります。また、<code>P</code>や<code>Q</code>の内部で別の処理を呼び出す事の正しさについてもここでは無視しています。しかし、この記事の本質はプログラムの正しさを検討することではありません。ここでの正しさは例外を考える程度のものでよいので、厳密な意味での正しさは扱いません。</p>

<p>*4: Meyer氏は著書『オブジェクト指向入門』にて契約による設計を提唱しました。そのため、彼の説明はオブジェクト指向プログラミングに依存しています。しかし、現代的なプログラミング言語であればデータに対する何らかの抽象化機構が提供されているはずです。例えばMLに由来する多くの関数型言語はモジュールによってデータと操作の一体化が可能です。ここで言うオブジェクトとは抽象データ型(ADT: Abstract Data Type)を実現する1手法程度の意味に過ぎません。</p>

<h2>
<span id="参考文献" class="fragment"></span><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><i class="fa fa-link"></i></a>参考文献</h2>

<p>[1]: 『オブジェクト指向入門 第2版 原則・コンセプト』 Bertrand Meyre, 翔泳社 2007</p>
<div class="hidden"><form class="js-task-list-update" action="/Kokudori/items/2e4bd32abf7abea3186f" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="_method" value="patch" /><input type="hidden" name="authenticity_token" value="alTUKx7jd3dm6kp4wDov5+1gyK9tG0DY/reZPSCONoUE1k9zhc1OPJk5/2Swz5G+jSfsHPrfGi/CaZDGwYA4Qw==" /><input type="hidden" name="updated_at_confirmation_in_unixtime" id="updated_at_confirmation_in_unixtime" value="1417781917" class="js-task-list-updated-at" /><textarea name="raw_body" id="raw_body" class="js-task-list-field">
&gt; 正しさは相対的な概念である。 Bertrand Meyer [1]

Bertrand Meyer氏は「契約による設計」という概念から例外を**導出**し、例外の必要性をエレガントに説明しています。また、彼の説明に則れば今までの議論と比べて例外をいくぶんか形式的に扱えるようになります。契約による設計を学ぶ前に、プログラムの正しさについてもう一度考えてみましょう。

## プログラムの正しさ
あるプログラムが正しいかどうかを判定するにはどのようにすれば良いでしょうか。最も簡単な方法は、あるプログラムの正しさを形式的に定義する事です。より直接的に言えば、あるプログラムの正しさを簡単な論理式で表現します。その論理式が真ならばそのプログラムは正しい。偽ならばそのプログラムは正しくありません。
これだけだと関数の戻り値を検査すれば良いだけのようにも聞こえます。しかし、そう簡単な話ではありません。純粋でない言語の場合、処理の前後で副作用が発生している可能性があります。例えば、処理を呼び出すたびにデータの内容が書き換わることがあるでしょう。なるほど、戻り値だけを調べるだけでは済まなさそうです。
さらに、ある処理が呼び出される前提となる条件を考える必要があります。例えば整数の除算を考えてみましょう。除算処理は除数に0が来た時のみ失敗します。除数が0でない全ての整数において成功します。処理によっては、呼ばれる前の前提が成否に大きく影響をあたえるものがあります。
これらを加味して、ある処理が呼ばれる前後で成り立つ条件を考えれば、その処理の正しさを表現できたことになるはずです。それらを便宜上「正しさの条件」と呼ぶことにしましょう。
ある処理が呼ばれる前に成立すべき条件を**事前条件**、ある処理が呼び出された後に成立すべき条件を**事後条件**と呼びます。事前条件、処理、事後条件の3組を考えることでその処理の正しさを判定することができます\*1。
これで処理の正しさを考えることが出来ました。次に、データの正しさを考えましょう。データが正しくなければ、そのデータを用いた処理も正しくはないでしょう。
データは処理とは違い、呼ぶ呼ばれるの関係にありません。そのため、常に成り立つ1つの条件を考えれば良いでしょう。このような、データが常に満たすべき条件を**不変条件**と呼びます。例えば、自然数の不変条件は「0以上」です\*2。
ここで、「成功」と「失敗」をより形式的に定義することができます。成功とは「関係データの不変条件が常に成り立ち、事前条件が成り立ち、処理が呼ばれ、事後条件が成り立つ」場合を指します。失敗とは「関係データの不変条件がいずれかの時点で成り立たない、又は事前条件が成り立たない、又は処理呼び出し後の事後条件が成り立たない」場合を指します。つまり、正しさの条件が成り立てば成功。成り立たなければ失敗です。

### 例：スタック
例としてスタックの正しさについて考えてみましょう。スタックを実装する言語は何でもいいのですが、ここではRubyで書いてみましょう。

```stack.rb
class Stack &lt; Struct.new(:arr)
  def push(value)
    arr &lt;&lt; value
  end

  def pop()
    arr.slice! -1
  end
end
```

さて、考えるべきは`Stack`クラスの不変条件と、`push`と`pop`の事前条件と事後条件です\*3。

最初に`Stack`クラスの不変条件です。これは`arr`アクセサが`Array`相当、つまり`&lt;&lt;`又は`slice!`メソッドを持つことです。厳密には`arr.&lt;&lt;`や`arr.slice!`の操作についても規定すべきですが、Ruby文化とも合いませんのでここでは省略します。`Stack`クラスの不変条件は`arr.respond_to? &#39;&lt;&lt;&#39; and arr.respond_to? &#39;slice!&#39;`です。

次に`push`メソッドの事前条件を考えてみましょう。しかし、`push`メソッドは特に前提となる条件がありません。値を終端に追加するだけですので、当然です。つまり、事前条件がありません。言い換えれば、常に事前条件は満たされます。よって、`push`メソッドの事前条件は`true`です。
`push`メソッドの事後条件は、`arr`の終端に`value`を追加したことです。これを論理式で直接表現する事は出来ません。何故なら、追加された事を確かめるには処理が呼び出される前の`arr`と比較する必要があるからです。そこで、事後条件でのみ、処理が呼び出される前の値にアクセスできるよう`old(expr)`という構文を導入しましょう。そうすると、事後条件は`arr.length - old(arr).length == 1 and arr.last == value`と書けます。

そして`pop`メソッドの事前条件ですが、これは厄介です。`arr`が空配列の場合はどうでしょう。「空のスタックからpopする」という行為はどのような意味があるのでしょうか。**ひとまずここでは空スタックのpopを正しくないと仮定します**。そうすると、事前条件全体は`arr.length != 0`と書くことができます。
最後に`pop`メソッドの事後条件ですが、呼び出される前の`arr`の終端から値を取り出して返しているかどうかです。しかし、これも直接論理式で表現できません。何故なら、処理が返した値を参照できないからです。そのため、処理が返した戻り値を`result()`でアクセスできるよう拡張しましょう。そうすると、事後条件は`old(arr).length - arr.length == 1 and result() == old(arr).last`と書けます。

以上をコメントとして記述してみましょう。

```stack.rb
# 不変条件: arr.respond_to? &#39;&lt;&lt;&#39; and arr.respond_to? &#39;slice!&#39;
class Stack &lt; Struct.new(:arr)
  # 事前条件: true
  # 事後条件: arr.length - old(arr).length == 1 and arr.last == value
  def push(value)
    arr &lt;&lt; value
  end

  # 事前条件: arr.length != 0
  # 事後条件: old(arr).length - arr.length == 1 and result() == old(arr).last
  def pop()
    arr.slice! -1
  end
end
```

## 失敗の原因
事前条件、事後条件、そして不変条件を考えると、処理が失敗する可能性としては
1. 事前条件が成り立たない
2. 事後条件が成り立たない
3. 不変条件が成り立たない
の3通りの組み合わせであることがわかります。ここでは各々の条件が独立に成り立たない場合について詳しく分析してみましょう。各々の条件の失敗の組み合わせを考える必要はありません。何故なら、これら3つの条件の内、どれか1つの条件でも成り立たなければ処理の失敗が決まるからです。

### 事前条件が成り立たない
事前条件が成り立たない場合、処理は失敗します。もし事前条件が表明されていた場合、その処理が失敗するかどうかは処理の呼び出し側から確認できます。事前条件を満たすように呼び出せば成功、そうでなければ失敗です。
だとすれば事前条件を満たすべき責任とは処理の呼び出し側にあるのでしょうか。より端的に言えば、事前条件が偽となる失敗が起きたとすれば、呼び出し側が悪いのでしょうか。
これが成り立つにはある条件が必要です。それは「事前条件で呼び出された全ての処理が呼び出し側から呼び出せること」です。例えば先程のスタックプログラムを考えてみましょう。`pop`メソッドの事前条件は`arr.length != 0`です。しかし、`Stack`の呼び出し側からは`arr.length`が呼び出せないため、呼び出し側は`Stack`の`pop`メソッドを適切に呼び出す事ができません。
では`arr.length == 0`を返す`empty?`メソッドを`Stack`クラスに定義したとします。この場合、`pop`メソッドの呼び出し側は`empty?`メソッドを調べることで**安全に**`pop`メソッドを呼び出すことができます。
`Stack`クラスはこれで呼び出し側にとってもフェアな実装となりました。`empty?`メソッドは実装が簡潔なので事前、事後条件は省略しています。

```stack.rb
# 不変条件: arr.respond_to? &#39;&lt;&lt;&#39; and arr.respond_to? &#39;slice!&#39;
class Stack &lt; Struct.new(:arr)
  def empty?
    arr.length == 0
  end

  # 事前条件: true
  # 事後条件: arr.length - old(arr).length == 1 and arr.last == value
  def push(value)
    arr &lt;&lt; value
  end

  # 事前条件: not empty?
  # 事後条件: old(arr).length - arr.length == 1 and result() == old(arr).last
  def pop()
    arr.slice! -1
  end
end
```
まとめましょう。事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合、事前条件が成り立たない責任は処理の呼び出し側にあります。何故なら、呼び出し側は合法的に事前条件の合否を判断できる手段を有していたにも関わらず、それを怠ったためです。さらに言えば、事前条件が満たせない場合、呼び出し側には回避手段がありますが実装側にはどうしようもありません。
事前条件が成り立つ時、処理は正しく呼ばれていることが保証されます。

### 事後条件が成り立たない
事後条件が成り立たない場合も、処理は失敗します。これはどちらが悪いのでしょう。実装側でしょうか？それとも呼び出し側でしょうか？
事前条件の時は呼び出し側に責任がありました。しかし、「事前条件で呼び出された全ての処理が呼び出し側から呼び出せること」という実装側の責任を果たした上での呼び出し側の責任です。これは、事前条件は引数等呼び出し側がコントロール可能なものを対象としているためです。では、事後条件は何を対象に扱っているかというと、主にその処理の結果です。これは呼び出し側にはどうすることもありません。
事後条件が成り立たない責任は実装側にあります。何故なら、実装側は事後条件を満たすような処理が実装できると表明しているにも関わらず、それを怠ったためです。さらに言えば、呼び出し側には事後条件を正しく満たすような努力の余地がありません。
事後条件が成り立つ時、処理は正しく実装されていることが保証されます。

### 不変条件が成り立たない
不変条件が成り立たない場合も、処理は失敗します。ここで、不変条件が呼び出し側の責任だと仮定してみましょう。であれば、データは外部から不変条件を満たしたり破壊したりすることができます。これは好ましくありません。**カプセル化**とは、不変条件を満たすようなデータの抽象化だと考えることができます。もし適切にカプセル化されているのであれば、呼び出し側からデータの不変条件に手を加えられるべき道理はありません。
不変条件が成り立たない責任は実装側にあります。ここでいう実装側とは、データとそれに関係する処理全ての実装を行ったものを指します。例えばオブジェクト指向プログラミングでは両者は不可分なものとして一体化され、「オブジェクト」と呼ばれます\*4。つまり、不変条件はオブジェクトが適切に実装されている限りにおいて、**常に**満たされます。
不変条件が成り立つ時、オブジェクトは正しく実装されていることが保証されます。

## 契約による設計
今まで、「実装側」と「呼び出し側」という2人のプログラマを登場させました。そして、あるプログラムの失敗を3通りに分け、各々の場合で**どちらが悪いのか**について議論しました。Bertrand Meyer氏は正しさの条件が2者間の**契約**とみなせることに気づきました。契約、つまり呼び出し側の負うべき義務とそれによる権利、実装側の負うべき義務とそれによる権利を正しさの条件から説明できると考えたのです。
以下に3つの条件を契約とみなした時の呼び出し側と実装側の義務と権利についてまとめてみました。とは言え不変条件は登場しません。不変条件は特定処理の呼び出しに関せず常に成り立つべき正しさだからです。

|   当事者  |                       義務                       |                権利(≒利益)             |
|:---------:|:------------------------------------------------|:---------------------------------------|
| 呼び出し側 |       処理を適切に呼び出す(事前条件を満たす)       |   処理が成功する(事後条件が満たされる)    |
|   実装側  | 処理やオブジェクトを適切に実装する(事後条件を満たす) | 処理が適切に呼ばれる(事前条件が満たされる) |

この考えに則った設計手法を**契約による設計**(DbC: Design by Contract)と呼びます。ここでは例外についてのみ考えるため、設計手法としての契約による設計は扱いません。

### 空スタックのpopは正しくないのか？
`Stack`クラスの例では`pop`メソッドの事前条件を`not empty?`と**決めました**。しかし、Rubyの`Array`クラスの`pop`メソッドは、配列が空の場合`nil`を返します。もっと言えば、現在の実装`arr.alice! -1`は`arr`が空の時`nil`を返します。これはどちらが正しいのでしょうか？
答えは、場合による、です。「正しさの条件」とは言い換えれば「正しさの定義」です。つまり、ここで述べた3つの条件による「正しさ」とは「仕様」のことです。空スタックの`pop`を正しいとして`nil`を返しても良いですし、正しくないとして失敗させても良いです。どのような仕様にするかは要求を鑑みてプログラマが自分で判断する必要があるというだけの話です。契約のメタファーを借りれば、プログラマは要求に合うようにプログラムの正しさを定義する権利があります。もちろん、プログラムを定義した正しさを満たすよう適切に実装する義務の上での権利です。

## 契約が破られるとき
契約という概念を考えた時、失敗を以下のように再定義できます。

&gt; ルーチンが契約を満たす状態で実行を終えた場合、そのルーチンコールは成功である。成功しなければ失敗である。 [1]

そして、契約と失敗から例外を再定義できます。

&gt; ルーチンの失敗によって、そのルーチンの呼び出し側に例外が発生する。 [1]

前日に述べたように、例外は回復するか通知するかのどちらかです。

&gt; ルーチンの実行中に例外が起き、ルーチンがその例外から回復しない場合に限り、そのルーチンコールは失敗となる。 [1]

例外から回復とは、その処理の契約を満たすように出来るかということです。回復できれば成功です。できなければ失敗なので、処理の呼び出し元へ例外が投げられます。
Meyer氏は個々の契約の違反は本質的な問題では無いと考えました。つまり、彼の言葉を借りれば「戦闘の1つには負けても戦争そのものに負けたわけではない」のです。ある処理の契約違反を別の処理が尻拭いしてくれれば、それで良いというわけです。
この関係を図にまとめてみました。例外が契約の観点から見事に説明できています。

![例外と失敗.png](https://qiita-image-store.s3.amazonaws.com/0/3206/1b56a9ff-821a-a7a1-4547-6883e9613fdb.png)

### 責任不在の失敗
*以下の文は筆者による私見です。Meyer氏は『オブジェクト指向入門』ではIO操作に対する契約について言及していません。*

最後に、契約の概念の限界性について述べます。契約の考えに則れば、あらゆる失敗は処理の呼び出し側もしくは処理の実装側の責任でした。責任がどちらか一方に定まるという性質が契約の大原則でした。
ここで、受け取ったパスからファイルの内容を読み取る`file_read`関数を考えてみましょう。そして、その`file_read`関数の事前条件を考えます。どのような事前条件が書けるでしょう。
`file_read`はファイルパスを受け取るので、その受け取ったファイルパスにファイルが存在するかどうかというものを事前条件として考えられそうです。ひとまず`is_exist`関数の存在を仮定すれば、`file_read`関数は以下のようになります。

```file_read.rb
# 事前条件: is_exist(path)
def file_read(path)
  ...
end
```

つまり、`file_read`関数は、受け取ったパスにファイルが存在している場合は**常に**成功します。そう、こんなことはありえません。我々はどこで道を間違えたのでしょうか。

全ての処理は大きく2種類に分けることができます。契約を満たせば必ず成功するもの。そして、契約を満たしていてもときおり失敗するものです。これは信頼性の問題です。厳密に言えば全ての処理は後者です。つまり、全ての処理は契約を満たしていても常に成功するとは限りません。
整数同士を足し合わせる`add`関数があるとします。これは整数を受け取る限り、常に成功しそうです。しかし、実際の処理を行うCPUが壊れていれば失敗します。要件にもよりますが、大抵の場合はCPUの誤作動は想定しません。これも正しさ条件の1つです。プログラム全体の事前条件として、CPUは正しく動くという暗黙の条件があるのです。
ではファイルAPIはどうでしょう。同じことで、HDDが不調かもしれません。OSの割り込みによるタイミングの問題で失敗するかもしれません。ファイル操作はCPUよりも不安定なので、大抵の場合はプログラム全体の事前条件として受け入れることはできません。ファイル、DB、HTTP通信等は一般に信頼性が低く、事前条件を満たしても成功するとは限りません。

ここで、無理やり契約の考えを貫いてみましょう。`file_read`関数を適切に呼び出した場合、つまり事前条件をみたすように呼び出した場合、呼び出し側の義務は終了です。では、その上で`file_read`関数が失敗すれば実装側の問題なのでしょうか。しかし、契約とは正しさです。正しくない動作とは、つまるところバグです。

&gt; 事前条件違反は顧客側(筆者注：この記事で言う呼び出し側)にバグがある証拠である。
&gt; 事後条件違反は供給者側(筆者注：この記事で言う実装側)にバグがある証拠である。 [1]

では、`file_read`関数の失敗は実装者によるバグなのでしょうか。仮にバグだとしてもどうしようもありません。何故ならそのバグは取り除けないからです。どのように慎重に実装を行ったとしても、`file_read`関数の信頼性を他の処理、例えばスタック操作と同程度にまで引き上げるのは困難です。
`file_read`関数の存在、もっと一般に、IO操作は契約の概念が適用できません。何故なら、契約を満たしても失敗する可能性があるからです。そして、その失敗は誰の責任でもありません。ただ、運が悪かっただけです。もう一度試してみれば上手くいくかもしれません。

## 注釈
\*1: この3組、及び3組を用いたプログラムの正しさについての研究をTony Hoarが行ったことから、3組を**ホーア・トリプル**と呼ばれ、以下のように書き表します。

```
{P} C {Q}
```

Pはprecondition、Qはpostcondition、Cはcommandの意味です。
また、単純なホーア・トリプルではプログラムCの正しさを完全に表現することはできません。何故なら、Cが停止しない可能性があるためです。そのため、単純なホーア・トリプルはプログラムの部分的な正しさしか表現できません。
PやQの停止性については、ここでは考えません。

\*2: ここでは自然数を0以上の整数としています。

\*3: ここではいくつかの条件を省略しています。本来は`{P} C {Q}`において`C`に副作用を認める限り、`P`, `Q`はプログラム上のあらゆる作用を記述する必要があります。また、`P`や`Q`の内部で別の処理を呼び出す事の正しさについてもここでは無視しています。しかし、この記事の本質はプログラムの正しさを検討することではありません。ここでの正しさは例外を考える程度のものでよいので、厳密な意味での正しさは扱いません。

\*4: Meyer氏は著書『オブジェクト指向入門』にて契約による設計を提唱しました。そのため、彼の説明はオブジェクト指向プログラミングに依存しています。しかし、現代的なプログラミング言語であればデータに対する何らかの抽象化機構が提供されているはずです。例えばMLに由来する多くの関数型言語はモジュールによってデータと操作の一体化が可能です。ここで言うオブジェクトとは抽象データ型(ADT: Abstract Data Type)を実現する1手法程度の意味に過ぎません。

## 参考文献
[1]: 『オブジェクト指向入門 第2版 原則・コンセプト』 Bertrand Meyre, 翔泳社 2007
</textarea><input type="submit" name="commit" value="Save changes" data-disable-with="Save changes" /></form></div></section></div><div class="col-sm-3"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="契約による設計から見た例外 by @Kokudori on @Qiita" data-url="http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="契約による設計から見た例外" href="http://b.hatena.ne.jp/entry/http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div><section class="itemsShowAuthorInfo" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><a href="/Kokudori"><img alt="" class="itemsShowAuthorInfo_userIcon" itemprop="image" src="https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775" /></a><div class="itemsShowAuthorInfo_profileStats"><strong class="itemsShowAuthorInfo_userName" itemprop="name"><a itemprop="url" href="/Kokudori">Kokudori</a></strong><div class="itemsShowAuthorInfo_contribution"><span class="itemsShowAuthorInfo_count">1843</span><span class="itemsShowAuthorInfo_unit">Contribution</span></div><div data-react-class="T.UserFollowButton" data-react-props="{&quot;url_name&quot;:&quot;Kokudori&quot;,&quot;initial_followed_by&quot;:false,&quot;size&quot;:&quot;btn-xs&quot;,&quot;position&quot;:&quot;author-info&quot;}"></div></div><section class="itemsShowAuthorPopularItems"><h5 class="itemsShowAuthorPopularItems_sectionTitle">人気の投稿</h5><ul class="itemsShowAuthorPopularItems_posts list-unstyled"><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/Kokudori/items/3a953c00012408f76ab9">例外入門以前</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/Kokudori/items/2b36068cdf2e40e75c2d">ググるよりもまずはpry</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/Kokudori/items/ab5fcac4b31d7290e630">Livetで始めるWPF(ざっくり)入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/Kokudori/items/2e4bd32abf7abea3186f">契約による設計から見た例外</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/Kokudori/items/987073d59529b6c9a37c">例外安全と例外中立</a></li></ul></section></section><div class="scroll-chaser"><div class="google-adsense"><style>.test-text-responsible { width: 200px; height: 200px; }@media(min-width: 1200px) {  .test-text-responsible { width: 250px; height: 250px; }}@media(max-width: 979px) and (min-width: 768px) {  .test-text-responsible { width: 120px; height: 240px; }}@media(max-width: 767px) {  .test-text-responsible { width: 320px; height: 50px; }}</style><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle test-text-responsible" data-ad-client="ca-pub-8127218772604357" data-ad-slot="3880091879" style="display:inline-block"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div><div data-react-class="T.Toc" data-react-props="{&quot;body&quot;:&quot;\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%AD%A3%E3%81%97%E3%81%95\&quot;\u003eプログラムの正しさ\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BE%8B%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF\&quot;\u003e例：スタック\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A4%B1%E6%95%97%E3%81%AE%E5%8E%9F%E5%9B%A0\&quot;\u003e失敗の原因\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BA%8B%E5%89%8D%E6%9D%A1%E4%BB%B6%E3%81%8C%E6%88%90%E3%82%8A%E7%AB%8B%E3%81%9F%E3%81%AA%E3%81%84\&quot;\u003e事前条件が成り立たない\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BA%8B%E5%BE%8C%E6%9D%A1%E4%BB%B6%E3%81%8C%E6%88%90%E3%82%8A%E7%AB%8B%E3%81%9F%E3%81%AA%E3%81%84\&quot;\u003e事後条件が成り立たない\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6%E3%81%8C%E6%88%90%E3%82%8A%E7%AB%8B%E3%81%9F%E3%81%AA%E3%81%84\&quot;\u003e不変条件が成り立たない\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A5%91%E7%B4%84%E3%81%AB%E3%82%88%E3%82%8B%E8%A8%AD%E8%A8%88\&quot;\u003e契約による設計\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%A9%BA%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%81%AEpop%E3%81%AF%E6%AD%A3%E3%81%97%E3%81%8F%E3%81%AA%E3%81%84%E3%81%AE%E3%81%8B\&quot;\u003e空スタックのpopは正しくないのか？\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A5%91%E7%B4%84%E3%81%8C%E7%A0%B4%E3%82%89%E3%82%8C%E3%82%8B%E3%81%A8%E3%81%8D\&quot;\u003e契約が破られるとき\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%B2%AC%E4%BB%BB%E4%B8%8D%E5%9C%A8%E3%81%AE%E5%A4%B1%E6%95%97\&quot;\u003e責任不在の失敗\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%B3%A8%E9%87%88\&quot;\u003e注釈\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\&quot;\u003e参考文献\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n&quot;,&quot;wrapper&quot;:&quot;#article-body-wrapper&quot;}"></div></div></div><div class="row"><div class="col-sm-9"><div class="ArticleFooter__menu"><div class="s-flex-align-center"><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:173,&quot;show_count&quot;:true,&quot;uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-footer&quot;}"></div><div class="ArticleFooter__userList"><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="magicant"><a itemprop="url" href="/magicant"><img alt="magicant" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="bells17"><a itemprop="url" href="/bells17"><img alt="bells17" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/13148/profile-images/1473682696" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="funnything"><a itemprop="url" href="/funnything"><img alt="funnything" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/12653/profile-images/1473682479" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="cigalecigales"><a itemprop="url" href="/cigalecigales"><img alt="cigalecigales" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/48912/profile-images/1473691524" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="matsu_chara"><a itemprop="url" href="/matsu_chara"><img alt="matsu_chara" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/14260/profile-images/1473683255" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="daneko0123"><a itemprop="url" href="/daneko0123"><img alt="daneko0123" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/1221/profile-images/1473683109" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="sisidovski"><a itemprop="url" href="/sisidovski"><img alt="sisidovski" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/6436/profile-images/1473682868" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="yuba"><a itemprop="url" href="/yuba"><img alt="yuba" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/2852/profile-images/1473682178" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="yuukigoodman"><a itemprop="url" href="/yuukigoodman"><img alt="yuukigoodman" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/11737/profile-images/1473682135" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="hirofummy"><a itemprop="url" href="/hirofummy"><img alt="hirofummy" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/6419/profile-images/1473682860" /></a></div></div><div class="ArticleFooter__user"><a href="/Kokudori/items/2e4bd32abf7abea3186f/likers"><span class="fa fa-ellipsis-h"></span></a></div></div></div><div class="u-flex u-align-center"><div class="ArticleFooter__stock"><div class="js-stockbutton" data-position="footer_menu" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="ArticleFooter__editRequest"><a class="u-link-no-underline" data-toggle="tooltip" title="You can propose improvements about the article to the author 💪" href="/drafts/2e4bd32abf7abea3186f/edit"><span class="fa fa-send-o fa-lg"></span> <span>Edit request</span></a></div><div class="dropdown ArticleFooter__dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h"></span></a><ul class="dropdown-menu dropdown-menu-right"><li><a href="/Kokudori/items/2e4bd32abf7abea3186f.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><i class="fa fa-fw fa-flag"></i> Report article</a></li></ul></div></div></div><div class="itemsShowBody_adventCalendar"><div class="itemsShowBody_adventCalendar_header"><i class="fa fa-fw fa-calendar"></i> This post is the <span class="date">No.3</span> article of <a class="title" href="/advent-calendar/2014/exception">例外 Advent Calendar 2014</a></div><ul class="itemsShowBody_adventCalendar_nav list-unstyled"><li class="itemsShowBody_adventCalendar_neighborItem itemsShowBody_adventCalendar_neighborItem-prev"><span class="itemsShowBody_adventCalendar_date"><i class="fa fa-fw fa-arrow-circle-left"></i> Day 2:</span><span class="itemsShowBody_adventCalendar_title"><img alt="Kokudori" class="itemsShowBody_adventCalendar_icon" src="https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775" width="18" height="18" /> <a class="itemsShowBody_adventCalendar_link" href="/Kokudori/items/987073d59529b6c9a37c">例外安全と例外中立</a></span></li><li class="itemsShowBody_adventCalendar_neighborItem itemsShowBody_adventCalendar_neighborItem-next"><span class="itemsShowBody_adventCalendar_date"><i class="fa fa-fw fa-arrow-circle-right"></i> Day 4:</span><span class="itemsShowBody_adventCalendar_title"><img alt="Kokudori" class="itemsShowBody_adventCalendar_icon" src="https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775" width="18" height="18" /> <a class="itemsShowBody_adventCalendar_link" href="/Kokudori/items/30ef407e9ee135cb73f6">例外大統一理論</a></span></li></ul></div><ul class="references js-referencesView"><li class="references_header"><i class="fa fa-fw fa-link"></i> Linked from these articles</li><li class="references_reference js-reference"><span>Linked from </span><a href="/Kokudori/items/3a953c00012408f76ab9#_reference-7082b01281c6753c4210"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775" />例外入門以前</a><time class="references_datetime js-dateTimeView" datetime="2014-12-06T06:34:03+00:00">about 2 years ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/yuya_presto/items/3b651d6b0cf38f77e933#_reference-028215055cadb9d3fdd8"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/4153/profile-images/1473683814" />Java/Androidにおける例外設計、あるいは「契約による設計」によるシンプルさの追求</a><time class="references_datetime js-dateTimeView" datetime="2016-03-06T11:09:39+00:00">12 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/draftcode/items/d9c1aa0ef63b100923dd#_reference-1cfb0a92092b434601ca"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/18199/profile-images/1473682366" />再度、契約による設計と例外について</a><time class="references_datetime js-dateTimeView" datetime="2016-09-06T05:05:46+00:00">6 months ago</time></li></ul><div class="itemsShowBody_articleColumnFooter"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="契約による設計から見た例外 by @Kokudori on @Qiita" data-url="http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="契約による設計から見た例外" href="http://b.hatena.ne.jp/entry/http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div></div><div class="itemsShowComment_wrapper" id="comments"><div data-react-class="T.CommentListContainer" data-react-props="{&quot;currentUser&quot;:null,&quot;initialComments&quot;:[{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cblockquote\u003e\n\u003cp\u003efile_read関数の存在、もっと一般に、IO操作は契約の概念が適用できません\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ccode\u003efile_read\u003c/code\u003eを「指定されたパスの内容を読もうと試み、成功した場合はその内容を、失敗した場合は\u003ccode\u003enil\u003c/code\u003eを返す処理」と定義すれば、「\u003ccode\u003efile_read\u003c/code\u003eは常に成功する」と言えるのではないでしょうか?\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T16:45:06+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:125961,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;\u003e file_read関数の存在、もっと一般に、IO操作は契約の概念が適用できません\n\n`file_read`を「指定されたパスの内容を読もうと試み、成功した場合はその内容を、失敗した場合は`nil`を返す処理」と定義すれば、「`file_read`は常に成功する」と言えるのではないでしょうか?\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-aa4af02f7f64b2225296&quot;,&quot;user&quot;:{&quot;contribution&quot;:0,&quot;created_at&quot;:&quot;2013-04-26T10:27:20+09:00&quot;,&quot;id&quot;:20549,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/20549/profile-images/1473683047&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;todesking@github&quot;},&quot;uuid&quot;:&quot;aa4af02f7f64b2225296&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cp\u003e\u003ca href=\&quot;/todesking@github\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;todesking@github\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;todesking@github\&quot;\u003e@todesking@github\u003c/a\u003e\u003cbr\u003e\n正しさをどう定義するかに依存します。\u003cbr\u003e\n極論を言えば、例外を投げることさえも契約に含めれば全ての処理は常に成功すると考える事ができます。\u003cbr\u003e\nただ、そこまで正しさを広げてしまっては、わざわざ契約を表明する意味なんてありません。\u003cbr\u003e\n契約は正しさを形式的に定義、表明できることにこそ価値があるで、\u003ccode\u003enil\u003c/code\u003eのような失敗を表現するだけの特殊な値も避けたほうが良いように思われます。\u003cbr\u003e\nただ、Meyer自身がそのような状況の正しさ、つまり失敗表現さえも処理の正しさに含めた場合の契約の意義について言及していないので、Meyerがどう考えていたのかについては不明です。\u003c/p\u003e\n\n\u003cp\u003eそして、IOに関する契約の考えが成り立たないという旨の指摘は筆者自らのものです。\u003cbr\u003e\n少なくともMeyerはIOに対する契約について『オブジェクト指向入門』の中では言及していません。\u003cbr\u003e\n明記すべきでした、すいません。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T17:45:14+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126028,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;@todesking@github\n正しさをどう定義するかに依存します。\n極論を言えば、例外を投げることさえも契約に含めれば全ての処理は常に成功すると考える事ができます。\nただ、そこまで正しさを広げてしまっては、わざわざ契約を表明する意味なんてありません。\n契約は正しさを形式的に定義、表明できることにこそ価値があるで、`nil`のような失敗を表現するだけの特殊な値も避けたほうが良いように思われます。\nただ、Meyer自身がそのような状況の正しさ、つまり失敗表現さえも処理の正しさに含めた場合の契約の意義について言及していないので、Meyerがどう考えていたのかについては不明です。\n\nそして、IOに関する契約の考えが成り立たないという旨の指摘は筆者自らのものです。\n少なくともMeyerはIOに対する契約について『オブジェクト指向入門』の中では言及していません。\n明記すべきでした、すいません。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-1c98e24edfd45575b12c&quot;,&quot;user&quot;:{&quot;contribution&quot;:1843,&quot;created_at&quot;:&quot;2012-02-09T20:19:22+09:00&quot;,&quot;id&quot;:3206,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;Kokudori&quot;},&quot;uuid&quot;:&quot;1c98e24edfd45575b12c&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cblockquote\u003e\n\u003cp\u003e事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合、事前条件が成り立たない責任は処理の呼び出し側にあります\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eこの条件は強すぎるように見えます。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eStack\u003c/code\u003eの例だと、\u003ccode\u003eempty?\u003c/code\u003eが提供されていなくても\u003ccode\u003eStack.new.pop\u003c/code\u003eの失敗はクライアントの責務とするのが自然ではないでしょうか。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T17:45:24+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126029,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;\u003e 事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合、事前条件が成り立たない責任は処理の呼び出し側にあります\n\nこの条件は強すぎるように見えます。\n\n`Stack`の例だと、`empty?`が提供されていなくても`Stack.new.pop`の失敗はクライアントの責務とするのが自然ではないでしょうか。\n\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-0bf66faaf6058766caa4&quot;,&quot;user&quot;:{&quot;contribution&quot;:0,&quot;created_at&quot;:&quot;2013-04-26T10:27:20+09:00&quot;,&quot;id&quot;:20549,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/20549/profile-images/1473683047&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;todesking@github&quot;},&quot;uuid&quot;:&quot;0bf66faaf6058766caa4&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cp\u003e\u003ccode\u003eStack\u003c/code\u003eに関するご指摘ですが、\u003ccode\u003eStack\u003c/code\u003eは十分有名であり、\u003ccode\u003epop\u003c/code\u003eの正しさがプログラマ間で十分合意が得られているので成り立つご指摘だと思います。\u003cbr\u003e\n例えばStackでの契約と責任の議論を一般化し、\u003ccode\u003eHoge.new.piyo\u003c/code\u003eの失敗をクライアントの責務とするのは、クライアントが\u003ccode\u003eHoge#piyo\u003c/code\u003eの事前条件を知っていることが前提とする方が自然かつフェアではないでしょうか。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T17:51:04+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126037,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;`Stack`に関するご指摘ですが、`Stack`は十分有名であり、`pop`の正しさがプログラマ間で十分合意が得られているので成り立つご指摘だと思います。\n例えばStackでの契約と責任の議論を一般化し、`Hoge.new.piyo`の失敗をクライアントの責務とするのは、クライアントが`Hoge#piyo`の事前条件を知っていることが前提とする方が自然かつフェアではないでしょうか。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-ac8e71f985477bfe6c4d&quot;,&quot;user&quot;:{&quot;contribution&quot;:1843,&quot;created_at&quot;:&quot;2012-02-09T20:19:22+09:00&quot;,&quot;id&quot;:3206,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;Kokudori&quot;},&quot;uuid&quot;:&quot;ac8e71f985477bfe6c4d&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eHoge.new.piyo\u003c/code\u003eの失敗をクライアントの責務とするのは、クライアントが\u003ccode\u003eHoge#piyo\u003c/code\u003eの事前条件を知っていることが前提とする方が自然かつフェアではないでしょうか。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e事前条件の中で仕様が不明なprivate APIを使っていた場合、クライアントがその条件の意味を解釈できないため正しい呼び方が分からないという意味でしょうか? それなら同意です。\u003c/p\u003e\n\n\u003cp\u003eただ、\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eというのは、必要条件としては強すぎると思います。\u003ccode\u003eStack\u003c/code\u003eの例では「\u003ccode\u003eempty?\u003c/code\u003eが成り立つ\u003ccode\u003eStack\u003c/code\u003eは\u003ccode\u003epop\u003c/code\u003eできない」「\u003ccode\u003eStack\u003c/code\u003eの初期状態は\u003ccode\u003eempty?\u003c/code\u003eが成り立つ」という条件さえクライアントが理解していれば、\u003ccode\u003eempty?\u003c/code\u003eにアクセスできなくても正しい使い方が可能なので。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T19:07:26+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126118,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;\u003e `Hoge.new.piyo`の失敗をクライアントの責務とするのは、クライアントが`Hoge#piyo`の事前条件を知っていることが前提とする方が自然かつフェアではないでしょうか。\n\n事前条件の中で仕様が不明なprivate APIを使っていた場合、クライアントがその条件の意味を解釈できないため正しい呼び方が分からないという意味でしょうか? それなら同意です。\n\nただ、\n\n\u003e 事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合\n\nというのは、必要条件としては強すぎると思います。`Stack`の例では「`empty?`が成り立つ`Stack`は`pop`できない」「`Stack`の初期状態は`empty?`が成り立つ」という条件さえクライアントが理解していれば、`empty?`にアクセスできなくても正しい使い方が可能なので。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-ee9946ad68b0a3331774&quot;,&quot;user&quot;:{&quot;contribution&quot;:0,&quot;created_at&quot;:&quot;2013-04-26T10:27:20+09:00&quot;,&quot;id&quot;:20549,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/20549/profile-images/1473683047&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;todesking@github&quot;},&quot;uuid&quot;:&quot;ee9946ad68b0a3331774&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cp\u003e\u003ca href=\&quot;/todesking@github\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;todesking@github\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;todesking@github\&quot;\u003e@todesking@github\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e事前条件の中で仕様が不明なprivate APIを使っていた場合、クライアントがその条件の意味を解釈できないため正しい呼び方が分からないという意味でしょうか?\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eそうです。事前条件は呼び出し側が満たすべき正しさですので、呼び出し側から見える必要があります。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eStackの例では「empty?が成り立つStackはpopできない」「Stackの初期状態はempty?が成り立つ」という条件さえクライアントが理解していれば、empty?にアクセスできなくても正しい使い方が可能なので。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eなるほど、いくつかのケースでは「事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合」という条件は必ずしも必要ないというご指摘ですね。\u003cbr\u003e\n私は契約を一般的なケースで考えていました。確かに、いくつかのケースではこの条件は強すぎます。\u003cbr\u003e\nしかし、そのように考えるメリットは特にありません。契約をより一般化して捉えなければ、一般的な処理の呼び出しを考えられないからです。\u003c/p\u003e\n\n\u003cp\u003eうーん、「契約の実際的な利益のためここではいくつかの特別なケースを考えず、より一般的な意味での処理の呼び出しにおける各々の責任の関係を見ます」と言った一言があれば良かったのでしょうか…。\u003cbr\u003e\nご意見ありがとうございます。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T19:29:53+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126151,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;@todesking@github\n\u003e 事前条件の中で仕様が不明なprivate APIを使っていた場合、クライアントがその条件の意味を解釈できないため正しい呼び方が分からないという意味でしょうか?\n\nそうです。事前条件は呼び出し側が満たすべき正しさですので、呼び出し側から見える必要があります。\n\n\u003e Stackの例では「empty?が成り立つStackはpopできない」「Stackの初期状態はempty?が成り立つ」という条件さえクライアントが理解していれば、empty?にアクセスできなくても正しい使い方が可能なので。\n\nなるほど、いくつかのケースでは「事前条件で呼び出された全ての処理が呼び出し側から呼び出せる場合」という条件は必ずしも必要ないというご指摘ですね。\n私は契約を一般的なケースで考えていました。確かに、いくつかのケースではこの条件は強すぎます。\nしかし、そのように考えるメリットは特にありません。契約をより一般化して捉えなければ、一般的な処理の呼び出しを考えられないからです。\n\nうーん、「契約の実際的な利益のためここではいくつかの特別なケースを考えず、より一般的な意味での処理の呼び出しにおける各々の責任の関係を見ます」と言った一言があれば良かったのでしょうか…。\nご意見ありがとうございます。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-b2669fd6a24148c6c89f&quot;,&quot;user&quot;:{&quot;contribution&quot;:1843,&quot;created_at&quot;:&quot;2012-02-09T20:19:22+09:00&quot;,&quot;id&quot;:3206,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;Kokudori&quot;},&quot;uuid&quot;:&quot;b2669fd6a24148c6c89f&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cblockquote\u003e\n\u003cp\u003e極論を言えば、例外を投げることさえも契約に含めれば全ての処理は常に成功すると考える事ができます。\u003cbr\u003e\nただ、そこまで正しさを広げてしまっては、わざわざ契約を表明する意味なんてありません。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eそこはむしろエラー時に例外が投げられることや nil が返されることを事後条件の一部と見做してしまった方が、クライアントが行う例外回復の妥当性を検証する上で都合が良いでしょう。クライアントが例外回復を実装するためには、どういう条件の時にどういう例外やエラー値が返されるのかがクライアントに対して表明されていなければなりませんから。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T22:54:12+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126261,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;\u003e 極論を言えば、例外を投げることさえも契約に含めれば全ての処理は常に成功すると考える事ができます。\nただ、そこまで正しさを広げてしまっては、わざわざ契約を表明する意味なんてありません。\n\nそこはむしろエラー時に例外が投げられることや nil が返されることを事後条件の一部と見做してしまった方が、クライアントが行う例外回復の妥当性を検証する上で都合が良いでしょう。クライアントが例外回復を実装するためには、どういう条件の時にどういう例外やエラー値が返されるのかがクライアントに対して表明されていなければなりませんから。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-93cf0430365bc3b6503b&quot;,&quot;user&quot;:{&quot;contribution&quot;:5305,&quot;created_at&quot;:&quot;2014-02-23T13:59:58+09:00&quot;,&quot;id&quot;:38244,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;magicant&quot;},&quot;uuid&quot;:&quot;93cf0430365bc3b6503b&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cp\u003e\u003ca href=\&quot;/magicant\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;magicant\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;magicant\&quot;\u003e@magicant\u003c/a\u003e\u003cbr\u003e\nそのアイデアの有効性はともかくとして、契約の考えとしてマッチするかどうかを考えると、妥当ではないのではないと思います。\u003cbr\u003e\nこの記事では触れていませんがMeyerは契約(表明)をオプショナルなものとして考えており、必要なら実行時検査を切っても良いとしています。\u003cbr\u003e\nなので、契約が例外を直接扱うことを少なくともMeyerは意図していないと思います。\u003c/p\u003e\n\n\u003chr\u003e\n\n\u003cp\u003e以下、契約と例外に関する愚痴です。\u003cbr\u003e\nMeyerは契約を正しい、満たして当然のものだと主張しています。\u003cbr\u003e\nなので、契約違反はバグだと著書の中ではっきり書いてあります。\u003cbr\u003e\nなのであれば例外とはなんぞやという話になりまして…。\u003cbr\u003e\n特に契約が例外回復を見越して例外が投げられることまで扱ってしまうと、よくわからなくなります。\u003cbr\u003e\n正直バグなら直せば良いじゃないかという気分になりますし、このバグを踏んだらこういう例外を投げますという表明は何なのかという感じです。\u003cbr\u003e\nこの記事でも触れていますが、IO等の契約を守っても発生する失敗(誰に責任を求められない失敗)は契約の考えと矛盾すると思います。\u003cbr\u003e\nMeyerがこのことを想定しなかったとは思えないのですが、どうなんでしょう。『オブジェクト指向入門』以外の彼の契約に関する書籍を読んだことがないので正直良くわかりません。\u003cbr\u003e\n私にはMeyerが例外を処理の仕様として捉えていなかったようにも見えます。それはpureな処理においては成り立つ前提だと思います。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T23:10:10+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126272,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;@magicant\nそのアイデアの有効性はともかくとして、契約の考えとしてマッチするかどうかを考えると、妥当ではないのではないと思います。\nこの記事では触れていませんがMeyerは契約(表明)をオプショナルなものとして考えており、必要なら実行時検査を切っても良いとしています。\nなので、契約が例外を直接扱うことを少なくともMeyerは意図していないと思います。\n\n---\n\n以下、契約と例外に関する愚痴です。\nMeyerは契約を正しい、満たして当然のものだと主張しています。\nなので、契約違反はバグだと著書の中ではっきり書いてあります。\nなのであれば例外とはなんぞやという話になりまして…。\n特に契約が例外回復を見越して例外が投げられることまで扱ってしまうと、よくわからなくなります。\n正直バグなら直せば良いじゃないかという気分になりますし、このバグを踏んだらこういう例外を投げますという表明は何なのかという感じです。\nこの記事でも触れていますが、IO等の契約を守っても発生する失敗(誰に責任を求められない失敗)は契約の考えと矛盾すると思います。\nMeyerがこのことを想定しなかったとは思えないのですが、どうなんでしょう。『オブジェクト指向入門』以外の彼の契約に関する書籍を読んだことがないので正直良くわかりません。\n私にはMeyerが例外を処理の仕様として捉えていなかったようにも見えます。それはpureな処理においては成り立つ前提だと思います。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-dc8521ab4122ec1d40d3&quot;,&quot;user&quot;:{&quot;contribution&quot;:1843,&quot;created_at&quot;:&quot;2012-02-09T20:19:22+09:00&quot;,&quot;id&quot;:3206,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;Kokudori&quot;},&quot;uuid&quot;:&quot;dc8521ab4122ec1d40d3&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cblockquote\u003e\n\u003cp\u003eMeyerは契約(表明)をオプショナルなものとして考えており、必要なら実行時検査を切っても良いとしています。\u003cbr\u003e\nなので、契約が例外を直接扱うことを少なくともMeyerは意図していないと思います。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eMeyer さんの考えがそうだった(らしい)ということはわかりますが、契約(表明)を assert 文を書くための道具としか看做さないのはとても惜しい考えだと思います。\u003cbr\u003e\n元来、ホーア論理やら公理的意味論やらといった概念はプログラムの正しさの静的な (=プログラムを実行する前の段階での) 論理的検証のために考えられたものです。\u003c/p\u003e\n\n\u003cp\u003e関数の戻り値だけに注目して、例外を文字通り例外扱いするだけでは、話はただそこで終ってしまいます。\u003cbr\u003e\nしかし、例外とか型とかいった上位概念をチューリングマシンとかラムダ計算のような基本的体系に落とし込んでいくと、関数が return 文で返るのか throw 文で返るのかという区別だってほとんど意味の無いものだということが明らかになります。例外をいかに論理的考察の対象とするかを突き詰めていくと、もっと話が膨らむと思いますよ。\u003cbr\u003e\n例外回復の処理が正しいか検証する話もそうですし、検査例外も例外に関する事後条件の静的検査に過ぎないという話ができます。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-05T23:55:59+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126292,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;\u003e Meyerは契約(表明)をオプショナルなものとして考えており、必要なら実行時検査を切っても良いとしています。\nなので、契約が例外を直接扱うことを少なくともMeyerは意図していないと思います。\n\nMeyer さんの考えがそうだった(らしい)ということはわかりますが、契約(表明)を assert 文を書くための道具としか看做さないのはとても惜しい考えだと思います。\n元来、ホーア論理やら公理的意味論やらといった概念はプログラムの正しさの静的な (=プログラムを実行する前の段階での) 論理的検証のために考えられたものです。\n\n関数の戻り値だけに注目して、例外を文字通り例外扱いするだけでは、話はただそこで終ってしまいます。\nしかし、例外とか型とかいった上位概念をチューリングマシンとかラムダ計算のような基本的体系に落とし込んでいくと、関数が return 文で返るのか throw 文で返るのかという区別だってほとんど意味の無いものだということが明らかになります。例外をいかに論理的考察の対象とするかを突き詰めていくと、もっと話が膨らむと思いますよ。\n例外回復の処理が正しいか検証する話もそうですし、検査例外も例外に関する事後条件の静的検査に過ぎないという話ができます。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-b093a4528caac6323563&quot;,&quot;user&quot;:{&quot;contribution&quot;:5305,&quot;created_at&quot;:&quot;2014-02-23T13:59:58+09:00&quot;,&quot;id&quot;:38244,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;magicant&quot;},&quot;uuid&quot;:&quot;b093a4528caac6323563&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cblockquote\u003e\n\u003cp\u003eMeyerは契約を正しい、満たして当然のものだと主張しています。\u003cbr\u003e\nなので、契約違反はバグだと著書の中ではっきり書いてあります。\u003cbr\u003e\nなのであれば例外とはなんぞやという話になりまして…。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eファイルの存在性を前提条件とする例があまり良くないので、別の例を考えましょうか。 C 言語の fread 関数は、引数が NULL ポインタでないことを前提条件として要求します。もし NULL ポインタを渡した場合、動作は未定義です。つまり何が起こるか分かりません。プログラムがクラッシュするのかもしれないし、例外が投げられるのかもしれないし、あるいは成功したかのように何らかのデータが返ってくるのかもしれないし、もしかしたら一部の人が揶揄するように鼻から悪魔が飛び出してくるのかもしれない。\u003c/p\u003e\n\n\u003cp\u003e何にせよ、NULL でないポインタを渡すことは呼出元の責務です。もし NULL ポインタが渡されたとしたら、それは呼出元の「バグ」です。\u003cbr\u003e\n逆に正しいポインタが渡される限り fread 関数は正しく動作し事後条件を満たします。するとそこには「例外」が発生する余地(というか可能性)はありませんね。\u003c/p\u003e\n\n\u003cp\u003eではこの場合において例外の意義は何なのか。それは、デバッグを助ける道具です。もし NULL ポインタが渡されたとして、何が起こるべきでしょうか。契約上は、上に述べたように何が起こってもおかしくはありません。でも、鼻から悪魔が飛び出してくるよりは、分かりやすいエラーメッセージが表示されたり、適切な型の例外が投げられたりする方が、デバッグしやすいでしょう。(C 言語には例外はありませんが、まあ C++ で書いているとでも思ってください)\u003c/p\u003e\n\n\u003cp\u003eただし、この例外は回復されることを前提としたものではありません。つまり、例外の発生を見越して呼出元に例外をキャッチするコードを書くのは妥当ではありません。妥当なのは、そもそも NULL ポインタを渡さないようにロジックを修正することです。だって、NULL ポインタを渡したこと自体がバグなのですから。\u003c/p\u003e\n\n\u003cp\u003eさて話を変えて、例外回復について語るなら、私や他の人が言うように、エラー時にどういう例外が投げられるのかまで契約に含めて考えないと、話が進みません。実際、C 言語の fread 関数にしろ、Java の InputStream の read メソッドにしろ、ファイルが読めなかった時にどう動作するかはマニュアルに明記されています。ファイルが読めなかったからといって動作が未定義ということにはなりません。少なくとも何らかのエラー値や例外が返ってきます。であるからこそ、呼出元でエラー値をチェックしたり例外をキャッチしたりすることに意味が出てきます。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-06T12:57:11+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126372,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;\u003e Meyerは契約を正しい、満たして当然のものだと主張しています。\n\u003e なので、契約違反はバグだと著書の中ではっきり書いてあります。\n\u003e なのであれば例外とはなんぞやという話になりまして…。\n\nファイルの存在性を前提条件とする例があまり良くないので、別の例を考えましょうか。 C 言語の fread 関数は、引数が NULL ポインタでないことを前提条件として要求します。もし NULL ポインタを渡した場合、動作は未定義です。つまり何が起こるか分かりません。プログラムがクラッシュするのかもしれないし、例外が投げられるのかもしれないし、あるいは成功したかのように何らかのデータが返ってくるのかもしれないし、もしかしたら一部の人が揶揄するように鼻から悪魔が飛び出してくるのかもしれない。\n\n何にせよ、NULL でないポインタを渡すことは呼出元の責務です。もし NULL ポインタが渡されたとしたら、それは呼出元の「バグ」です。\n逆に正しいポインタが渡される限り fread 関数は正しく動作し事後条件を満たします。するとそこには「例外」が発生する余地(というか可能性)はありませんね。\n\nではこの場合において例外の意義は何なのか。それは、デバッグを助ける道具です。もし NULL ポインタが渡されたとして、何が起こるべきでしょうか。契約上は、上に述べたように何が起こってもおかしくはありません。でも、鼻から悪魔が飛び出してくるよりは、分かりやすいエラーメッセージが表示されたり、適切な型の例外が投げられたりする方が、デバッグしやすいでしょう。(C 言語には例外はありませんが、まあ C++ で書いているとでも思ってください)\n\nただし、この例外は回復されることを前提としたものではありません。つまり、例外の発生を見越して呼出元に例外をキャッチするコードを書くのは妥当ではありません。妥当なのは、そもそも NULL ポインタを渡さないようにロジックを修正することです。だって、NULL ポインタを渡したこと自体がバグなのですから。\n\nさて話を変えて、例外回復について語るなら、私や他の人が言うように、エラー時にどういう例外が投げられるのかまで契約に含めて考えないと、話が進みません。実際、C 言語の fread 関数にしろ、Java の InputStream の read メソッドにしろ、ファイルが読めなかった時にどう動作するかはマニュアルに明記されています。ファイルが読めなかったからといって動作が未定義ということにはなりません。少なくとも何らかのエラー値や例外が返ってきます。であるからこそ、呼出元でエラー値をチェックしたり例外をキャッチしたりすることに意味が出てきます。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-01814f549abf1b70b6a9&quot;,&quot;user&quot;:{&quot;contribution&quot;:5305,&quot;created_at&quot;:&quot;2014-02-23T13:59:58+09:00&quot;,&quot;id&quot;:38244,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;magicant&quot;},&quot;uuid&quot;:&quot;01814f549abf1b70b6a9&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cp\u003e\u003ca href=\&quot;/magicant\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;magicant\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;magicant\&quot;\u003e@magicant\u003c/a\u003e\u003cbr\u003e\nすみませんが、仰りたい主張がよくわかりません。\u003cbr\u003e\nMeyerの契約の正しい解釈についてでしょうか？それとも契約をより現実に則したモデルへ拡張するお話でしょうか？\u003cbr\u003e\n少なくともこの記事はMeyerの言う契約を説明するためのものです。\u003cbr\u003e\nmagicantさんの仰る説明は「バグ」と「例外」を明確に区別するものだと思います。\u003cbr\u003e\n5日目の「検査例外再考」の記事でも触れていますが、そのような契約の拡張は私自身肯定的です。\u003cbr\u003e\nmagicantさんが引用されている、私の契約や例外に対する疑問はMeyerの契約モデルを逸脱しない範囲での話です。\u003cbr\u003e\nもし契約をより良いシステムとして拡張する記事を書いたとしても(既に書いていますが)、原点であるMeyerの契約を説明し、何故それだけでは十分ではないのかを述べるやり方をとるべきだと思いますし、この記事はそのための紹介記事です。\u003cbr\u003e\n繰り返しますが、私自身は契約を拡張する考えには肯定的です。私も「契約(表明)をassert文を書くための道具としか看做さないのはとても惜しい考えだ」と思います。ただ、この記事はそのためのものではないというだけです。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-06T13:34:09+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126381,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;@magicant\nすみませんが、仰りたい主張がよくわかりません。\nMeyerの契約の正しい解釈についてでしょうか？それとも契約をより現実に則したモデルへ拡張するお話でしょうか？\n少なくともこの記事はMeyerの言う契約を説明するためのものです。\nmagicantさんの仰る説明は「バグ」と「例外」を明確に区別するものだと思います。\n5日目の「検査例外再考」の記事でも触れていますが、そのような契約の拡張は私自身肯定的です。\nmagicantさんが引用されている、私の契約や例外に対する疑問はMeyerの契約モデルを逸脱しない範囲での話です。\nもし契約をより良いシステムとして拡張する記事を書いたとしても(既に書いていますが)、原点であるMeyerの契約を説明し、何故それだけでは十分ではないのかを述べるやり方をとるべきだと思いますし、この記事はそのための紹介記事です。\n繰り返しますが、私自身は契約を拡張する考えには肯定的です。私も「契約(表明)をassert文を書くための道具としか看做さないのはとても惜しい考えだ」と思います。ただ、この記事はそのためのものではないというだけです。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-4afffa756ca4f16713a6&quot;,&quot;user&quot;:{&quot;contribution&quot;:1843,&quot;created_at&quot;:&quot;2012-02-09T20:19:22+09:00&quot;,&quot;id&quot;:3206,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;Kokudori&quot;},&quot;uuid&quot;:&quot;4afffa756ca4f16713a6&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cblockquote\u003e\n\u003cp\u003e仰りたい主張がよくわかりません。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e「契約を正しい、満たして当然のものだと」する Meyer 氏の主張の下で、「例外とはなんぞや」と例外の意義が不明であると \u003ca href=\&quot;/Kokudori\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;Kokudori\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;Kokudori\&quot;\u003e@Kokudori\u003c/a\u003e 氏はぼやいておられるようでしたので、その意義は「デバッグを助ける」ものであるということを明確化する説明をしました。また IO 操作は信頼性が不十分であるために契約が適用できないという話に関して、そもそも IO 操作が信頼できないという仮定が不適切であることを示しました (このことは既に他の方が示していましたが、 \u003ca href=\&quot;/Kokudori\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;Kokudori\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;Kokudori\&quot;\u003e@Kokudori\u003c/a\u003e 氏が不適切な仮定からありがたみのない結論を導くことに拘っているように見えたので、強調のために再度示しました)。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-06T14:08:12+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126388,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;\u003e 仰りたい主張がよくわかりません。\n\n「契約を正しい、満たして当然のものだと」する Meyer 氏の主張の下で、「例外とはなんぞや」と例外の意義が不明であると @Kokudori 氏はぼやいておられるようでしたので、その意義は「デバッグを助ける」ものであるということを明確化する説明をしました。また IO 操作は信頼性が不十分であるために契約が適用できないという話に関して、そもそも IO 操作が信頼できないという仮定が不適切であることを示しました (このことは既に他の方が示していましたが、 @Kokudori 氏が不適切な仮定からありがたみのない結論を導くことに拘っているように見えたので、強調のために再度示しました)。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-42cee5f439e1e835f4e6&quot;,&quot;user&quot;:{&quot;contribution&quot;:5305,&quot;created_at&quot;:&quot;2014-02-23T13:59:58+09:00&quot;,&quot;id&quot;:38244,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;magicant&quot;},&quot;uuid&quot;:&quot;42cee5f439e1e835f4e6&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cp\u003e\u003ca href=\&quot;/magicant\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;magicant\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;magicant\&quot;\u003e@magicant\u003c/a\u003e\u003cbr\u003e\nあぁ、すいません、ようやく理解出来ました。\u003cbr\u003e\n私は回復可能な失敗と回復不可能な失敗がどちらも同じ機構で扱われていることが理解できず、その基準を信頼性に置いてしまいました。\u003cbr\u003e\n私もMeyerの契約でいう例外はデバッグのためだと思いました。しかし、彼の言う例外機構には回復機構があったため、そこが理解できませんでした。\u003cbr\u003e\nつまり、Meyerは信頼性を区別しなかったのではなく、回復可能性を区別しなかったのですね。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eそこはむしろエラー時に例外が投げられることや nil が返されることを事後条件の一部と見做してしまった方が、クライアントが行う例外回復の妥当性を検証する上で都合が良いでしょう。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eという言葉はそれを指していたのですね。\u003c/p\u003e\n\n\u003cp\u003e不勉強でした。お時間取らせてしまい申し訳ありません。ご教授ありがとうございました。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-06T14:39:39+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126392,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;@magicant\nあぁ、すいません、ようやく理解出来ました。\n私は回復可能な失敗と回復不可能な失敗がどちらも同じ機構で扱われていることが理解できず、その基準を信頼性に置いてしまいました。\n私もMeyerの契約でいう例外はデバッグのためだと思いました。しかし、彼の言う例外機構には回復機構があったため、そこが理解できませんでした。\nつまり、Meyerは信頼性を区別しなかったのではなく、回復可能性を区別しなかったのですね。\n\n\u003e そこはむしろエラー時に例外が投げられることや nil が返されることを事後条件の一部と見做してしまった方が、クライアントが行う例外回復の妥当性を検証する上で都合が良いでしょう。\n\nという言葉はそれを指していたのですね。\n\n不勉強でした。お時間取らせてしまい申し訳ありません。ご教授ありがとうございました。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-b24ced01c40a549d06a3&quot;,&quot;user&quot;:{&quot;contribution&quot;:1843,&quot;created_at&quot;:&quot;2012-02-09T20:19:22+09:00&quot;,&quot;id&quot;:3206,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;Kokudori&quot;},&quot;uuid&quot;:&quot;b24ced01c40a549d06a3&quot;,&quot;via_email&quot;:false},{&quot;banned&quot;:false,&quot;body&quot;:&quot;\u003cp\u003e\u003ca href=\&quot;/Kokudori\&quot; class=\&quot;user-mention js-hovercard\&quot; title=\&quot;Kokudori\&quot; data-hovercard-target-type=\&quot;user\&quot; data-hovercard-target-name=\&quot;Kokudori\&quot;\u003e@Kokudori\u003c/a\u003e こちらこそ、私の説明がつたないせいでやり取りを長引かせてしまったかと思います。すみませんでした。\u003c/p\u003e\n&quot;,&quot;created_at&quot;:&quot;2014-12-07T11:56:28+09:00&quot;,&quot;expanded_references&quot;:&quot;&quot;,&quot;id&quot;:126528,&quot;is_team&quot;:false,&quot;item_id&quot;:194437,&quot;item_type&quot;:&quot;PublicDomainArticle&quot;,&quot;item_uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;likable&quot;:false,&quot;liked&quot;:false,&quot;public_likes_count&quot;:0,&quot;raw_body&quot;:&quot;@Kokudori こちらこそ、私の説明がつたないせいでやり取りを長引かせてしまったかと思います。すみませんでした。\n&quot;,&quot;reaction_types&quot;:[{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f44d.png&quot;,&quot;name&quot;:&quot;+1&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f64f.png&quot;,&quot;name&quot;:&quot;pray&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f389.png&quot;,&quot;name&quot;:&quot;tada&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f647.png&quot;,&quot;name&quot;:&quot;bow&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f631.png&quot;,&quot;name&quot;:&quot;scream&quot;},{&quot;image_url&quot;:&quot;https://cdn.qiita.com/emoji/twemoji/unicode/1f440.png&quot;,&quot;name&quot;:&quot;eyes&quot;}],&quot;reactions&quot;:[],&quot;team&quot;:null,&quot;team_membership&quot;:null,&quot;updatable&quot;:false,&quot;url&quot;:&quot;http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f#comment-4ecfd1a71993343856e3&quot;,&quot;user&quot;:{&quot;contribution&quot;:5305,&quot;created_at&quot;:&quot;2014-02-23T13:59:58+09:00&quot;,&quot;id&quot;:38244,&quot;is_admin&quot;:false,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694&quot;,&quot;suspended&quot;:false,&quot;url_name&quot;:&quot;magicant&quot;},&quot;uuid&quot;:&quot;4ecfd1a71993343856e3&quot;,&quot;via_email&quot;:false}],&quot;monthly_public_image_uploadable_size_limit&quot;:null,&quot;total_uploaded_public_image_size_in_current_month&quot;:null,&quot;item&quot;:{&quot;id&quot;:194437,&quot;uuid&quot;:&quot;2e4bd32abf7abea3186f&quot;,&quot;suspended&quot;:false,&quot;secret&quot;:false},&quot;owner&quot;:{&quot;url_name&quot;:&quot;Kokudori&quot;},&quot;is_team&quot;:false,&quot;is_project&quot;:false,&quot;logged_in&quot;:false,&quot;polling&quot;:false,&quot;mention_candidates&quot;:[{&quot;id&quot;:3206,&quot;url_name&quot;:&quot;Kokudori&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;},{&quot;id&quot;:20549,&quot;url_name&quot;:&quot;todesking@github&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/20549/profile-images/1473683047&quot;},{&quot;id&quot;:38244,&quot;url_name&quot;:&quot;magicant&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/38244/profile-images/1473687694&quot;}]}">Comments Loading...</div></div></div></div></div></article><div class="js-report-form modal fade reportForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Report article</h4></div><div class="modal-body"><form action="/reports" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="dK1gedhxjaDvQZGC8AtGCHaV88z02KvXpNiH+g0Cq1YaL/shQ1+06xCSJJ6A/vhRFtLXf2Mc8SCYBo4B7AylkA==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/Kokudori/items/2e4bd32abf7abea3186f" /><input type="hidden" name="item_uuid" id="item_uuid" value="2e4bd32abf7abea3186f" /><p>Help us understand the problem. What is going on with this item?</p><br /><div class="form-group"><ul class="list-unstyled"><li><label><input type="radio" name="report_type" id="report_type_spam" value="spam" required="required" /> It&#39;s spam </label></li><li><label><input type="radio" name="report_type" id="report_type_harassment" value="harassment" required="required" /> It&#39;s abusive or harmful </label></li><li><label><input type="radio" name="report_type" id="report_type_inappropriate_content" value="inappropriate_content" required="required" /> It contains inappropriate content </label></li></ul></div><div class="reportForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary reportForm_submitButton"><i class="fa fa-send"></i> Submit</button></div></form></div></div></div></div><script id="js-item" type="application/json">{ "url": "http://qiita.com/Kokudori/items/2e4bd32abf7abea3186f", "id": 194437, "uuid": "2e4bd32abf7abea3186f" }</script><script class="js-user" type="application/json">{&quot;id&quot;:3206,&quot;url_name&quot;:&quot;Kokudori&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/3206/profile-images/1473682775&quot;}</script><script language="JavaScript" src="//cdn.bigmining.com/private/js/qiita_bigmining.js" type="text/javascript"></script></div><footer class="footer"><div class="footer_inner"><div class="footer_container"><ul class="footer_links-left"><li class="footer_link"><a class="footer_copyright" href="http://increments.co.jp">© 2011-2017 Increments Inc.</a></li><li class="footer_link"><a href="http://qiita.com/terms">Terms</a></li><li class="footer_link"><a href="http://qiita.com/privacy">Privacy</a></li><li class="footer_link"><a href="http://help.qiita.com">Help</a></li><li class="footer_link"><a href="https://increments.zendesk.com/anonymous_requests/new">Contact</a></li></ul><ul class="footer_links-right"><li class="footer_link"><a href="http://qiita.com/about">About</a></li><li class="footer_link"><a href="/users">Users</a></li><li class="footer_link"><a href="/tags">Tags</a></li><li class="footer_link"><a href="http://blog.qiita.com">Blog</a></li><li class="footer_link"><a href="http://qiita.com/api/v2/docs">API</a></li><li class="footer_link"><a href="https://teams.qiita.com/">Team</a></li><li class="footer_link"><a href="http://kobito.qiita.com">Kobito</a></li><li class="footer_link"><a class="js-public-form-feedback-link" data-target=".js-feedback-form" data-toggle="modal" href=""><i class="fa fa-heart"></i> Feedback <i class="fa fa-caret-down"></i></a></li></ul></div></div></footer><div class="js-feedback-form modal fade feedbackForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Feedback</h4></div><div class="modal-body"><form class="js-feedback-form-form" action="/feedbacks" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="Zqu7CDOGbvaHfZYL7dV2lBHnnBYA5bYmSqWlWtm1LSwIKSBQqKhXvXiuIxedIMjNcaC4pZch7NF2e6yhOLsj6g==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/Kokudori/items/2e4bd32abf7abea3186f" /><div class="form-group"><textarea name="feedback[message]" id="feedback_message" class="form-control js-feedback-form-text-area" placeholder="Please give us any feedback about Qiita." required="required" rows="5">
</textarea></div><div class="feedbackForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary feedbackForm_submitButton"><i class="fa fa-send"></i> Submit</button><p class="feedbackForm_note">We don&#39;t reply to any feedback.<br />If you need help with Qiita, please send a support request from <a href="https://increments.zendesk.com/anonymous_requests/new">here</a>.</p></div><div style="position:fixed;top:-99999px;opacity:0.0001;"><input name="feedback[name]" type="text" /></div></form></div></div></div></div><script>// if (window.mixpanel instanceof Element) {
//   window.mixpanel = [];
// }
// (function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
// for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);</script><script src="http://cdn.qiita.com/assets/public-8c6201a66dc6db6f64a9017391c319bf.min.js"></script><script>
  (function () {
    var script = document.getElementsByTagName('script')[0];
    var load = function (src, id) {
      var el = document.createElement('script');
      el.async = true;
      el.src = src;
      el.id = id;
      script.parentNode.insertBefore(el, script);
    };
      // Optimizely
      load('//cdn.optimizely.com/js/52738645.js', 'optimizely-jssdk');
      // Google Analytics
      window._gaq = window._gaq || [];
      var isCareer = location.hostname.split('.')[0] == 'career';
      if (isCareer) {
        window._gaq.push(['_setAccount', 'UA-24675221-11']);
        window._gaq.push(['_setDomainName', 'qiita.com']);
      } else {
        window._gaq.push(['_setAccount', 'UA-24675221-1']);
      }
      window._gaq.push(['_setCustomVar', 1, 'logged_in', 'false', 2]);
      window._gaq.push(['_trackPageview']);
      var src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      load(src, 'google-analytics-jssdk');
    // Google Analytics - Universal Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-24675221-12', {
          
        });
        ga('set', 'dimension1', 'false');
        ga('set', 'dimension3', 'false');
      ga('require', 'displayfeatures');
      ga('set', 'forceSSL', true);
      ga('send', 'pageview');
    // Google Tag Manager
      (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-TBQWPN');
  })();
</script>
</body></html>