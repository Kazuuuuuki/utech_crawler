<!DOCTYPE html><html xmlns:og="http://ogp.me/ns#"><head><meta charset="UTF-8" /><title>C#/JavaScriptで学ぶF#入門 - Qiita</title><meta content="width=device-width,initial-scale=1" name="viewport" /><meta content="C#やJavaScript（ES2015）と比較しながらF#の文法を説明します。手続型の延長線上で取っ掛かりをつかむことを目的とします。関数型については深追いしません。


とりあえず手続型的な発想でも構わないので、F#を使ってみます。
関数型特有の概念の説明には重点を置きませんが、その導入になるようには意識します。
一気に関数型に飛ばないで、ベターC#として慣れていくような入り方を目指します。
関数型の理解を深めるのは慣れてからでも遅くないというスタンスです。


こ..." name="description" /><meta content="summary" name="twitter:card" /><meta content="@Qiita" name="twitter:site" /><meta content="7shi" name="twitter:creator" /><meta content="C#/JavaScriptで学ぶF#入門 - Qiita" property="og:title" /><meta content="article" property="og:type" /><meta content="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" property="og:url" /><meta content="http://cdn.qiita.com/assets/qiita-fb-2887e7b4aad86fd8c25cea84846f2236.png" property="og:image" /><meta content="C#やJavaScript（ES2015）と比較しながらF#の文法を説明します。手続型の延長線上で取っ掛かりをつかむことを目的とします。関数型については深追いしません。

* とりあえず手続型的な発想でも構わないので、F#を使ってみま..." property="og:description" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><link rel="shortcut icon" type="image/x-icon" href="http://cdn.qiita.com/assets/favicons/public/production-4ff10c1e1e2b5fcb353ff9cafdd56c70.ico" /><link rel="apple-touch-icon" type="image/png" href="http://cdn.qiita.com/assets/favicons/public/apple-touch-icon-f9a6afad761ec2306e10db2736187c8b.png" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link rel="stylesheet" media="all" href="http://cdn.qiita.com/assets/public-e8d29e8ff1879118096f0f5877946857.min.css" /><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="jf7r4HEYUQHRX/iJ1duToP+r5FKp4ZGcQOuz4wxuD3LjfHC46jZoSi6MTZWlLi35n+zA4T4ly2t8NboY7WABtA==" /></head><body class="without-js" id=""><noscript><iframe height="0" src="//www.googletagmanager.com/ns.html?id=GTM-TBQWPN" style="display:none;visibility:hidden" width="0"></iframe></noscript><script>
  document.body.className = document.body.className.replace('without-js', '') + ' with-js';
  window.Qiita = {"asset_host":"cdn.qiita.com","TLD":"com","controller_path":"public/items","controller_action":"public/items#show","controller":"items","action":"show","env":"production","flash":{},"is_landing_page":false,"is_team_page":false,"root_domain":"qiita.com","variant":null,"config":{"mixpanel":{"career":"dd35af27e959781713d63fd7ca898a8d","per_team":"c0a2116368b33b44b5029ebd2cc9b094","public":"be87616606b0e26a87689099aab2c4e5","team":"b7c0342acba2dbc8742484d98788efb3"},"default_locale":"ja","locale":"en"},"team":null,"user":null,"GIT_BRANCH":null,"DEBUG":false};

</script>
<div class="headerContainer headerContainer-public" role="navigation"><div data-react-class="T.HeaderContainer" data-react-props="{&quot;user&quot;:null,&quot;team&quot;:null,&quot;news&quot;:{&quot;type&quot;:&quot;Hot&quot;,&quot;content&quot;:&quot;Markdownによる情報共有サービス、Qiita:Team&quot;,&quot;url&quot;:&quot;https://teams.qiita.com?utm_source=qiita\u0026utm_medium=header_news&quot;},&quot;initial_unread_count&quot;:null,&quot;siteid_image&quot;:&quot;http://cdn.qiita.com/siteid-reverse.png&quot;,&quot;is_team_page&quot;:false,&quot;on_team_setting&quot;:false,&quot;show_post_menu&quot;:true,&quot;show_search_menu&quot;:true,&quot;is_fluid&quot;:false,&quot;locale&quot;:&quot;en&quot;}"></div></div><div id="main"><ol class="itemBreadcrumbs" itemscope="" itemtype="http://schema.org/BreadcrumbList"><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/"><span itemprop="name">Qiita</span></a><meta content="1" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/items"><span itemprop="name">Items</span></a><meta content="2" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/tags/F%23"><span itemprop="name">F#</span></a><meta content="3" itemprop="position" /></li></ol><article itemscope="" itemtype="http://schema.org/Article"><div class="ArticleMainHeader "><div class="container"></div><div class="container"><div class="row s-flex-align-center"><div class="col-sm-9"><h1 class="ArticleMainHeader__title">C#/JavaScriptで学ぶF#入門</h1><ul class="TagList"><li class="TagList__item" data-count="160"><a class="u-link-unstyled TagList__label" href="/tags/F%23"><img alt="F#" class="TagList__icon" src="https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/ba95a660afc4ec92093e69afbd0b70d04e51245b/medium.jpg?1395581508" /><span>F#</span></a></li><li class="TagList__item" data-count="3128"><a class="u-link-unstyled TagList__label" href="/tags/C%23"><img alt="C#" class="TagList__icon" src="https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/56621c239d6d51d9b6ceda3850a0d97e23c92319/medium.jpg?1364839171" /><span>C#</span></a></li><li class="TagList__item" data-count="13002"><a class="u-link-unstyled TagList__label" href="/tags/JavaScript"><img alt="JavaScript" class="TagList__icon" src="https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/58f69837141ae3efa0c530ed53de128cacb49b66/medium.jpg?1421232838" /><span>JavaScript</span></a></li></ul></div><div class="col-sm-3"><div class="itemsShowHeaderStock"><ul class="list-unstyled itemsShowHeaderStock_statusList"><li><div class="itemsShowHeaderStock_count stock"><span class="fa fa-thumbs-up"></span><span class="js-likecount">16</span></div><div class="itemsShowHeaderStock_countText">Like</div></li><li><div class="itemsShowHeaderStock_count" content="0 UserComments" itemprop="interactionCount"><span class="fa fa-comment"></span>0</div><div class="itemsShowHeaderStock_countText">Comment</div></li></ul></div><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:16,&quot;uuid&quot;:&quot;ff746903680ae8d0d7ce&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-header&quot;}"></div><ul class="list-inline ArticleMainHeader__users"><li class="js-hovercard" data-hovercard-target-name="tyahha"><a itemprop="url" href="/tyahha"><img alt="tyahha" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/91779/profile-images/1480570348" /></a></li><li class="js-hovercard" data-hovercard-target-name="jbucaran"><a itemprop="url" href="/jbucaran"><img alt="jbucaran" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/60411/profile-images/1483117845" /></a></li><li class="js-hovercard" data-hovercard-target-name="NetSeed"><a itemprop="url" href="/NetSeed"><img alt="NetSeed" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/9662/profile-images/1473681499" /></a></li><li class="js-hovercard" data-hovercard-target-name="moto_pipedo"><a itemprop="url" href="/moto_pipedo"><img alt="moto_pipedo" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/86588/profile-images/1473703794" /></a></li><li class="js-hovercard" data-hovercard-target-name="ozwk"><a itemprop="url" href="/ozwk"><img alt="ozwk" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/72075/profile-images/1473699037" /></a></li><li class="js-hovercard" data-hovercard-target-name="muro"><a itemprop="url" href="/muro"><img alt="muro" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/46717/profile-images/1473690741" /></a></li><li class="js-hovercard" data-hovercard-target-name="KandaMorioka"><a itemprop="url" href="/KandaMorioka"><img alt="KandaMorioka" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/126862/profile-images/1473716697" /></a></li><li class="js-hovercard" data-hovercard-target-name="ttsutchi"><a itemprop="url" href="/ttsutchi"><img alt="ttsutchi" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/120362/profile-images/1486650239" /></a></li><li class="js-hovercard" data-hovercard-target-name="Yasu-umi"><a itemprop="url" href="/Yasu-umi"><img alt="Yasu-umi" class="thumb thumb--xs" src="https://pbs.twimg.com/profile_images/550329366035456000/u947CJIG_normal.png" /></a></li><li class="js-hovercard" data-hovercard-target-name="chocolamint"><a itemprop="url" href="/chocolamint"><img alt="chocolamint" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/11978/profile-images/1473682231" /></a></li><li><a href="/7shi/items/ff746903680ae8d0d7ce/likers"><span class="fa fa-ellipsis-h"></span></a></li></ul></div></div></div></div><div class="ArticleAsideHeader"><div class="container"><div class="u-flex u-space-between"><div class="u-flex u-flex-wrap"><div class="u-flex u-align-center s-pdv-5 u-flex-wrap"><div class="ArticleAsideHeader__author"><a href="/7shi"><img class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" alt="1473685823" /></a> <a class="u-link-unstyled" href="/7shi">7shi</a> </div><div class="ArticleAsideHeader__date"><span data-toggle="tooltip" title="posted at 2017-01-04">Edited at <time datetime="2017-02-09T18:45:11+09:00" itemprop="dateModified">2017-02-09</time></span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"><div class="ArticleAsideHeader__revision"> <a data-toggle="tooltip" title="Revisions" href="/7shi/items/ff746903680ae8d0d7ce/revisions"><span class="fa fa-history"></span></a><span class="ArticleAsideHeader__revisionCount">43</span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"></div></div><div class="u-flex u-align-center s-flex-justiry-between s-pdv-5 u-shrink-0"><div class="ArticleAsideHeader__stock"><div class="js-stockbutton" data-position="top" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h fa-lg"></span></a><ul class="dropdown-menu dropdown-menu-right"><li class="dropdown__item--mobile"><a href="/7shi/items/ff746903680ae8d0d7ce/revisions"><span class="fa fa-fw fa-history"></span> Revisions<span>(43)</span></a></li><li><a href="/7shi/items/ff746903680ae8d0d7ce.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><span class="fa fa-fw fa-flag"></span> Report article</a></li></ul></div></div></div></div></div><div class="container"><div class="row" id="article-body-wrapper"><div class="col-sm-9"><section class="markdownContent markdownContent-headingEnabled js-task-list-container clearfix position-relative" id="item-ff746903680ae8d0d7ce" itemprop="articleBody"><p>C#やJavaScript（ES2015）と比較しながらF#の文法を説明します。手続型の延長線上で取っ掛かりをつかむことを目的とします。関数型については深追いしません。</p>

<ul>
<li>とりあえず手続型的な発想でも構わないので、F#を使ってみます。</li>
<li>関数型特有の概念の説明には重点を置きませんが、その導入になるようには意識します。</li>
<li>一気に関数型に飛ばないで、ベターC#として慣れていくような入り方を目指します。</li>
<li>関数型の理解を深めるのは慣れてからでも遅くないというスタンスです。</li>
</ul>

<p>この記事は以前開催していた<a href="https://connpass.com/series/361/" rel="nofollow noopener" target="_blank">F#入門</a>のテキストを改訂したものです。</p>

<p>この記事には姉妹編があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" id="reference-6a3cfa99698502105270">Haskellで学ぶF#入門</a> 2017.01.11</li>
</ul>

<p>F#を手っ取り早く試すために、私が常用している環境を紹介します。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/5fc7d6477d96bbd7a71d" id="reference-68b89880edcfdf69cabe">F#開発環境の紹介</a> 2016.12.30</li>
</ul>

<h1>
<span id="fについて" class="fragment"></span><a href="#f%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6"><i class="fa fa-link"></i></a>F#について</h1>

<p>F#の構文は見慣れないものだと思います。この記事ではC#/JavaScriptと比較しながら構文に慣れることに重点を置きます。</p>

<h2>
<span id="背景" class="fragment"></span><a href="#%E8%83%8C%E6%99%AF"><i class="fa fa-link"></i></a>背景</h2>

<p>F#が分かりにくいと感じる原因は、主に以下の2種類ではないでしょうか。</p>

<ol>
<li>構文の異質さ（C系言語などと比較して）</li>
<li>関数型の考え方</li>
</ol>

<p>今回は前者の壁に的を絞ります。両者は完全に分離しているわけではないため、後者の領域も多少は言及します。個人的にはF#は構文が簡潔で短く書けるのが良いと思っています。触り始めの頃は関数型のことはあまり意識しませんでした。</p>

<h2>
<span id="位置付け" class="fragment"></span><a href="#%E4%BD%8D%E7%BD%AE%E4%BB%98%E3%81%91"><i class="fa fa-link"></i></a>位置付け</h2>

<p>F#はC#と同様に.NET Frameworkで動く言語です。クラスを定義したり使ったりなど、基本的にはC#でできるのとほぼ同じことができます。</p>

<p>※ これは大雑把な説明で、細かい点で違いはあります（<code>protected</code>や入れ子にされた型など）。</p>

<p>それに対してJavaScriptは出自が異なりますが、C#よりもJavaScriptで説明した方が分かりやすいケースもあるため、説明に取り入れました。</p>

<h1>
<span id="ハローワールド" class="fragment"></span><a href="#%E3%83%8F%E3%83%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89"><i class="fa fa-link"></i></a>ハローワールド</h1>

<p>※ 横幅の関係上、インデントはスペース2つとします。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
using System;

class Program
{
  static void Main()
  {
    Console.WriteLine("hello");
  }
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
console.log("hello");
</pre></div></div></td>
<td>
<div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "hello"
</pre></div></div>または<div class="code-frame" data-lang="text"><div class="highlight"><pre>
open System
Console.WriteLine "hello"
</pre></div></div>
</td>
</tr>
</table>

<ul>
<li>C#はMainメソッドが必須で、クラスで包む必要があります。簡単のため以後の例では省略します。</li>
<li>JavaScriptとF#はクラスやMainで包む必要がありません。</li>
<li>F#はセミコロンが必要ありません。（JavaScriptも省略可能）</li>
<li>F#では引数を<code>()</code>で囲む必要がありません。（付けても動きます）</li>
<li>F#の<code>open</code>はC#の<code>using</code>に相当します。以後の例では省略します。</li>
</ul>

<h2>
<span id="printfprintfn" class="fragment"></span><a href="#printfprintfn"><i class="fa fa-link"></i></a>printf/printfn</h2>

<p>F#の<code>printf</code>/<code>printfn</code>は<code>open</code>も何もなくいきなり使える標準の出力用関数です。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printf</span> <span class="s">"hello</span><span class="se">\n</span><span class="s">"</span>
<span class="n">printfn</span> <span class="s">"hello"</span>
</pre></div>
</div>

<p>関数名の接尾辞<code>n</code>は<code>"\n"</code>と同様に New line に由来して、改行を意味します。</p>

<p>複数の引数はコンマではなくスペースで区切ります。（詳細は次のセクションで解説します）</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%d"</span> <span class="mi">1</span>
</pre></div>
</div>

<p><code>printf</code>はコンパイラがフォーマット文字列を認識して、引数の型をチェックします。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%d"</span> <span class="s">"abc"</span>  <span class="c1">// エラー</span>
<span class="n">printfn</span> <span class="s">"%s"</span> <span class="mi">0</span>      <span class="c1">// エラー</span>
</pre></div>
</div>

<h1>
<span id="複数の引数" class="fragment"></span><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E5%BC%95%E6%95%B0"><i class="fa fa-link"></i></a>複数の引数</h1>

<p>F#では複数の引数の扱い方が二系統あり、F#ネイティブの関数と.NETのメソッドとで異なります。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Console.WriteLine("{0} {1}”,
  1 + 1, Math.Sqrt(2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
console.log(1 + 1, Math.sqrt(2));
</pre></div></div></td>
<td>
<div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d %f" (1 + 1) (sqrt 2.)
</pre></div></div>または<div class="code-frame" data-lang="text"><div class="highlight"><pre>
Console.WriteLine("{0} {1}",
  1 + 1, Math.Sqrt 2.)
</pre></div></div>
</td>
</tr>
</table>

<p>※ F#の2.は2.0のことで、浮動小数点数であることを示します。（後述）</p>

<h2>
<span id="fネイティブの関数" class="fragment"></span><a href="#f%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%81%AE%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>F#ネイティブの関数</h2>

<p>複数の引数はコンマではなくスペースで区切ります。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%d"</span> <span class="mi">1</span>
</pre></div>
</div>

<p>コンマを付けると警告されてうまく動きません。（後述のタプルとして扱われます）</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%d"</span><span class="o">,</span> <span class="mi">1</span>  <span class="c1">// 警告され文字も出力されない</span>
</pre></div>
</div>

<p>括弧で囲む必要はありません。付けるとエラーになります。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span><span class="o">(</span><span class="s">"%d"</span> <span class="mi">1</span><span class="o">)</span>   <span class="c1">// エラー</span>
<span class="n">printfn</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>  <span class="c1">// エラー</span>
</pre></div>
</div>

<p>引数で計算や関数呼び出しを行う場合、引数としてまとめるため括弧で囲む必要があります。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#（再掲）</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%d %f"</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">.)</span>
</pre></div>
</div>

<h2>
<span id="netのメソッド" class="fragment"></span><a href="#net%E3%81%AE%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89"><i class="fa fa-link"></i></a>.NETのメソッド</h2>

<p>タプルと呼ばれる複数の値を組み合わせた型として扱われます。C#と同じスタイルで、引数はコンマで区切って括弧で囲みます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="s">"{0}"</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>

<p>括弧を省略すると警告されてうまく動きません。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="s">"{0}"</span><span class="o">,</span> <span class="mi">1</span>  <span class="c1">// 警告され実行時例外</span>
</pre></div>
</div>

<p>.NETのメソッドでも1引数の場合は括弧が省略可能です。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="s">"hello"</span>
</pre></div>
</div>

<p>以後の例では、F#はネイティブの関数（<code>printfn</code>など）があれば、.NETのメソッド（<code>Console.WriteLine</code>など）よりも優先して使用します。</p>

<h2>
<span id="数値型のキャスト" class="fragment"></span><a href="#%E6%95%B0%E5%80%A4%E5%9E%8B%E3%81%AE%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88"><i class="fa fa-link"></i></a>数値型のキャスト</h2>

<p>F#では数値型を自動的にキャストしてくれないため<code>sqrt(2)</code>はエラーになります。<br>
C#/JavaScriptから見ると不親切ですが、型推論を優先するための言語設計です。</p>

<p>浮動小数点数型はC#とは型名が異なるため注意が必要です。</p>

<table>
<thead>
<tr>
<th>C#</th>
<th>F#</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>float32</td>
</tr>
<tr>
<td>double</td>
<td>float</td>
</tr>
</tbody>
</table>

<p>倍精度が浮動小数点数の基本で、単精度がオプショナルという解釈だと思われます。</p>

<h2>
<span id="おまけ" class="fragment"></span><a href="#%E3%81%8A%E3%81%BE%E3%81%91"><i class="fa fa-link"></i></a>おまけ</h2>

<p>LISPを知っていれば、最上位の括弧が省略されていると考えればしっくり来るかもしれません。括弧で囲んでも動きます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="o">(</span><span class="n">printfn</span> <span class="s">"%f"</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">.))</span>
</pre></div>
</div>

<h1>
<span id="変数" class="fragment"></span><a href="#%E5%A4%89%E6%95%B0"><i class="fa fa-link"></i></a>変数</h1>

<p>F#の変数はデフォルトで再代入できないという特徴があります。そのことについての説明は後に回して、まずは単純に変数を定義するケースを取り上げます。</p>

<p>変数は<code>let</code>で定義します。型推論されるため、C#の<code>var</code>に相当します。JavaScriptでは<code>var</code>は関数スコープとなるため、ES2015で追加されたブロックスコープの<code>let</code>に相当します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var a = 1;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1
</pre></div></div></td>
</tr>
</table>

<p>型を明示的に指定する方法もあります。JavaScriptはasm.jsで型で示します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int a = 1;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1 | 0;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a: int = 1
</pre></div></div></td>
</tr>
</table>

<p>F#では可能な限り型推論に任せるスタイルを推奨します。</p>

<h2>
<span id="束縛" class="fragment"></span><a href="#%E6%9D%9F%E7%B8%9B"><i class="fa fa-link"></i></a>束縛</h2>

<p>F#はデフォルトでは変数に入れた値は変更できません。変数と値の結び付きが強く、「代入」ではなく「束縛」と表現します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
const int a = 1;
Console.WriteLine(a);
a = 2;  // エラー
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
const a = 1;
console.log(a);
a = 2;  // エラー
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1
printfn "%d" a
a = 2  // 警告（代入ではなく比較）
</pre></div></div></td>
</tr>
</table>

<p>F#では<code>=</code>と<code>==</code>を書き分けずにどちらも<code>=</code>です。<code>let</code>以外の<code>=</code>は比較として扱われます。</p>

<p>F#で値が変更できるようにするには<code>mutable</code>を付けます。値の変更には<code>&lt;-</code>を使います。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int a = 1;
Console.WriteLine(a);
a = 2;
Console.WriteLine(a);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1;
console.log(a);
a = 2;
console.log(a);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let mutable a = 1
printfn "%d" a
a &lt;- 2
printfn "%d" a
</pre></div></div></td>
</tr>
</table>

<p><code>mutable</code>を付けずに宣言した変数に再代入する方法はありません。</p>

<h2>
<span id="複数の変数定義" class="fragment"></span><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E6%95%B0%E5%AE%9A%E7%BE%A9"><i class="fa fa-link"></i></a>複数の変数定義</h2>

<p>複数の変数を一度に定義する書式を示します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int x = 1, y = 2;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let x = 1, y = 2;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let x, y = 1, 2
</pre></div></div></td>
</tr>
</table>

<p>※ C#では<code>var</code>を使うと複数の変数を一度に定義できません。</p>

<p>F#の書式は括弧で囲めば数学に近くなり、座標の表記に似たものだと理解できます。括弧の有無で意味は変わりません。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>
</div>

<h1>
<span id="f-interactive" class="fragment"></span><a href="#f-interactive"><i class="fa fa-link"></i></a>F# Interactive</h1>

<p>ちょっとした実験は対話的に実行した方が便利です。F# Interactive (fsi) と呼ばれるREPLがあります。</p>

<p>Windows では <code>fsi.exe</code> ですが、Mono 環境では <code>fsharpi</code> コマンドで呼び出します。</p>

<p>fsiではセミコロンを2つ付けると、評価されて値が表示されます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="k">let</span> <span class="nv">a</span><span class="o">=</span><span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">a</span> <span class="o">:</span> <span class="n">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>

<p>※ <code>val</code>は値（value）の意味です。</p>

<p>変数の値を見るには変数名だけでOKです。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="n">a</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="n">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>

<p>itは直前に評価された値が束縛されている変数で「それ（it）」の意味です。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="n">it</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="n">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>

<p><code>;;</code>を付け忘れると複数行入力として扱われます。次の行で付ければ評価されます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="n">a</span>
<span class="o">-</span> <span class="o">;;</span>
</pre></div>
</div>

<p>電卓としても使えます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="n">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>

<p><code>let</code>なしの<code>=</code>が比較になっているのを確認します。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="k">true</span>
<span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="k">false</span>
</pre></div>
</div>

<p>等しくないのを表すのは<code>&lt;&gt;</code>です。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="n">a</span><span class="o">&lt;&gt;</span><span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="k">false</span>
</pre></div>
</div>

<p>終了は<code>#q;;</code>と入力します。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fsi</span></div>
<div class="highlight"><pre>
<span class="o">&gt;</span> <span class="o">#</span><span class="n">q</span><span class="o">;;</span>
</pre></div>
</div>

<h1>
<span id="条件式" class="fragment"></span><a href="#%E6%9D%A1%E4%BB%B6%E5%BC%8F"><i class="fa fa-link"></i></a>条件式</h1>

<p><code>if</code>は構文が少し違うだけで基本的に同じです。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
if (a == 1)
  Console.WriteLine("1");
else
  Console.WriteLine("?");
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
if (a == 1)
  console.log("1");
else
  console.log("?");
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
if a = 1 then
  printfn "1"
else
  printfn "?"
</pre></div></div></td>
</tr>
</table>

<h2>
<span id="ブロック" class="fragment"></span><a href="#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>ブロック</h2>

<p>F#はインデントでブロックが構成されるので、C#のように複文での中括弧に相当するものはありません。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
if (a == 1)
{
  Console.WriteLine("1");
  Console.WriteLine("!");
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
if (a == 1) {
  console.log("1");
  console.log("!");
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
if a = 1 then
  printfn "1"
  printfn "!"
</pre></div></div></td>
</tr>
</table>

<h2>
<span id="三項演算子" class="fragment"></span><a href="#%E4%B8%89%E9%A0%85%E6%BC%94%E7%AE%97%E5%AD%90"><i class="fa fa-link"></i></a>三項演算子</h2>

<p>F#の<code>if</code>はそのまま三項演算子としても使えます。（<code>if</code>は文ではなく式のため）</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var b = a == 1 ? 2 : 0;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = a == 1 ? 2 : 0;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = if a = 1 then 2 else 0
</pre></div></div></td>
</tr>
</table>

<h2>
<span id="複合技" class="fragment"></span><a href="#%E8%A4%87%E5%90%88%E6%8A%80"><i class="fa fa-link"></i></a>複合技</h2>

<p>F#では最後に評価された値が返されるため、処理と代入を混ぜることができます。これは慣れると便利な技です。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int b;
if (a == 1)
{
  Console.WriteLine("1");
  b = 2;
}
else
{
  Console.WriteLine("?");
  b = 0;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b;
if (a == 1) {
  console.log("1");
  b = 2;
} else {
  console.log("?");
  b = 0;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b =
  if a = 1 then
    printfn "1"
    2
  else
    printfn "?"
    0
</pre></div></div></td>
</tr>
</table>

<h2>
<span id="タプル" class="fragment"></span><a href="#%E3%82%BF%E3%83%97%E3%83%AB"><i class="fa fa-link"></i></a>タプル</h2>

<p>条件分岐の結果、複数の値を代入するような処理を一気に書けます。うまくハマるととても簡潔になります。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int x, y;
if (a == 1)
{
  x = 1;
  y = 2;
}
else
{
  x = 3;
  y = 4;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let x, y;
if (a == 1) {
  x = 1;
  y = 2;
} else {
  x = 3;
  y = 4;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let x, y = if a = 1 then 1, 2 else 3, 4
</pre></div></div></td>
</tr>
</table>

<p>この構文が分かりにくければ、括弧を付けて考えると良いかもしれません。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div>
</div>

<h1>
<span id="関数" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>関数</h1>

<p>説明の都合上、F#は冗長な構文から先に紹介します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
class Test
{
  static int inc(int x)
  {
    return x + 1;
  }
  static int add(int x, int y)
  {
    return x + y;
  }
  static void Main()
  {
    Console.WriteLine(inc(1));
    Console.WriteLine(add(1, 2));
  }
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
function inc(x) {
  return x + 1;
}
function add(x, y) {
  return x + y;
}
console.log(inc(1));
console.log(add(1, 2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc = fun x -&gt; x + 1
let add = fun x y -&gt; x + y
printfn "%d" (inc 1)
printfn "%d" (add 1 2)
</pre></div></div></td>
</tr>
</table>

<p>F#は変数の束縛と同じ構文で、関数が束縛されています。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#（対比）</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">inc</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">let</span> <span class="nv">inc</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>

<p>右辺の <code>fun x -&gt; x + 1</code> は左辺に束縛されて名前が付くことから、単体では名前が無く、無名関数などと呼ばれます。</p>

<h2>
<span id="ラムダ式" class="fragment"></span><a href="#%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F"><i class="fa fa-link"></i></a>ラムダ式</h2>

<p>F#の書き方は、C#のラムダ式やJavaScriptのアロー関数式に相当します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Func&lt;int, int&gt; inc = x =&gt; x + 1;
Func&lt;int, int, int&gt; add = (x, y) =&gt; x + y;
Console.WriteLine(inc(1));
Console.WriteLine(add(1, 2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc = x =&gt; x + 1;
let add = (x, y) =&gt; x + y;
console.log(inc(1));
console.log(add(1, 2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc = fun x -&gt; x + 1
let add = fun x y -&gt; x + y
printfn "%d" (inc 1)
printfn "%d" (add 1 2)
</pre></div></div></td>
</tr>
</table>

<p>C#の<code>Func</code>は冗長ですが、型推論が効かないため省略できません。</p>

<div class="code-frame" data-lang="csharp">
<div class="code-lang"><span class="bold">C#</span></div>
<div class="highlight"><pre>
<span class="kt">var</span> <span class="n">inc</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>  <span class="c1">// エラー</span>
</pre></div>
</div>

<p>ちなみにVB.NETでは匿名デリゲート型に型推論されます。</p>

<div class="code-frame" data-lang="vbnet">
<div class="code-lang"><span class="bold">VB.NET</span></div>
<div class="highlight"><pre>
<span class="k">Dim</span> <span class="n">inc</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">x%</span><span class="p">)</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>

<p>※ C#では引数や戻り値の型が同じデリゲート間でもキャストできませんが、VB.NETではできることから、匿名デリゲート型に割り当てても問題がないという判断だと思われます。</p>

<h2>
<span id="糖衣構文" class="fragment"></span><a href="#%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87"><i class="fa fa-link"></i></a>糖衣構文</h2>

<p><code>fun</code>を省略して引数を左辺に記述できます。通常はこちらを使います。</p>

<table>
<tr>
<th>F# (funあり)</th>
<th>F# (funなし)</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc = fun x -&gt; x + 1
let add = fun x y -&gt; x + y
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc x = x + 1
let add x y = x + y
</pre></div></div></td>
</tr>
</table>

<p><code>fun</code>なしの方が便利です。最初に見せなかったのは、関数が値と同じように束縛されていることを示したかったためです。</p>

<h2>
<span id="fsi" class="fragment"></span><a href="#fsi"><i class="fa fa-link"></i></a>fsi</h2>

<p>F# Interactiveで色々な書き方を動作確認します。この手の簡単な確認にREPLは便利です。</p>

<table>
<tr>
<th>F# Interactive</th>
<th>JavaScript (Node.js)</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc = fun x -&gt; x + 1;;
inc 1;;
(inc 1);;
inc(1);;
(fun x -&gt; x + 1) 1;;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
inc = x =&gt; x + 1
inc(1)
(x =&gt; x + 1)(1)
</pre></div></div></td>
</tr>
</table>

<p>※ 最後の例は関数を束縛せずにインラインで使っています。<code>fun</code>を省略した構文では表現できません。</p>

<h2>
<span id="unit" class="fragment"></span><a href="#unit"><i class="fa fa-link"></i></a>unit</h2>

<p>C#での<code>void</code>に相当するのが<code>unit</code>です。値としては<code>()</code>と表現します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
void test1() {}
int test2() { return 1; }
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
function test1() {}
function test2() { return 1; }
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1() = ()
let test2() = 1
</pre></div></div></td>
</tr>
</table>

<p>ラムダ式などで書いてみます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Action test1 = () =&gt; {};
Func&lt;int&gt; test2 = () =&gt; 1;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1 = () =&gt; {};
let test2 = () =&gt; 1;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1 = fun () -&gt; ()
let test2 = fun () -&gt; 1
</pre></div></div></td>
</tr>
</table>

<p>変数（<code>test3</code>）と関数（<code>test4</code>）を比べてみます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int test3 = 0;
Func&lt;int&gt; test4 = () =&gt; 0;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test3 = 0;
let test4 = () =&gt; 0;
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test3 = 0
let test4() = 0
</pre></div></div></td>
</tr>
</table>

<h2>
<span id="ignore" class="fragment"></span><a href="#ignore"><i class="fa fa-link"></i></a>ignore</h2>

<p>F#では関数の戻り値を捨てると警告されます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Func&lt;int&gt; a = () =&gt; 1;
a();  // 警告なし
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = () =&gt; 1;
a();  // 警告なし
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a() = 1
a()  // 警告
</pre></div></div></td>
</tr>
</table>

<p>警告を抑えるため、<code>ignore</code>関数で明示的に無視します。C言語で<code>void</code>にキャストする流儀に似ています。</p>

<table>
<tr>
<th>C言語</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int a() { return 1; }
void test() { (void)a(); }
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a() = 1
ignore(a())
</pre></div></div></td>
</tr>
</table>

<p>※ gccには戻り値を無視したときに警告する <code>__attribute__((warn_unused_result))</code> があります。</p>

<h2>
<span id="パイプライン演算子" class="fragment"></span><a href="#%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E6%BC%94%E7%AE%97%E5%AD%90"><i class="fa fa-link"></i></a>パイプライン演算子</h2>

<p>引数と関数を分離するパイプライン演算子というものがあります。ネストした引数の括弧を外してフラットに記述するのに使います。戻り値の警告を受けて<code>ignore</code>を追加するときに便利です。</p>

<table>
<tr>
<th>F#</th>
<th>F# (右向き)</th>
<th>F# (左向き)</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
ignore(a())
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
a() |&gt; ignore
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
ignore &lt;| a()
</pre></div></div></td>
</tr>
</table>

<p>右向きのパイプライン演算子は、シェルのパイプのような感覚で関数の多重呼び出しに使えます。左向きはHaskellの<code>$</code>に似ていますが、連続して使うと<code>$</code>とは意味が変わるため（後述）、連続させるときは<code>&lt;&lt;</code>演算子による関数合成と併用します。</p>

<table>
<tr>
<th>F#</th>
<th>F# (右向き)</th>
<th>F# (左向き)</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
foo(bar(baz()))
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
() |&gt; baz |&gt; bar |&gt; foo
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
foo &lt;&lt; bar &lt;&lt; baz &lt;| ()
</pre></div></div></td>
</tr>
</table>

<p><code>&lt;|</code>を連続して使用すると、複数の引数を個別に適用する意味となります。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%d,%s"</span> <span class="o">&lt;|</span> <span class="mi">5</span> <span class="o">&lt;|</span> <span class="s">"abc"</span>
</pre></div>
</div>

<h2>
<span id="再帰関数" class="fragment"></span><a href="#%E5%86%8D%E5%B8%B0%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>再帰関数</h2>

<p>C#/JavaScriptでラムダ式を使わずに再帰で階乗を求めます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
class Test
{
  static int frac(int x)
  {
    return x &lt; 1 ? 1 : x * frac(x - 1);
  }
  static void Main()
  {
    Console.WriteLine(frac(5));
  }
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
function frac(x) {
  return x &lt; 1 ? 1 : x * frac(x - 1);
}
console.log(frac(5));
</pre></div></div></td>
</tr>
</table>

<p>これをラムダ式で書きます。C#では自分自身が参照できなくなるため、一度<code>null</code>で初期化するという小手先の技が必要となります。JavaScriptは参照が動的に処理されるため問題ありません。F#では自分自身を参照するために専用の<code>rec</code>キーワードが用意されています。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Func&lt;int, int&gt; frac = null;
frac = x =&gt;
  x &lt; 1 ? 1 : x * frac(x - 1);
Console.WriteLine(frac(5));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let frac = x =&gt;
  x &lt; 1 ? 1 : x * frac(x - 1);
console.log(frac(5));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let rec frac x =
  if x &lt; 1 then 1 else x * frac(x - 1)
printfn "%d" (frac 5)
</pre></div></div></td>
</tr>
</table>

<p>※ デフォルトで再帰可能になっていないのは、同名の変数で覆い隠すシャドウイングを考慮した言語設計のようです。F#の元になったOCamlについての記事を紹介します。</p>

<ul>
<li>
<a href="https://twitter.com/camlspotter" rel="nofollow noopener" target="_blank">@camlspotter</a>: <a href="http://d.hatena.ne.jp/camlspotter/20110509/1304933919" rel="nofollow noopener" target="_blank">OCaml の let と let rec はなぜ別扱いになっているのか、決定版、もしくは OCaml 暦十何年だったか忘れたけど仕事で Haskell を一年使ってみた - Oh, you `re no (fun _ → more)</a> 2011.05.09</li>
</ul>

<h2>
<span id="前方参照" class="fragment"></span><a href="#%E5%89%8D%E6%96%B9%E5%8F%82%E7%85%A7"><i class="fa fa-link"></i></a>前方参照</h2>

<p>一般論として用語を解説します。</p>

<p>パーサは上から下にコードを読み進めます。進行方向に沿って下が「前方」と表現されます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre>
     後方
1 aaaa↓
2 bbbb↓
3 cccc↓
     前方
</pre></div></div>

<p>前方で定義されている関数にアクセス（参照）することを「前方参照」と呼びます。下の例では<code>test()</code>が前方参照されています。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
class Test
{
  static void Main()
  {
    test();  // 前方参照
  }
  static void test()
  {
    Console.WriteLine("abc");
  }
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
test();  // 前方参照

function test() {
  console.log("abc");
}
</pre></div></div></td>
</tr>
</table>

<p>※ 直感的には「上が前」のように感じられるので注意が必要です。C言語の前方宣言は呼び出し元から見て「前方にある宣言」ではなく、「前方参照を可能にするための宣言」という意味だと解釈できます。</p>

<p>F#は前方参照ができません。他の言語でもラムダ式だけで記述すると似たような状況になりますが、それと同じだと考えてください。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
test();  // エラー
Action test = () =&gt;
  Console.WriteLine("abc");
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
test();  // エラー
let test = () =&gt;
  console.log("abc");
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
test()  // エラー
let test() = printfn "abc"
</pre></div></div></td>
</tr>
</table>

<p>F#に前方宣言はありません。必ず後方（上）で定義する必要があります。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Action test = () =&gt;
  Console.WriteLine("abc");
test();  // OK
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test = () =&gt;
  console.log("abc");
test()  // OK
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test() = printfn "abc"
test()  // OK
</pre></div></div></td>
</tr>
</table>

<p>これは強い制限のようにも感じられますが、コードを読んだり部分的に引用したりするときは、そこより上だけを見ておけば良いという利点があります。</p>

<h2>
<span id="相互再帰" class="fragment"></span><a href="#%E7%9B%B8%E4%BA%92%E5%86%8D%E5%B8%B0"><i class="fa fa-link"></i></a>相互再帰</h2>

<p>前方宣言はありませんが、相互に再帰する場合は特別な構文があります。</p>

<p>F#では<code>rec</code>と<code>and</code>を使います。C#ではラムダ式を使わなければ特に問題はなく、JavaScriptでは動的に参照されるためアロー関数式でも特に意識する必要はありません。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
void test1() { test2(); }
void test2() { test1(); }
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1 = () =&gt; test2();
let test2 = () =&gt; test1();
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let rec test1() = test2()
and test2() = test1()
</pre></div></div></td>
</tr>
</table>

<p>どうしても相互再帰が避けられないケースはありますが、その場合はクラスタとしてひとまとめに定義することが必要です。離して定義することはできません。</p>

<h2>
<span id="関数内関数" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E5%86%85%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>関数内関数</h2>

<p>C#ではクラス直下のメソッドと、メソッド内のラムダ式の書式が大きく異なります。</p>

<p>※ C# 7ではローカル関数という機能が追加され、この制限が緩和されます。</p>

<p>F#やJavaScriptでは関数の中でも関数が定義できます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
class Test
{
  static int inc1(int x)
  {
    return x + 1;
  }
  static void test()
  {
    Func&lt;int, int&gt; inc2 = x =&gt; x + 1;
    Console.WriteLine(inc1(1));
    Console.WriteLine(inc2(1));
  }
  static void Main()
  {
    test();
  }
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
function inc1(x) {
  return x + 1;
}
function test() {
  function inc2(x) {
    return x + 1;
  }
  console.log(inc1(1));
  console.log(inc2(1));
}
test();
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc1 x = x + 1
let test() =
  let inc2 x = x + 1
  printfn "%d" (inc1 1)
  printfn "%d" (inc2 1)
test()
</pre></div></div></td>
</tr>
</table>

<h1>
<span id="カリー化" class="fragment"></span><a href="#%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96"><i class="fa fa-link"></i></a>カリー化</h1>

<p>関数型で必ず話題になるカリー化を説明します。</p>

<p>※ とりあえずF#を使うだけなら必須というわけではありません。分かりにくければ飛ばしても構いません。</p>

<p>必要に応じて次の記事を参照すると良いでしょう。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/a0143daac77a205e7962" id="reference-45504b7e82a512f098d8">カリー化と部分適用（JavaScriptとHaskell）</a> 2014.10.15</li>
</ul>

<h2>
<span id="糖衣構文-1" class="fragment"></span><a href="#%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87-1"><i class="fa fa-link"></i></a>糖衣構文</h2>

<p>以下の3種類はすべて同じ意味です。</p>

<ol>
<li><code>let add = fun x -&gt; fun y -&gt; x + y</code></li>
<li><code>let add = fun x y -&gt; x + y</code></li>
<li><code>let add x y = x + y</code></li>
</ol>

<p>2と3は1の糖衣構文です。1をC#/JavaScriptに翻訳して呼び出してみます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Func&lt;int, Func&lt;int, int&gt;&gt; add =
    x =&gt; y =&gt; x + y;
Console.WriteLine(add(1)(2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let add = x =&gt; y =&gt; x + y;
console.log(add(1)(2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let add = fun x -&gt; fun y -&gt; x + y
printfn "%d" (add 1 2)
</pre></div></div></td>
</tr>
</table>

<p>ラムダ式がネストしています。初見では分かりにくいですが、括弧を付けてみます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Func&lt;int, Func&lt;int, int&gt;&gt; add =
    x =&gt; (y =&gt; x + y);
Console.WriteLine(add(1)(2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let add = x =&gt; (y =&gt; x + y);
console.log(add(1)(2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let add = fun x -&gt; (fun y -&gt; x + y)
printfn "%d" (add 1 2)
</pre></div></div></td>
</tr>
</table>

<p>JavaScriptでは<code>function</code>で記述した方が分かりやすいかもしれません。</p>

<div class="code-frame" data-lang="js">
<div class="code-lang"><span class="bold">JavaScript</span></div>
<div class="highlight"><pre>
<span class="kd">let</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">));</span>
</pre></div>
</div>

<h2>
<span id="部分適用" class="fragment"></span><a href="#%E9%83%A8%E5%88%86%E9%81%A9%E7%94%A8"><i class="fa fa-link"></i></a>部分適用</h2>

<p>C#/JavaScriptでは引数を1つずつ渡していますが（<code>add(1)(2)</code>）、引数を片方だけ渡すこともできます。こうして得られた中間的な関数に残りの引数を渡すと最終的な結果が得られます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var inc = add(1);
Console.WriteLine(inc(2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc = add(1);
console.log(inc(2));
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let inc = add 1
printfn "%d" (inc 2)
</pre></div></div></td>
</tr>
</table>

<p>このように引数を途中まで渡して関数を得ることを部分適用と呼びます。部分適用できるように関数の中に関数を入れる形式をカリー化と呼びます。</p>

<p>※ 部分適用が誤ってカリー化と呼ばれることがあるので注意が必要です。</p>

<p>F#では冒頭で挙げた1～3のすべてがカリー化された関数で部分適用できます。カリー化されない関数を定義するには、引数をコンマで区切りタプルとします。引数をタプルで取る関数でもラムダ式でラップすれば擬似的に部分適用は可能です。</p>

<table>
<tr>
<th>F# (カリー化)</th>
<th>F# (非カリー化)</th>
<th>C# (非カリー化)</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let add x y = x + y
let inc = add 1
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let add(x, y) = x + y
let inc = fun y -&gt; add(1, y)
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Func&lt;int, int, int&gt; add = (x, y) =&gt; x + y;
Func&lt;int, int&gt; inc = y =&gt; add(1, y);
</pre></div></div></td>
</tr>
</table>

<p>最初の方で.NETのメソッドの呼び方がネイティブ関数とは異なると述べましたが、引数がタプルとして扱われカリー化されていないためです。</p>

<h1>
<span id="配列" class="fragment"></span><a href="#%E9%85%8D%E5%88%97"><i class="fa fa-link"></i></a>配列</h1>

<p>C#ではサイズを指定して配列を作るとゼロで初期化されます。JavaScriptではTypedArrayで同様の処理が可能です。F#では専用の関数を使用します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var a = new int[5];
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = new Int32Array(5);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = Array.zeroCreate&lt;int&gt; 5
</pre></div></div></td>
</tr>
</table>

<p>初期値を指定して配列を作成する方法を示します。F#では要素の区切りはセミコロンなのに注意が必要です（コンマ区切りはタプルを意味するため）。また、F#では配列アクセスで添字の前にドットが必要です。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var a = new[] {1, 2, 3, 4};
Console.WriteLine(a[2]);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var a = [1, 2, 3, 4];
console.log(a[2]);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = [|1; 2; 3; 4|]
printfn "%d" a.[2]
</pre></div></div></td>
</tr>
</table>

<p>F#では配列をスライスできます。末尾の指定方法がJavaScriptとF#では異なるのに注意します。C#では言語サポートがないため地道にコピーします。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var b = new int[2];
Array.Copy(a, 2, b, 0, 2);
</pre></div></div></td>
<td>
<div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = a.slice(2, 4);
</pre></div></div>※ 4は末尾の添字+1</td>
<td>
<div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = a.[2..3]
</pre></div></div>※ 3は末尾の添字</td>
</tr>
</table>

<p>JavaScriptとF#は文字列の切り出にもスライスが使用可能です。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
"abcde".Substring(2, 2);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
"abcde".slice(2, 4);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
"abcde".[2..3]
</pre></div></div></td>
</tr>
</table>

<h1>
<span id="ループ" class="fragment"></span><a href="#%E3%83%AB%E3%83%BC%E3%83%97"><i class="fa fa-link"></i></a>ループ</h1>

<p>F#には<code>while</code>と<code>for</code>はありますが、<code>continue</code>と<code>break</code>はありません。再帰で書き直す方法を覚えておくと潰しが効きます。考え方としてはループ変数を引数に見立てて、条件を満たせば再帰的に自分を呼び出します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var r = new Random();
for (int i = 0; i &lt; 10; i++)
{
  var v = r.Next(10);
  Console.WriteLine(v);
  if (v &gt; 5) break;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
for (let i = 0; i &lt; 10; i++) {
  let v = (Math.random() * 10) | 0;
  console.log(v);
  if (v &gt; 5) break;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let r = new Random()
let rec loop i =
  if i &lt; 10 then
    let v = r.Next(10)
    printfn "%d" v
    if not(v &gt; 5) then
      loop (i + 1)
loop 0
</pre></div></div></td>
</tr>
</table>

<p>※ 再帰呼び出しは<code>continue</code>に相当して、明示的に<code>continue</code>を書かないとループから抜けてしまうと解釈できます。ただし<code>continue</code>と違って後続の処理が打ち切られるわけではないため、再帰呼び出しの後に処理が来ないように注意する必要があります。後に処理が来ない再帰を<strong>末尾再帰</strong>と呼びます。</p>

<p>再帰を使わずに<code>while</code>で無理やり実装することもできます。うまく書けないときはこの手で逃げることがあるかもしれません。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
var r = new Random();
int i = 0, v = 0;
while (i &lt; 10 &amp;&amp; !(v &gt; 5))
{
  v = r.Next(10);
  Console.WriteLine(v);
  i++;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let i = 0, v = 0;
while (i &lt; 10 &amp;&amp; !(v &gt; 5)) {
  v = (Math.random() * 10) | 0;
  console.log(v);
  i++;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let r = new Random()
let mutable i, v = 0, 0
while i &lt; 10 &amp;&amp; not(v &gt; 5) do
  v &lt;- r.Next(10)
  printfn "%d" v
  i &lt;- i + 1
</pre></div></div></td>
</tr>
</table>

<p>※ この記事では取り上げませんが、F#にはループの代用となる様々な関数が用意されており、本来そちらを使うことが推奨されます。しかしそういったものがうまく適用できないときは、最終手段としてここで説明したような方法でどうにかすることもあるでしょう。</p>

<h2>
<span id="複雑な例" class="fragment"></span><a href="#%E8%A4%87%E9%9B%91%E3%81%AA%E4%BE%8B"><i class="fa fa-link"></i></a>複雑な例</h2>

<p>標準入力から文字列を読み取り、先頭から連続する数字だけを抜き出して表示する例を示します。C#では代入した値をそのまま評価できますが、F#ではできないため工夫が必要です。JavaScriptはNode.jsで示します。</p>

<div class="code-frame" data-lang="csharp">
<div class="code-lang"><span class="bold">C#</span></div>
<div class="highlight"><pre>
<span class="kt">string</span> <span class="n">line</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">line</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">())</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">line</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">Char</span><span class="p">.</span><span class="n">IsNumber</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">break</span><span class="p">;</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>

<div class="code-frame" data-lang="js">
<div class="code-lang"><span class="bold">JavaScript(Node.js)</span></div>
<div class="highlight"><pre>
<span class="kd">let</span> <span class="nx">isDigit</span> <span class="o">=</span> <span class="nx">ch</span> <span class="o">=&gt;</span> <span class="s2">"0"</span> <span class="o">&lt;=</span> <span class="nx">ch</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span> <span class="o">&lt;=</span> <span class="s2">"9"</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">loop</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">line</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="nx">line</span> <span class="o">=</span> <span class="k">yield</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isDigit</span><span class="p">(</span><span class="nx">line</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="k">break</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}();</span>
<span class="nx">loop</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="kd">let</span> <span class="nx">rl</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"readline"</span><span class="p">).</span><span class="nx">createInterface</span><span class="p">(</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">,</span> <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
<span class="nx">rl</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"line"</span><span class="p">,</span> <span class="nx">line</span> <span class="o">=&gt;</span> <span class="nx">loop</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">line</span><span class="p">));</span>
<span class="nx">rl</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"close"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">loop</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="kc">null</span><span class="p">));</span>
</pre></div>
</div>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">rec</span> <span class="n">loop</span><span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="nv">line</span> <span class="o">=</span> <span class="nn">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="bp">()</span>
  <span class="k">if</span> <span class="n">line</span> <span class="o">&lt;&gt;</span> <span class="k">null</span> <span class="k">then</span>
    <span class="k">let</span> <span class="nv">rec</span> <span class="n">loop2</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">line</span><span class="o">.</span><span class="n">Length</span> <span class="o">&amp;&amp;</span> <span class="nn">Char</span><span class="p">.</span><span class="n">IsNumber</span><span class="o">(</span><span class="n">line</span><span class="o">.[</span><span class="n">i</span><span class="o">])</span> <span class="k">then</span>
        <span class="n">loop2</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="n">line</span><span class="o">.[</span><span class="mi">0</span> <span class="o">..</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span>
    <span class="n">printfn</span> <span class="s">"%s"</span> <span class="o">(</span><span class="n">loop2</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">loop</span><span class="bp">()</span>
<span class="n">loop</span><span class="bp">()</span>
</pre></div>
</div>

<p>※ Windowsで標準入力読み切り型プログラムを終了させるには [Ctrl]+[Z] [Enter] と操作しますが、Node.jsでは [Ctrl]+[D] です。</p>

<p>Node.jsでの標準入力の扱いは次の記事を参考にしました。</p>

<ul>
<li>
<a href="http://qiita.com/hiroqn@github/items/c927bc97780c34eda562" id="reference-738fb68b7690aa464f96">Node.jsの標準入力と</a> 2013.10.03</li>
</ul>

<h1>
<span id="参照" class="fragment"></span><a href="#%E5%8F%82%E7%85%A7"><i class="fa fa-link"></i></a>参照</h1>

<p>F#では<code>mutable</code>の親戚のような参照という型があります。参照は<code>ref</code>というキーワードを指定するとその場でインスタンスが作られます。</p>

<p>※ C#で引数を参照で渡すための<code>ref</code>とは別物です。</p>

<p>値へのアクセスはプロパティによる方法と演算子による方法があります。演算子の方がよく使われます。<code>!</code> は参照剥がし（デリファレンス）演算子で、C#の否定演算子とは無関係です。参照への代入は <code>:=</code> です。</p>

<table>
<tr>
<th>C#</th>
<th>F# (mutable)</th>
<th>F# (参照・プロパティ)</th>
<th>F# (参照・演算子)</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int a = 1;
Console.WriteLine(a);
a = 2;
Console.WriteLine(a);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let mutable a = 1
printfn "%d" a
a &lt;- 2
printfn "%d" a
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = ref 1
printfn "%d" b.Value
b.Value &lt;- 2
printfn "%d" b.Value
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = ref 1
printfn "%d" !b
b := 2
printfn "%d" !b
</pre></div></div></td>
</tr>
</table>

<p>C#よりもC++で説明した方が分かりやすいかもしれません。比較の都合上、C++は参照ではなくポインタで示します。C#でもポインタは使えますが、1要素の配列で表現する方が簡単なのでその方法で示します。</p>

<table>
<tr>
<th>C++</th>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int *b = new int(1);
printf("%d\n", *b);
*b = 2;
printf("%d\n", *b);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
int[] b = new[] {1};
Console.WriteLine(b[0]);
b[0] = 2;
Console.WriteLine(b[0]);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = [1];
console.log(b[0]);
b[0] = 2;
console.log(b[0]);
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let b = ref 1
printfn "%d" !b
b := 2
printfn "%d" !b
</pre></div></div></td>
</tr>
</table>

<p>※ C++でも <code>*b = 2;</code> は <code>b[0] = 2;</code> に書き換えられます。</p>

<h1>
<span id="クロージャ" class="fragment"></span><a href="#%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3"><i class="fa fa-link"></i></a>クロージャ</h1>

<p>関数内関数から外のローカル変数にアクセスできます。これをレキシカルスコープと呼んで、変数への参照をキャプチャと表現します。キャプチャを伴った関数をクロージャと呼びます。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Action test1 = () =&gt; {
  var i = 0;
  Action test2 = () =&gt;
    Console.WriteLine(i);
  test2();
};
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1 = () =&gt; {
  let i = 0;
  let test2 = () =&gt;
    console.log(i);
  test2();
};
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1() =
  let i = 0
  let test2() =
    printfn "%d" i
  test2()
</pre></div></div></td>
</tr>
</table>

<p>上の例ではC#やJavaScriptでは値が変更可能な変数をキャプチャしていますが、F#では<code>mutable</code>な変数はキャプチャできません。Javaでもラムダ式（匿名クラス）から<code>final</code>を指定した変数しか参照できないのと似ています。</p>

<p>※ Java 8では初期化以外で値を触らなければ事実上の<code>final</code>としてコンパイルが通ります。下のコードでは意図的に<code>i</code>の値を変更しています。</p>

<table>
<tr>
<th>F#</th>
<th>Java 8</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1() =
  let mutable i = 0
  let test2() =
    printfn "%d" i  // エラー
  i &lt;- 1
  test2()
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
void test1() {
  int i = 0;
  Runnable test2 = () -&gt;
    System.out.println(i);  // エラー
  i = 1;
  test2.run();
}
</pre></div></div></td>
</tr>
</table>

<p>F#では参照で回避します。Javaでは<code>final</code>を付け、中身を変更可能にするため配列で包む回避策があります。</p>

<table>
<tr>
<th>F#</th>
<th>Java 8</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let test1() =
  let i = ref 0
  let test2() =
    printfn "%d" !i
  i := 1
  test2()
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
void test1() {
  final int i[] = {0};
  Runnable test2 = () -&gt;
    System.out.println(i[0]);
  i[0] = 1;
  test2.run();
}
</pre></div></div></td>
</tr>
</table>

<h2>
<span id="理由" class="fragment"></span><a href="#%E7%90%86%E7%94%B1"><i class="fa fa-link"></i></a>理由</h2>

<p>ローカルの<code>mutable</code>変数はスタックに確保されるのに対し、参照の実体はヒープに確保されます。スタックに確保された変数はスコープアウト時に破棄されます。しかしクロージャにキャプチャされた変数の寿命はスコープに縛られないため、参照によりヒープに確保して解放はGCに任せることで、スコープアウト問題を回避しています。</p>

<p>C#ではキャプチャされる変数はコンパイラが自動的に扱い方を変えるためこの制限がありません。F#では敢えてエラーにしていると思われます。</p>

<h1>
<span id="クラス" class="fragment"></span><a href="#%E3%82%AF%E3%83%A9%E3%82%B9"><i class="fa fa-link"></i></a>クラス</h1>

<p>F#とC#で構文がかなり違いますが、<code>protected</code>や入れ子にされた型がない以外はほぼ同じことが表現できます。JavaScriptは色々な書き方ができますが、ここではF#との対比の都合上<code>class</code>を使わない古い書き方で示します。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
class Num
{
  private int num = 0;
  public void Next()
  {
    Console.WriteLine(++num);
  }
}
class Test
{
  static void Main()
  {
    var n = new Num();
    for (int i = 0; i &lt; 5; i++)
      n.Next();
  }
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
function Num() {
  this.num = 0;
  this.Next = () =&gt;
    console.log(++this.num);
}
let n = new Num();
for (let i = 0; i &lt; 5; i++)
  n.Next();
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
type Num() =
  let mutable num = 0
  member this.Next() =
    num &lt;- num + 1
    printfn "%d" num
let n = new Num()
for i = 0 to 4 do
  n.Next()
</pre></div></div></td>
</tr>
</table>

<p>F#でアクセス制御を省略したときのデフォルトは、<code>let</code>が<code>private</code>、<code>member</code>が<code>public</code>となります。<code>type</code>名の後の<code>()</code>はコンストラクタの引数を表しています。JavaScriptは関数の引数がそのままコンストラクタの引数として使われていて、F#と書き方が似ていることに注目してください。</p>

<p>F#ではインスタンスを生成するときの<code>new</code>を省略できます。以後は省略します。</p>

<ul>
<li>
<code>new Num()</code> ⇔ <code>Num()</code>
</li>
</ul>

<p>※ <code>IDisposable</code>を実装したクラスでは<code>new</code>を省略すると警告されます。個人的にはデフォルトで省略して、警告されたら付けるという運用をしています。</p>

<h2>
<span id="コンストラクタ" class="fragment"></span><a href="#%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF"><i class="fa fa-link"></i></a>コンストラクタ</h2>

<p>コンストラクタで引数を処理する例を示します。JavaScriptで引数をそのままキャプチャしているのに注目してください。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
class Num
{
  private int num = 0;
  public Num(int n)
  {
    num = n;
  }
  public void Next()
  {
    Console.WriteLine(++num);
  }
}
class Test
{
  static void Main()
  {
    var n = new Num(5);
    for (int i = 0; i &lt; 5; i++)
      n.Next();
  }
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
function Num(num) {
  this.Next = () =&gt;
    console.log(++num);
}
let n = new Num(5);
for (let i = 0; i &lt; 5; i++)
  n.Next();
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
type Num(n) =
  let mutable num = n
  member this.Next() =
    num &lt;- num + 1
    printfn "%d" num
let n = Num 5
for i = 0 to 4 do
    n.Next()
</pre></div></div></td>
</tr>
</table>

<h2>
<span id="クロージャと比較" class="fragment"></span><a href="#%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%81%A8%E6%AF%94%E8%BC%83"><i class="fa fa-link"></i></a>クロージャと比較</h2>

<p>クロージャをクラスの代わりに使って比較してみます。F#は一旦参照で受けるため冗長になっていますが、C#やJavaScriptはその必要がないため単純です。JavaScriptとF#はクラスの書き方とよく似ているのに注目してください。</p>

<table>
<tr>
<th>C#</th>
<th>JavaScript</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
Func&lt;int, Action&gt; Num = num =&gt;
  () =&gt; Console.WriteLine(++num);
var next = Num(5);
for (int i = 0; i &lt; 5; i++)
  next();
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
function Num(num) {
  return () =&gt;
    console.log(++num);
}
let next = Num(5);
for (let i = 0; i &lt; 5; i++)
  next();
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let Num(n) =
  let num = ref n
  fun () -&gt;
    num := !num + 1
    printfn "%d" !num
let next = Num 5
for i = 0 to 4 do
  next()
</pre></div></div></td>
</tr>
</table>

<h1>
<span id="多態" class="fragment"></span><a href="#%E5%A4%9A%E6%85%8B"><i class="fa fa-link"></i></a>多態</h1>

<h2>
<span id="サブクラスによるオーバーライド" class="fragment"></span><a href="#%E3%82%B5%E3%83%96%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E3%82%88%E3%82%8B%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89"><i class="fa fa-link"></i></a>サブクラスによるオーバーライド</h2>

<p>数字と足し算のAST（抽象構文木）の例を示します。JavaScriptは継承ではなくダックタイピングで実装します。</p>

<div class="code-frame" data-lang="csharp">
<div class="code-lang"><span class="bold">C#</span></div>
<div class="highlight"><pre>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Val</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">abstract</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Num</span> <span class="p">:</span> <span class="n">Val</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">Num</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">num</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">num</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Add</span> <span class="p">:</span> <span class="n">Val</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">Val</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">Add</span><span class="p">(</span><span class="n">Val</span> <span class="n">a</span><span class="p">,</span> <span class="n">Val</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">b</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="n">Value</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">Value</span> <span class="p">+</span> <span class="n">b</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">expr</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Num</span><span class="p">(</span><span class="m">2</span><span class="p">),</span> <span class="k">new</span> <span class="n">Num</span><span class="p">(</span><span class="m">3</span><span class="p">));</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>

<div class="code-frame" data-lang="js">
<div class="code-lang"><span class="bold">JavaScript</span></div>
<div class="highlight"><pre>
<span class="kd">function</span> <span class="nx">Num</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s2">"Value"</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">get</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">num</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s2">"Value"</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">get</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Value</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">expr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Add</span><span class="p">(</span><span class="k">new</span> <span class="nx">Num</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="k">new</span> <span class="nx">Num</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">expr</span><span class="p">.</span><span class="nx">Value</span><span class="p">);</span>
</pre></div>
</div>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="o">[&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;]</span>
<span class="k">type</span> <span class="nc">Val</span><span class="bp">()</span> <span class="o">=</span>
  <span class="k">abstract</span> <span class="n">Value</span><span class="o">:</span> <span class="n">int</span>
<span class="k">type</span> <span class="nc">Num</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">inherit</span> <span class="n">Val</span><span class="bp">()</span>
  <span class="k">override</span> <span class="n">this</span><span class="p">.</span><span class="nf">Value</span> <span class="o">=</span> <span class="n">num</span>
<span class="k">type</span> <span class="nc">Add</span><span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">Val</span><span class="o">,</span> <span class="n">b</span><span class="o">:</span> <span class="n">Val</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">inherit</span> <span class="n">Val</span><span class="bp">()</span>
  <span class="k">override</span> <span class="n">this</span><span class="p">.</span><span class="nf">Value</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">Value</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">Value</span>
<span class="k">let</span> <span class="nv">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="o">(</span><span class="n">Num</span> <span class="mi">2</span><span class="o">,</span> <span class="n">Num</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">printfn</span> <span class="s">"%d"</span> <span class="n">expr</span><span class="o">.</span><span class="n">Value</span>
</pre></div>
</div>

<h2>
<span id="判別共用体" class="fragment"></span><a href="#%E5%88%A4%E5%88%A5%E5%85%B1%E7%94%A8%E4%BD%93"><i class="fa fa-link"></i></a>判別共用体</h2>

<p>F#には多態を簡潔に表現する判別共用体というものがあります。クラスごとの評価関数を個別にオーバーライドするのではなく、一箇所にまとめて書くスタイルです。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">type</span> <span class="nc">Val</span> <span class="o">=</span>
<span class="o">|</span> <span class="n">Num</span> <span class="k">of</span> <span class="n">int</span>
<span class="o">|</span> <span class="n">Add</span> <span class="k">of</span> <span class="n">Val</span> <span class="o">*</span> <span class="n">Val</span>

<span class="k">let</span> <span class="nv">rec</span> <span class="n">eval</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="n">Num</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">num</span>
<span class="o">|</span> <span class="n">Add</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">eval</span> <span class="n">a</span> <span class="o">+</span> <span class="n">eval</span> <span class="n">b</span>

<span class="k">let</span> <span class="nv">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="o">(</span><span class="n">Num</span> <span class="mi">2</span><span class="o">,</span> <span class="n">Num</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">printfn</span> <span class="s">"%d"</span> <span class="o">(</span><span class="n">eval</span> <span class="n">expr</span><span class="o">)</span>
</pre></div>
</div>

<p>判別共用体がうまくハマるパターンではものすごく簡潔になります。</p>

<p>JavaScriptで雰囲気を真似た例を示します。C#では冗長になるため省略します。</p>

<div class="code-frame" data-lang="js">
<div class="code-lang"><span class="bold">JavaScript</span></div>
<div class="highlight"><pre>
<span class="kd">function</span> <span class="nx">Num</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">num</span> <span class="o">=</span> <span class="nx">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">Num</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">num</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">Add</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">expr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Add</span><span class="p">(</span><span class="k">new</span> <span class="nx">Num</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="k">new</span> <span class="nx">Num</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nx">expr</span><span class="p">));</span>
</pre></div>
</div>

<h1>
<span id="資料" class="fragment"></span><a href="#%E8%B3%87%E6%96%99"><i class="fa fa-link"></i></a>資料</h1>

<p>今回と同じような視点の記事を紹介します。</p>

<p>この記事の元になった記事です。C#的なオブジェクト指向構文を中心にまとめています。</p>

<ul>
<li>
<a href="http://d.hatena.ne.jp/n7shi/20090722" rel="nofollow noopener" target="_blank">C#プログラマのためのF#入門</a> 2009.07.22</li>
</ul>

<p>限定された範囲内でC#をF#に変換するトランスレータです。JavaScriptで実装されているため、ブラウザ上で動きます。</p>

<ul>
<li>
<a href="http://7shi.bitbucket.org/cs2fs/" rel="nofollow noopener" target="_blank">C# to F# translator</a> 2015.08.01</li>
</ul>

<p>C#とF#との対比記事です。引用されているF# Tutorialはプロジェクト作成のときに選択できます。</p>

<ul>
<li>
<a href="https://twitter.com/neuecc" rel="nofollow noopener" target="_blank">@neuecc</a>: <a href="http://neue.cc/2009/11/09_214.html" rel="nofollow noopener" target="_blank">F# TutorialをC#と比較しながらでF#を学ぶ</a> 2009.11.09</li>
</ul>
<div class="hidden"><form class="js-task-list-update" action="/7shi/items/ff746903680ae8d0d7ce" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="_method" value="patch" /><input type="hidden" name="authenticity_token" value="7QwUq+3Iwbuw/b5r/tSyDNoP0bBP2/9j0K+B70fZmUiDjo/zdub48E8uC3eOIQxVukj1A9gfpZTscYgUpteXjg==" /><input type="hidden" name="updated_at_confirmation_in_unixtime" id="updated_at_confirmation_in_unixtime" value="1486633511" class="js-task-list-updated-at" /><textarea name="raw_body" id="raw_body" class="js-task-list-field">
C#やJavaScript（ES2015）と比較しながらF#の文法を説明します。手続型の延長線上で取っ掛かりをつかむことを目的とします。関数型については深追いしません。

* とりあえず手続型的な発想でも構わないので、F#を使ってみます。
* 関数型特有の概念の説明には重点を置きませんが、その導入になるようには意識します。
* 一気に関数型に飛ばないで、ベターC#として慣れていくような入り方を目指します。
* 関数型の理解を深めるのは慣れてからでも遅くないというスタンスです。

この記事は以前開催していた[F#入門](https://connpass.com/series/361/)のテキストを改訂したものです。

この記事には姉妹編があります。

* [Haskellで学ぶF#入門](http://qiita.com/7shi/items/1d3750ba17f5a88b8405) 2017.01.11

F#を手っ取り早く試すために、私が常用している環境を紹介します。

* [F#開発環境の紹介](http://qiita.com/7shi/items/5fc7d6477d96bbd7a71d) 2016.12.30

# F#について

F#の構文は見慣れないものだと思います。この記事ではC#/JavaScriptと比較しながら構文に慣れることに重点を置きます。

## 背景

F#が分かりにくいと感じる原因は、主に以下の2種類ではないでしょうか。

1. 構文の異質さ（C系言語などと比較して）
2. 関数型の考え方

今回は前者の壁に的を絞ります。両者は完全に分離しているわけではないため、後者の領域も多少は言及します。個人的にはF#は構文が簡潔で短く書けるのが良いと思っています。触り始めの頃は関数型のことはあまり意識しませんでした。

## 位置付け

F#はC#と同様に.NET Frameworkで動く言語です。クラスを定義したり使ったりなど、基本的にはC#でできるのとほぼ同じことができます。

※ これは大雑把な説明で、細かい点で違いはあります（`protected`や入れ子にされた型など）。

それに対してJavaScriptは出自が異なりますが、C#よりもJavaScriptで説明した方が分かりやすいケースもあるため、説明に取り入れました。

# ハローワールド

※ 横幅の関係上、インデントはスペース2つとします。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
using System;

class Program
{
  static void Main()
  {
    Console.WriteLine(&quot;hello&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
console.log(&quot;hello&quot;);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;hello&quot;
&lt;/pre&gt;または&lt;pre&gt;
open System
Console.WriteLine &quot;hello&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

* C#はMainメソッドが必須で、クラスで包む必要があります。簡単のため以後の例では省略します。
* JavaScriptとF#はクラスやMainで包む必要がありません。
* F#はセミコロンが必要ありません。（JavaScriptも省略可能）
* F#では引数を`()`で囲む必要がありません。（付けても動きます）
* F#の`open`はC#の`using`に相当します。以後の例では省略します。

## printf/printfn

F#の`printf`/`printfn`は`open`も何もなくいきなり使える標準の出力用関数です。

```fsharp:F#
printf &quot;hello\n&quot;
printfn &quot;hello&quot;
```

関数名の接尾辞`n`は`&quot;\n&quot;`と同様に New line に由来して、改行を意味します。

複数の引数はコンマではなくスペースで区切ります。（詳細は次のセクションで解説します）

```fsharp:F#
printfn &quot;%d&quot; 1
```

`printf`はコンパイラがフォーマット文字列を認識して、引数の型をチェックします。

```fsharp:F#
printfn &quot;%d&quot; &quot;abc&quot;  // エラー
printfn &quot;%s&quot; 0      // エラー
```

# 複数の引数

F#では複数の引数の扱い方が二系統あり、F#ネイティブの関数と.NETのメソッドとで異なります。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Console.WriteLine(&quot;{0} {1}”,
  1 + 1, Math.Sqrt(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
console.log(1 + 1, Math.sqrt(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d %f&quot; (1 + 1) (sqrt 2.)
&lt;/pre&gt;または&lt;pre&gt;
Console.WriteLine(&quot;{0} {1}&quot;,
  1 + 1, Math.Sqrt 2.)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ F#の2.は2.0のことで、浮動小数点数であることを示します。（後述）

## F#ネイティブの関数

複数の引数はコンマではなくスペースで区切ります。

```fsharp:F#
printfn &quot;%d&quot; 1
```

コンマを付けると警告されてうまく動きません。（後述のタプルとして扱われます）

```fsharp:F#
printfn &quot;%d&quot;, 1  // 警告され文字も出力されない
```

括弧で囲む必要はありません。付けるとエラーになります。

```fsharp:F#
printfn(&quot;%d&quot; 1)   // エラー
printfn(&quot;%d&quot;, 1)  // エラー
```

引数で計算や関数呼び出しを行う場合、引数としてまとめるため括弧で囲む必要があります。

```fsharp:F#（再掲）
printfn &quot;%d %f&quot; (1 + 1) (sqrt 2.)
```

## .NETのメソッド

タプルと呼ばれる複数の値を組み合わせた型として扱われます。C#と同じスタイルで、引数はコンマで区切って括弧で囲みます。

```fsharp:F#
Console.WriteLine(&quot;{0}&quot;, 1)
```

括弧を省略すると警告されてうまく動きません。

```fsharp:F#
Console.WriteLine &quot;{0}&quot;, 1  // 警告され実行時例外
```

.NETのメソッドでも1引数の場合は括弧が省略可能です。

```fsharp:F#
Console.WriteLine &quot;hello&quot;
```

以後の例では、F#はネイティブの関数（`printfn`など）があれば、.NETのメソッド（`Console.WriteLine`など）よりも優先して使用します。

## 数値型のキャスト

F#では数値型を自動的にキャストしてくれないため`sqrt(2)`はエラーになります。
C#/JavaScriptから見ると不親切ですが、型推論を優先するための言語設計です。

浮動小数点数型はC#とは型名が異なるため注意が必要です。

C#|F#
----|----
float|float32
double|float

倍精度が浮動小数点数の基本で、単精度がオプショナルという解釈だと思われます。

## おまけ

LISPを知っていれば、最上位の括弧が省略されていると考えればしっくり来るかもしれません。括弧で囲んでも動きます。

```fsharp:F#
(printfn &quot;%f&quot; (sqrt 2.))
```

# 変数

F#の変数はデフォルトで再代入できないという特徴があります。そのことについての説明は後に回して、まずは単純に変数を定義するケースを取り上げます。

変数は`let`で定義します。型推論されるため、C#の`var`に相当します。JavaScriptでは`var`は関数スコープとなるため、ES2015で追加されたブロックスコープの`let`に相当します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var a = 1;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

型を明示的に指定する方法もあります。JavaScriptはasm.jsで型で示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int a = 1;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1 | 0;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a: int = 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#では可能な限り型推論に任せるスタイルを推奨します。

## 束縛

F#はデフォルトでは変数に入れた値は変更できません。変数と値の結び付きが強く、「代入」ではなく「束縛」と表現します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
const int a = 1;
Console.WriteLine(a);
a = 2;  // エラー
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
const a = 1;
console.log(a);
a = 2;  // エラー
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1
printfn &quot;%d&quot; a
a = 2  // 警告（代入ではなく比較）
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#では`=`と`==`を書き分けずにどちらも`=`です。`let`以外の`=`は比較として扱われます。

F#で値が変更できるようにするには`mutable`を付けます。値の変更には`&lt;-`を使います。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int a = 1;
Console.WriteLine(a);
a = 2;
Console.WriteLine(a);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1;
console.log(a);
a = 2;
console.log(a);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let mutable a = 1
printfn &quot;%d&quot; a
a &amp;#60;- 2
printfn &quot;%d&quot; a
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`mutable`を付けずに宣言した変数に再代入する方法はありません。

## 複数の変数定義

複数の変数を一度に定義する書式を示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int x = 1, y = 2;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let x = 1, y = 2;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let x, y = 1, 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ C#では`var`を使うと複数の変数を一度に定義できません。

F#の書式は括弧で囲めば数学に近くなり、座標の表記に似たものだと理解できます。括弧の有無で意味は変わりません。

```fsharp:F#
let (x, y) = (1, 2)
```

# F# Interactive

ちょっとした実験は対話的に実行した方が便利です。F# Interactive (fsi) と呼ばれるREPLがあります。

Windows では `fsi.exe` ですが、Mono 環境では `fsharpi` コマンドで呼び出します。

fsiではセミコロンを2つ付けると、評価されて値が表示されます。

```fsharp:fsi
&gt; let a=1;;
val a : int = 1
```

※ `val`は値（value）の意味です。

変数の値を見るには変数名だけでOKです。

```fsharp:fsi
&gt; a;;
val it : int = 1
```

itは直前に評価された値が束縛されている変数で「それ（it）」の意味です。

```fsharp:fsi
&gt; it;;
val it : int = 1
```

`;;`を付け忘れると複数行入力として扱われます。次の行で付ければ評価されます。

```fsharp:fsi
&gt; a
- ;;
```

電卓としても使えます。

```fsharp:fsi
&gt; 1+1;;
val it : int = 2
```

`let`なしの`=`が比較になっているのを確認します。

```fsharp:fsi
&gt; a=1;;
val it : bool = true
&gt; a=2;;
val it : bool = false
```

等しくないのを表すのは`&lt;&gt;`です。

```fsharp:fsi
&gt; a&lt;&gt;1;;
val it : bool = false
```

終了は`#q;;`と入力します。

```fsharp:fsi
&gt; #q;;
```

# 条件式

`if`は構文が少し違うだけで基本的に同じです。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
if (a == 1)
  Console.WriteLine(&quot;1&quot;);
else
  Console.WriteLine(&quot;?&quot;);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
if (a == 1)
  console.log(&quot;1&quot;);
else
  console.log(&quot;?&quot;);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
if a = 1 then
  printfn &quot;1&quot;
else
  printfn &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## ブロック

F#はインデントでブロックが構成されるので、C#のように複文での中括弧に相当するものはありません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
if (a == 1)
{
  Console.WriteLine(&quot;1&quot;);
  Console.WriteLine(&quot;!&quot;);
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
if (a == 1) {
  console.log(&quot;1&quot;);
  console.log(&quot;!&quot;);
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
if a = 1 then
  printfn &quot;1&quot;
  printfn &quot;!&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 三項演算子

F#の`if`はそのまま三項演算子としても使えます。（`if`は文ではなく式のため）

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var b = a == 1 ? 2 : 0;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = a == 1 ? 2 : 0;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = if a = 1 then 2 else 0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 複合技

F#では最後に評価された値が返されるため、処理と代入を混ぜることができます。これは慣れると便利な技です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int b;
if (a == 1)
{
  Console.WriteLine(&quot;1&quot;);
  b = 2;
}
else
{
  Console.WriteLine(&quot;?&quot;);
  b = 0;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b;
if (a == 1) {
  console.log(&quot;1&quot;);
  b = 2;
} else {
  console.log(&quot;?&quot;);
  b = 0;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b =
  if a = 1 then
    printfn &quot;1&quot;
    2
  else
    printfn &quot;?&quot;
    0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## タプル

条件分岐の結果、複数の値を代入するような処理を一気に書けます。うまくハマるととても簡潔になります。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int x, y;
if (a == 1)
{
  x = 1;
  y = 2;
}
else
{
  x = 3;
  y = 4;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let x, y;
if (a == 1) {
  x = 1;
  y = 2;
} else {
  x = 3;
  y = 4;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let x, y = if a = 1 then 1, 2 else 3, 4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

この構文が分かりにくければ、括弧を付けて考えると良いかもしれません。

```fsharp:F#
let (x, y) = if a = 1 then (1, 2) else (3, 4)
```

# 関数

説明の都合上、F#は冗長な構文から先に紹介します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
class Test
{
  static int inc(int x)
  {
    return x + 1;
  }
  static int add(int x, int y)
  {
    return x + y;
  }
  static void Main()
  {
    Console.WriteLine(inc(1));
    Console.WriteLine(add(1, 2));
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
function inc(x) {
  return x + 1;
}
function add(x, y) {
  return x + y;
}
console.log(inc(1));
console.log(add(1, 2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let inc = fun x -&gt; x + 1
let add = fun x y -&gt; x + y
printfn &quot;%d&quot; (inc 1)
printfn &quot;%d&quot; (add 1 2)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#は変数の束縛と同じ構文で、関数が束縛されています。

```fsharp:F#（対比）
let inc = 0
let inc = fun x -&gt; x + 1
```

右辺の `fun x -&gt; x + 1` は左辺に束縛されて名前が付くことから、単体では名前が無く、無名関数などと呼ばれます。

## ラムダ式

F#の書き方は、C#のラムダ式やJavaScriptのアロー関数式に相当します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Func&amp;#60;int, int&gt; inc = x =&gt; x + 1;
Func&amp;#60;int, int, int&gt; add = (x, y) =&gt; x + y;
Console.WriteLine(inc(1));
Console.WriteLine(add(1, 2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let inc = x =&gt; x + 1;
let add = (x, y) =&gt; x + y;
console.log(inc(1));
console.log(add(1, 2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let inc = fun x -&gt; x + 1
let add = fun x y -&gt; x + y
printfn &quot;%d&quot; (inc 1)
printfn &quot;%d&quot; (add 1 2)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

C#の`Func`は冗長ですが、型推論が効かないため省略できません。

```csharp:C#
var inc = (int x) =&gt; x + 1;  // エラー
```

ちなみにVB.NETでは匿名デリゲート型に型推論されます。

```vbnet:VB.NET
Dim inc = Function(x%) x + 1
```

※ C#では引数や戻り値の型が同じデリゲート間でもキャストできませんが、VB.NETではできることから、匿名デリゲート型に割り当てても問題がないという判断だと思われます。

## 糖衣構文

`fun`を省略して引数を左辺に記述できます。通常はこちらを使います。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;F# (funあり)&lt;/th&gt;&lt;th&gt;F# (funなし)&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
let inc = fun x -&gt; x + 1
let add = fun x y -&gt; x + y
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let inc x = x + 1
let add x y = x + y
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`fun`なしの方が便利です。最初に見せなかったのは、関数が値と同じように束縛されていることを示したかったためです。

## fsi

F# Interactiveで色々な書き方を動作確認します。この手の簡単な確認にREPLは便利です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;F# Interactive&lt;/th&gt;&lt;th&gt;JavaScript (Node.js)&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
let inc = fun x -&gt; x + 1;;
inc 1;;
(inc 1);;
inc(1);;
(fun x -&gt; x + 1) 1;;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
inc = x =&gt; x + 1
inc(1)
(x =&gt; x + 1)(1)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ 最後の例は関数を束縛せずにインラインで使っています。`fun`を省略した構文では表現できません。

## unit

C#での`void`に相当するのが`unit`です。値としては`()`と表現します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
void test1() {}
int test2() { return 1; }
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
function test1() {}
function test2() { return 1; }
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test1() = ()
let test2() = 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

ラムダ式などで書いてみます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Action test1 = () =&gt; {};
Func&amp;#60;int&gt; test2 = () =&gt; 1;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test1 = () =&gt; {};
let test2 = () =&gt; 1;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test1 = fun () -&gt; ()
let test2 = fun () -&gt; 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

変数（`test3`）と関数（`test4`）を比べてみます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int test3 = 0;
Func&amp;#60;int&gt; test4 = () =&gt; 0;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test3 = 0;
let test4 = () =&gt; 0;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test3 = 0
let test4() = 0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## ignore

F#では関数の戻り値を捨てると警告されます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Func&amp;#60;int&gt; a = () =&gt; 1;
a();  // 警告なし
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = () =&gt; 1;
a();  // 警告なし
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a() = 1
a()  // 警告
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

警告を抑えるため、`ignore`関数で明示的に無視します。C言語で`void`にキャストする流儀に似ています。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C言語&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int a() { return 1; }
void test() { (void)a(); }
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a() = 1
ignore(a())
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ gccには戻り値を無視したときに警告する `__attribute__((warn_unused_result))` があります。

## パイプライン演算子

引数と関数を分離するパイプライン演算子というものがあります。ネストした引数の括弧を外してフラットに記述するのに使います。戻り値の警告を受けて`ignore`を追加するときに便利です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;F#&lt;/th&gt;&lt;th&gt;F# (右向き)&lt;/th&gt;&lt;th&gt;F# (左向き)&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
ignore(a())
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
a() |&gt; ignore
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
ignore &amp;#60;| a()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

右向きのパイプライン演算子は、シェルのパイプのような感覚で関数の多重呼び出しに使えます。左向きはHaskellの`$`に似ていますが、連続して使うと`$`とは意味が変わるため（後述）、連続させるときは`&lt;&lt;`演算子による関数合成と併用します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;F#&lt;/th&gt;&lt;th&gt;F# (右向き)&lt;/th&gt;&lt;th&gt;F# (左向き)&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
foo(bar(baz()))
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
() |&gt; baz |&gt; bar |&gt; foo
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
foo &amp;#60;&amp;#60; bar &amp;#60;&amp;#60; baz &amp;#60;| ()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`&lt;|`を連続して使用すると、複数の引数を個別に適用する意味となります。

```fsharp:F#
printfn &quot;%d,%s&quot; &lt;| 5 &lt;| &quot;abc&quot;
```

## 再帰関数

C#/JavaScriptでラムダ式を使わずに再帰で階乗を求めます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
class Test
{
  static int frac(int x)
  {
    return x &amp;#60; 1 ? 1 : x * frac(x - 1);
  }
  static void Main()
  {
    Console.WriteLine(frac(5));
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
function frac(x) {
  return x &amp;#60; 1 ? 1 : x * frac(x - 1);
}
console.log(frac(5));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

これをラムダ式で書きます。C#では自分自身が参照できなくなるため、一度`null`で初期化するという小手先の技が必要となります。JavaScriptは参照が動的に処理されるため問題ありません。F#では自分自身を参照するために専用の`rec`キーワードが用意されています。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Func&amp;#60;int, int&gt; frac = null;
frac = x =&gt;
  x &amp;#60; 1 ? 1 : x * frac(x - 1);
Console.WriteLine(frac(5));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let frac = x =&gt;
  x &amp;#60; 1 ? 1 : x * frac(x - 1);
console.log(frac(5));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let rec frac x =
  if x &amp;#60; 1 then 1 else x * frac(x - 1)
printfn &quot;%d&quot; (frac 5)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ デフォルトで再帰可能になっていないのは、同名の変数で覆い隠すシャドウイングを考慮した言語設計のようです。F#の元になったOCamlについての記事を紹介します。

* [@camlspotter](https://twitter.com/camlspotter): [OCaml の let と let rec はなぜ別扱いになっているのか、決定版、もしくは OCaml 暦十何年だったか忘れたけど仕事で Haskell を一年使ってみた - Oh, you `re no (fun _ → more)](http://d.hatena.ne.jp/camlspotter/20110509/1304933919) 2011.05.09

## 前方参照

一般論として用語を解説します。

パーサは上から下にコードを読み進めます。進行方向に沿って下が「前方」と表現されます。

```text
     後方
1 aaaa↓
2 bbbb↓
3 cccc↓
     前方
```

前方で定義されている関数にアクセス（参照）することを「前方参照」と呼びます。下の例では`test()`が前方参照されています。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
class Test
{
  static void Main()
  {
    test();  // 前方参照
  }
  static void test()
  {
    Console.WriteLine(&quot;abc&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
test();  // 前方参照

function test() {
  console.log(&quot;abc&quot;);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ 直感的には「上が前」のように感じられるので注意が必要です。C言語の前方宣言は呼び出し元から見て「前方にある宣言」ではなく、「前方参照を可能にするための宣言」という意味だと解釈できます。

F#は前方参照ができません。他の言語でもラムダ式だけで記述すると似たような状況になりますが、それと同じだと考えてください。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
test();  // エラー
Action test = () =&gt;
  Console.WriteLine(&quot;abc&quot;);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
test();  // エラー
let test = () =&gt;
  console.log(&quot;abc&quot;);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
test()  // エラー
let test() = printfn &quot;abc&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#に前方宣言はありません。必ず後方（上）で定義する必要があります。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Action test = () =&gt;
  Console.WriteLine(&quot;abc&quot;);
test();  // OK
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test = () =&gt;
  console.log(&quot;abc&quot;);
test()  // OK
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test() = printfn &quot;abc&quot;
test()  // OK
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

これは強い制限のようにも感じられますが、コードを読んだり部分的に引用したりするときは、そこより上だけを見ておけば良いという利点があります。

## 相互再帰

前方宣言はありませんが、相互に再帰する場合は特別な構文があります。

F#では`rec`と`and`を使います。C#ではラムダ式を使わなければ特に問題はなく、JavaScriptでは動的に参照されるためアロー関数式でも特に意識する必要はありません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
void test1() { test2(); }
void test2() { test1(); }
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test1 = () =&gt; test2();
let test2 = () =&gt; test1();
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let rec test1() = test2()
and test2() = test1()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

どうしても相互再帰が避けられないケースはありますが、その場合はクラスタとしてひとまとめに定義することが必要です。離して定義することはできません。

## 関数内関数

C#ではクラス直下のメソッドと、メソッド内のラムダ式の書式が大きく異なります。

※ C# 7ではローカル関数という機能が追加され、この制限が緩和されます。

F#やJavaScriptでは関数の中でも関数が定義できます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
class Test
{
  static int inc1(int x)
  {
    return x + 1;
  }
  static void test()
  {
    Func&amp;#60;int, int&gt; inc2 = x =&gt; x + 1;
    Console.WriteLine(inc1(1));
    Console.WriteLine(inc2(1));
  }
  static void Main()
  {
    test();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
function inc1(x) {
  return x + 1;
}
function test() {
  function inc2(x) {
    return x + 1;
  }
  console.log(inc1(1));
  console.log(inc2(1));
}
test();
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let inc1 x = x + 1
let test() =
  let inc2 x = x + 1
  printfn &quot;%d&quot; (inc1 1)
  printfn &quot;%d&quot; (inc2 1)
test()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# カリー化

関数型で必ず話題になるカリー化を説明します。

※ とりあえずF#を使うだけなら必須というわけではありません。分かりにくければ飛ばしても構いません。

必要に応じて次の記事を参照すると良いでしょう。

* [カリー化と部分適用（JavaScriptとHaskell）](http://qiita.com/7shi/items/a0143daac77a205e7962) 2014.10.15

## 糖衣構文

以下の3種類はすべて同じ意味です。

1. `let add = fun x -&gt; fun y -&gt; x + y`
2. `let add = fun x y -&gt; x + y`
3. `let add x y = x + y`

2と3は1の糖衣構文です。1をC#/JavaScriptに翻訳して呼び出してみます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Func&amp;#60;int, Func&amp;#60;int, int&gt;&gt; add =
    x =&gt; y =&gt; x + y;
Console.WriteLine(add(1)(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let add = x =&gt; y =&gt; x + y;
console.log(add(1)(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let add = fun x -&gt; fun y -&gt; x + y
printfn &quot;%d&quot; (add 1 2)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

ラムダ式がネストしています。初見では分かりにくいですが、括弧を付けてみます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Func&amp;#60;int, Func&amp;#60;int, int&gt;&gt; add =
    x =&gt; (y =&gt; x + y);
Console.WriteLine(add(1)(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let add = x =&gt; (y =&gt; x + y);
console.log(add(1)(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let add = fun x -&gt; (fun y -&gt; x + y)
printfn &quot;%d&quot; (add 1 2)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

JavaScriptでは`function`で記述した方が分かりやすいかもしれません。

```js:JavaScript
let add = function(x) {
  return function(y) {
    return x + y;
  };
};
console.log(add(1)(2));
```

## 部分適用

C#/JavaScriptでは引数を1つずつ渡していますが（`add(1)(2)`）、引数を片方だけ渡すこともできます。こうして得られた中間的な関数に残りの引数を渡すと最終的な結果が得られます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var inc = add(1);
Console.WriteLine(inc(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let inc = add(1);
console.log(inc(2));
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let inc = add 1
printfn &quot;%d&quot; (inc 2)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

このように引数を途中まで渡して関数を得ることを部分適用と呼びます。部分適用できるように関数の中に関数を入れる形式をカリー化と呼びます。

※ 部分適用が誤ってカリー化と呼ばれることがあるので注意が必要です。

F#では冒頭で挙げた1～3のすべてがカリー化された関数で部分適用できます。カリー化されない関数を定義するには、引数をコンマで区切りタプルとします。引数をタプルで取る関数でもラムダ式でラップすれば擬似的に部分適用は可能です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;F# (カリー化)&lt;/th&gt;&lt;th&gt;F# (非カリー化)&lt;/th&gt;&lt;th&gt;C# (非カリー化)&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
let add x y = x + y
let inc = add 1
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let add(x, y) = x + y
let inc = fun y -&gt; add(1, y)
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
Func&amp;#60;int, int, int&gt; add = (x, y) =&gt; x + y;
Func&amp;#60;int, int&gt; inc = y =&gt; add(1, y);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

最初の方で.NETのメソッドの呼び方がネイティブ関数とは異なると述べましたが、引数がタプルとして扱われカリー化されていないためです。

# 配列

C#ではサイズを指定して配列を作るとゼロで初期化されます。JavaScriptではTypedArrayで同様の処理が可能です。F#では専用の関数を使用します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var a = new int[5];
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = new Int32Array(5);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = Array.zeroCreate&amp;#60;int&gt; 5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

初期値を指定して配列を作成する方法を示します。F#では要素の区切りはセミコロンなのに注意が必要です（コンマ区切りはタプルを意味するため）。また、F#では配列アクセスで添字の前にドットが必要です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var a = new[] {1, 2, 3, 4};
Console.WriteLine(a[2]);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
var a = [1, 2, 3, 4];
console.log(a[2]);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = [|1; 2; 3; 4|]
printfn &quot;%d&quot; a.[2]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#では配列をスライスできます。末尾の指定方法がJavaScriptとF#では異なるのに注意します。C#では言語サポートがないため地道にコピーします。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var b = new int[2];
Array.Copy(a, 2, b, 0, 2);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = a.slice(2, 4);
&lt;/pre&gt;※ 4は末尾の添字+1&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = a.[2..3]
&lt;/pre&gt;※ 3は末尾の添字&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

JavaScriptとF#は文字列の切り出にもスライスが使用可能です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
&quot;abcde&quot;.Substring(2, 2);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
&quot;abcde&quot;.slice(2, 4);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
&quot;abcde&quot;.[2..3]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# ループ

F#には`while`と`for`はありますが、`continue`と`break`はありません。再帰で書き直す方法を覚えておくと潰しが効きます。考え方としてはループ変数を引数に見立てて、条件を満たせば再帰的に自分を呼び出します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var r = new Random();
for (int i = 0; i &amp;#60; 10; i++)
{
  var v = r.Next(10);
  Console.WriteLine(v);
  if (v &gt; 5) break;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
for (let i = 0; i &amp;#60; 10; i++) {
  let v = (Math.random() * 10) | 0;
  console.log(v);
  if (v &gt; 5) break;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let r = new Random()
let rec loop i =
  if i &amp;#60; 10 then
    let v = r.Next(10)
    printfn &quot;%d&quot; v
    if not(v &gt; 5) then
      loop (i + 1)
loop 0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ 再帰呼び出しは`continue`に相当して、明示的に`continue`を書かないとループから抜けてしまうと解釈できます。ただし`continue`と違って後続の処理が打ち切られるわけではないため、再帰呼び出しの後に処理が来ないように注意する必要があります。後に処理が来ない再帰を**末尾再帰**と呼びます。

再帰を使わずに`while`で無理やり実装することもできます。うまく書けないときはこの手で逃げることがあるかもしれません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
var r = new Random();
int i = 0, v = 0;
while (i &amp;#60; 10 &amp;&amp; !(v &gt; 5))
{
  v = r.Next(10);
  Console.WriteLine(v);
  i++;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let i = 0, v = 0;
while (i &amp;#60; 10 &amp;&amp; !(v &gt; 5)) {
  v = (Math.random() * 10) | 0;
  console.log(v);
  i++;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let r = new Random()
let mutable i, v = 0, 0
while i &amp;#60; 10 &amp;&amp; not(v &gt; 5) do
  v &amp;#60;- r.Next(10)
  printfn &quot;%d&quot; v
  i &amp;#60;- i + 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ この記事では取り上げませんが、F#にはループの代用となる様々な関数が用意されており、本来そちらを使うことが推奨されます。しかしそういったものがうまく適用できないときは、最終手段としてここで説明したような方法でどうにかすることもあるでしょう。

## 複雑な例

標準入力から文字列を読み取り、先頭から連続する数字だけを抜き出して表示する例を示します。C#では代入した値をそのまま評価できますが、F#ではできないため工夫が必要です。JavaScriptはNode.jsで示します。

```csharp:C#
string line;
while ((line = Console.ReadLine()) != null)
{
  int i;
  for (i = 0; i &lt; line.Length; i++)
    if (!Char.IsNumber(line[i])) break;
  Console.WriteLine(line.Substring(0, i));
}
```
```js:JavaScript(Node.js)
let isDigit = ch =&gt; &quot;0&quot; &lt;= ch &amp;&amp; ch &lt;= &quot;9&quot;;

let loop = function*() {
  let line;
  while ((line = yield) != null) {
    let i;
    for (i = 0; i &lt; line.length; i++)
      if (!isDigit(line[i])) break;
    console.log(line.slice(0, i));
  }
}();
loop.next();

let rl = require(&quot;readline&quot;).createInterface(
  process.stdin, process.stdout, null);
rl.on(&quot;line&quot;, line =&gt; loop.next(line));
rl.on(&quot;close&quot;, () =&gt; loop.next(null));
```
```fsharp:F#
let rec loop() =
  let line = Console.ReadLine()
  if line &lt;&gt; null then
    let rec loop2 i =
      if i &lt; line.Length &amp;&amp; Char.IsNumber(line.[i]) then
        loop2 (i + 1)
      else
        line.[0 .. i - 1]
    printfn &quot;%s&quot; (loop2 0)
    loop()
loop()
```

※ Windowsで標準入力読み切り型プログラムを終了させるには [Ctrl]+[Z] [Enter] と操作しますが、Node.jsでは [Ctrl]+[D] です。

Node.jsでの標準入力の扱いは次の記事を参考にしました。

* [Node.jsの標準入力と](http://qiita.com/hiroqn@github/items/c927bc97780c34eda562) 2013.10.03

# 参照

F#では`mutable`の親戚のような参照という型があります。参照は`ref`というキーワードを指定するとその場でインスタンスが作られます。

※ C#で引数を参照で渡すための`ref`とは別物です。

値へのアクセスはプロパティによる方法と演算子による方法があります。演算子の方がよく使われます。`!` は参照剥がし（デリファレンス）演算子で、C#の否定演算子とは無関係です。参照への代入は `:=` です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;F# (mutable)&lt;/th&gt;&lt;th&gt;F# (参照・プロパティ)&lt;/th&gt;&lt;th&gt;F# (参照・演算子)&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int a = 1;
Console.WriteLine(a);
a = 2;
Console.WriteLine(a);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let mutable a = 1
printfn &quot;%d&quot; a
a &amp;#60;- 2
printfn &quot;%d&quot; a
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = ref 1
printfn &quot;%d&quot; b.Value
b.Value &amp;#60;- 2
printfn &quot;%d&quot; b.Value
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = ref 1
printfn &quot;%d&quot; !b
b := 2
printfn &quot;%d&quot; !b
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

C#よりもC++で説明した方が分かりやすいかもしれません。比較の都合上、C++は参照ではなくポインタで示します。C#でもポインタは使えますが、1要素の配列で表現する方が簡単なのでその方法で示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C++&lt;/th&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
int *b = new int(1);
printf(&quot;%d\n&quot;, *b);
*b = 2;
printf(&quot;%d\n&quot;, *b);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
int[] b = new[] {1};
Console.WriteLine(b[0]);
b[0] = 2;
Console.WriteLine(b[0]);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = [1];
console.log(b[0]);
b[0] = 2;
console.log(b[0]);
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let b = ref 1
printfn &quot;%d&quot; !b
b := 2
printfn &quot;%d&quot; !b
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ C++でも `*b = 2;` は `b[0] = 2;` に書き換えられます。

# クロージャ

関数内関数から外のローカル変数にアクセスできます。これをレキシカルスコープと呼んで、変数への参照をキャプチャと表現します。キャプチャを伴った関数をクロージャと呼びます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Action test1 = () =&gt; {
  var i = 0;
  Action test2 = () =&gt;
    Console.WriteLine(i);
  test2();
};
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test1 = () =&gt; {
  let i = 0;
  let test2 = () =&gt;
    console.log(i);
  test2();
};
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let test1() =
  let i = 0
  let test2() =
    printfn &quot;%d&quot; i
  test2()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

上の例ではC#やJavaScriptでは値が変更可能な変数をキャプチャしていますが、F#では`mutable`な変数はキャプチャできません。Javaでもラムダ式（匿名クラス）から`final`を指定した変数しか参照できないのと似ています。

※ Java 8では初期化以外で値を触らなければ事実上の`final`としてコンパイルが通ります。下のコードでは意図的に`i`の値を変更しています。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;F#&lt;/th&gt;&lt;th&gt;Java 8&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
let test1() =
  let mutable i = 0
  let test2() =
    printfn &quot;%d&quot; i  // エラー
  i &amp;#60;- 1
  test2()
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
void test1() {
  int i = 0;
  Runnable test2 = () -&gt;
    System.out.println(i);  // エラー
  i = 1;
  test2.run();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#では参照で回避します。Javaでは`final`を付け、中身を変更可能にするため配列で包む回避策があります。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;F#&lt;/th&gt;&lt;th&gt;Java 8&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
let test1() =
  let i = ref 0
  let test2() =
    printfn &quot;%d&quot; !i
  i := 1
  test2()
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
void test1() {
  final int i[] = {0};
  Runnable test2 = () -&gt;
    System.out.println(i[0]);
  i[0] = 1;
  test2.run();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 理由

ローカルの`mutable`変数はスタックに確保されるのに対し、参照の実体はヒープに確保されます。スタックに確保された変数はスコープアウト時に破棄されます。しかしクロージャにキャプチャされた変数の寿命はスコープに縛られないため、参照によりヒープに確保して解放はGCに任せることで、スコープアウト問題を回避しています。

C#ではキャプチャされる変数はコンパイラが自動的に扱い方を変えるためこの制限がありません。F#では敢えてエラーにしていると思われます。

# クラス

F#とC#で構文がかなり違いますが、`protected`や入れ子にされた型がない以外はほぼ同じことが表現できます。JavaScriptは色々な書き方ができますが、ここではF#との対比の都合上`class`を使わない古い書き方で示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
class Num
{
  private int num = 0;
  public void Next()
  {
    Console.WriteLine(++num);
  }
}
class Test
{
  static void Main()
  {
    var n = new Num();
    for (int i = 0; i &lt; 5; i++)
      n.Next();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
function Num() {
  this.num = 0;
  this.Next = () =&gt;
    console.log(++this.num);
}
let n = new Num();
for (let i = 0; i &lt; 5; i++)
  n.Next();
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
type Num() =
  let mutable num = 0
  member this.Next() =
    num &amp;#60;- num + 1
    printfn &quot;%d&quot; num
let n = new Num()
for i = 0 to 4 do
  n.Next()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#でアクセス制御を省略したときのデフォルトは、`let`が`private`、`member`が`public`となります。`type`名の後の`()`はコンストラクタの引数を表しています。JavaScriptは関数の引数がそのままコンストラクタの引数として使われていて、F#と書き方が似ていることに注目してください。

F#ではインスタンスを生成するときの`new`を省略できます。以後は省略します。

* `new Num()` ⇔ `Num()`

※ `IDisposable`を実装したクラスでは`new`を省略すると警告されます。個人的にはデフォルトで省略して、警告されたら付けるという運用をしています。

## コンストラクタ

コンストラクタで引数を処理する例を示します。JavaScriptで引数をそのままキャプチャしているのに注目してください。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
class Num
{
  private int num = 0;
  public Num(int n)
  {
    num = n;
  }
  public void Next()
  {
    Console.WriteLine(++num);
  }
}
class Test
{
  static void Main()
  {
    var n = new Num(5);
    for (int i = 0; i &lt; 5; i++)
      n.Next();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
function Num(num) {
  this.Next = () =&gt;
    console.log(++num);
}
let n = new Num(5);
for (let i = 0; i &lt; 5; i++)
  n.Next();
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
type Num(n) =
  let mutable num = n
  member this.Next() =
    num &amp;#60;- num + 1
    printfn &quot;%d&quot; num
let n = Num 5
for i = 0 to 4 do
    n.Next()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## クロージャと比較

クロージャをクラスの代わりに使って比較してみます。F#は一旦参照で受けるため冗長になっていますが、C#やJavaScriptはその必要がないため単純です。JavaScriptとF#はクラスの書き方とよく似ているのに注目してください。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C#&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
Func&amp;#60;int, Action&gt; Num = num =&gt;
  () =&gt; Console.WriteLine(++num);
var next = Num(5);
for (int i = 0; i &lt; 5; i++)
  next();
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
function Num(num) {
  return () =&gt;
    console.log(++num);
}
let next = Num(5);
for (let i = 0; i &lt; 5; i++)
  next();
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let Num(n) =
  let num = ref n
  fun () -&gt;
    num := !num + 1
    printfn &quot;%d&quot; !num
let next = Num 5
for i = 0 to 4 do
  next()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# 多態

## サブクラスによるオーバーライド

数字と足し算のAST（抽象構文木）の例を示します。JavaScriptは継承ではなくダックタイピングで実装します。

```csharp:C#
abstract class Val
{
  public abstract int Value { get; }
}
class Num : Val
{
  private int num;
  public Num(int n) { num = n; }
  public override int Value { get { return num; } }
}
class Add : Val
{
  private Val a, b;
  public Add(Val a, Val b) {
    this.a = a;
    this.b = b;
  }
  public override int Value
  {
    get { return a.Value + b.Value; }
  }
}
class Test
{
  static void Main() {
    var expr = new Add(new Num(2), new Num(3));
    Console.WriteLine(expr.Value);
  }
}
```
```js:JavaScript
function Num(num) {
  Object.defineProperty(this, &quot;Value&quot;, {
    get: () =&gt; num
  });
}
function Add(a, b) {
  Object.defineProperty(this, &quot;Value&quot;, {
    get: () =&gt; a.Value + b.Value
  });
}
let expr = new Add(new Num(2), new Num(3));
console.log(expr.Value);
```
```fsharp:F#
[&lt;AbstractClass&gt;]
type Val() =
  abstract Value: int
type Num(num) =
  inherit Val()
  override this.Value = num
type Add(a: Val, b: Val) =
  inherit Val()
  override this.Value = a.Value + b.Value
let expr = Add(Num 2, Num 3)
printfn &quot;%d&quot; expr.Value
```

## 判別共用体

F#には多態を簡潔に表現する判別共用体というものがあります。クラスごとの評価関数を個別にオーバーライドするのではなく、一箇所にまとめて書くスタイルです。

```fsharp:F#
type Val =
| Num of int
| Add of Val * Val

let rec eval = function
| Num(num) -&gt; num
| Add(a, b) -&gt; eval a + eval b

let expr = Add(Num 2, Num 3)
printfn &quot;%d&quot; (eval expr)
```

判別共用体がうまくハマるパターンではものすごく簡潔になります。

JavaScriptで雰囲気を真似た例を示します。C#では冗長になるため省略します。

```js:JavaScript
function Num(num) {
  this.num = num;
}
function Add(a, b) {
  this.a = a;
  this.b = b;
}
function eval(v) {
  if (v instanceof Num)
    return v.num;
  if (v instanceof Add)
    return eval(v.a) + eval(v.b);
}
let expr = new Add(new Num(2), new Num(3));
console.log(eval(expr));
```

# 資料

今回と同じような視点の記事を紹介します。

この記事の元になった記事です。C#的なオブジェクト指向構文を中心にまとめています。

* [C#プログラマのためのF#入門](http://d.hatena.ne.jp/n7shi/20090722) 2009.07.22

限定された範囲内でC#をF#に変換するトランスレータです。JavaScriptで実装されているため、ブラウザ上で動きます。

* [C# to F# translator](http://7shi.bitbucket.org/cs2fs/) 2015.08.01

C#とF#との対比記事です。引用されているF# Tutorialはプロジェクト作成のときに選択できます。

* [@neuecc](https://twitter.com/neuecc): [F# TutorialをC#と比較しながらでF#を学ぶ](http://neue.cc/2009/11/09_214.html) 2009.11.09
</textarea><input type="submit" name="commit" value="Save changes" data-disable-with="Save changes" /></form></div></section></div><div class="col-sm-3"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="C#/JavaScriptで学ぶF#入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="C#/JavaScriptで学ぶF#入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/ff746903680ae8d0d7ce" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div><section class="itemsShowAuthorInfo" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><a href="/7shi"><img alt="" class="itemsShowAuthorInfo_userIcon" itemprop="image" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" /></a><div class="itemsShowAuthorInfo_profileStats"><strong class="itemsShowAuthorInfo_userName" itemprop="name"><a itemprop="url" href="/7shi">7shi</a></strong><div class="itemsShowAuthorInfo_contribution"><span class="itemsShowAuthorInfo_count">2522</span><span class="itemsShowAuthorInfo_unit">Contribution</span></div><div data-react-class="T.UserFollowButton" data-react-props="{&quot;url_name&quot;:&quot;7shi&quot;,&quot;initial_followed_by&quot;:false,&quot;size&quot;:&quot;btn-xs&quot;,&quot;position&quot;:&quot;author-info&quot;}"></div></div><section class="itemsShowAuthorPopularItems"><h5 class="itemsShowAuthorPopularItems_sectionTitle">Popular Posts</h5><ul class="itemsShowAuthorPopularItems_posts list-unstyled"><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/145f1234f8ec2af923ef">Haskell 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/547b6137d7a3c482fe68">モナド則がちょっと分かった？</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/cac7b3e9b90bf91b00cc">文字列で学ぶC++入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/85afd7bbd5d6c4115ad6">Haskell アクション 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/d1e5a0c22be6cf61d286">Haskell IDE Leksah 入門</a></li></ul></section></section><div class="scroll-chaser"><div class="google-adsense"><style>.test-text-responsible { width: 200px; height: 200px; }@media(min-width: 1200px) {  .test-text-responsible { width: 250px; height: 250px; }}@media(max-width: 979px) and (min-width: 768px) {  .test-text-responsible { width: 120px; height: 240px; }}@media(max-width: 767px) {  .test-text-responsible { width: 320px; height: 50px; }}</style><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle test-text-responsible" data-ad-client="ca-pub-8127218772604357" data-ad-slot="3880091879" style="display:inline-block"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div><div data-react-class="T.Toc" data-react-props="{&quot;body&quot;:&quot;\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#f%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\&quot;\u003eF#について\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%83%8C%E6%99%AF\&quot;\u003e背景\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BD%8D%E7%BD%AE%E4%BB%98%E3%81%91\&quot;\u003e位置付け\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%8F%E3%83%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89\&quot;\u003eハローワールド\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#printfprintfn\&quot;\u003eprintf/printfn\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%A4%87%E6%95%B0%E3%81%AE%E5%BC%95%E6%95%B0\&quot;\u003e複数の引数\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#f%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%81%AE%E9%96%A2%E6%95%B0\&quot;\u003eF#ネイティブの関数\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#net%E3%81%AE%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89\&quot;\u003e.NETのメソッド\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%95%B0%E5%80%A4%E5%9E%8B%E3%81%AE%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88\&quot;\u003e数値型のキャスト\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%8A%E3%81%BE%E3%81%91\&quot;\u003eおまけ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A4%89%E6%95%B0\&quot;\u003e変数\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%9D%9F%E7%B8%9B\&quot;\u003e束縛\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E6%95%B0%E5%AE%9A%E7%BE%A9\&quot;\u003e複数の変数定義\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#f-interactive\&quot;\u003eF# Interactive\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%9D%A1%E4%BB%B6%E5%BC%8F\&quot;\u003e条件式\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF\&quot;\u003eブロック\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%B8%89%E9%A0%85%E6%BC%94%E7%AE%97%E5%AD%90\&quot;\u003e三項演算子\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%A4%87%E5%90%88%E6%8A%80\&quot;\u003e複合技\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%BF%E3%83%97%E3%83%AB\&quot;\u003eタプル\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0\&quot;\u003e関数\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F\&quot;\u003eラムダ式\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87\&quot;\u003e糖衣構文\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#fsi\&quot;\u003efsi\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#unit\&quot;\u003eunit\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#ignore\&quot;\u003eignore\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E6%BC%94%E7%AE%97%E5%AD%90\&quot;\u003eパイプライン演算子\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%86%8D%E5%B8%B0%E9%96%A2%E6%95%B0\&quot;\u003e再帰関数\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%89%8D%E6%96%B9%E5%8F%82%E7%85%A7\&quot;\u003e前方参照\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%9B%B8%E4%BA%92%E5%86%8D%E5%B8%B0\&quot;\u003e相互再帰\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0%E5%86%85%E9%96%A2%E6%95%B0\&quot;\u003e関数内関数\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96\&quot;\u003eカリー化\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87-1\&quot;\u003e糖衣構文\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%83%A8%E5%88%86%E9%81%A9%E7%94%A8\&quot;\u003e部分適用\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%85%8D%E5%88%97\&quot;\u003e配列\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%AB%E3%83%BC%E3%83%97\&quot;\u003eループ\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%A4%87%E9%9B%91%E3%81%AA%E4%BE%8B\&quot;\u003e複雑な例\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%8F%82%E7%85%A7\&quot;\u003e参照\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3\&quot;\u003eクロージャ\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%90%86%E7%94%B1\&quot;\u003e理由\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AF%E3%83%A9%E3%82%B9\&quot;\u003eクラス\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF\&quot;\u003eコンストラクタ\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%81%A8%E6%AF%94%E8%BC%83\&quot;\u003eクロージャと比較\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A4%9A%E6%85%8B\&quot;\u003e多態\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%B5%E3%83%96%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E3%82%88%E3%82%8B%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89\&quot;\u003eサブクラスによるオーバーライド\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%88%A4%E5%88%A5%E5%85%B1%E7%94%A8%E4%BD%93\&quot;\u003e判別共用体\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%B3%87%E6%96%99\&quot;\u003e資料\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n&quot;,&quot;wrapper&quot;:&quot;#article-body-wrapper&quot;}"></div></div></div><div class="row"><div class="col-sm-9"><div class="ArticleFooter__menu"><div class="s-flex-align-center"><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:16,&quot;show_count&quot;:true,&quot;uuid&quot;:&quot;ff746903680ae8d0d7ce&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-footer&quot;}"></div><div class="ArticleFooter__userList"><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="tyahha"><a itemprop="url" href="/tyahha"><img alt="tyahha" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/91779/profile-images/1480570348" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="jbucaran"><a itemprop="url" href="/jbucaran"><img alt="jbucaran" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/60411/profile-images/1483117845" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="NetSeed"><a itemprop="url" href="/NetSeed"><img alt="NetSeed" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/9662/profile-images/1473681499" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="moto_pipedo"><a itemprop="url" href="/moto_pipedo"><img alt="moto_pipedo" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/86588/profile-images/1473703794" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="ozwk"><a itemprop="url" href="/ozwk"><img alt="ozwk" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/72075/profile-images/1473699037" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="muro"><a itemprop="url" href="/muro"><img alt="muro" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/46717/profile-images/1473690741" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="KandaMorioka"><a itemprop="url" href="/KandaMorioka"><img alt="KandaMorioka" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/126862/profile-images/1473716697" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="ttsutchi"><a itemprop="url" href="/ttsutchi"><img alt="ttsutchi" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/120362/profile-images/1486650239" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="Yasu-umi"><a itemprop="url" href="/Yasu-umi"><img alt="Yasu-umi" class="thumb thumb--xs" src="https://pbs.twimg.com/profile_images/550329366035456000/u947CJIG_normal.png" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="chocolamint"><a itemprop="url" href="/chocolamint"><img alt="chocolamint" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/11978/profile-images/1473682231" /></a></div></div><div class="ArticleFooter__user"><a href="/7shi/items/ff746903680ae8d0d7ce/likers"><span class="fa fa-ellipsis-h"></span></a></div></div></div><div class="u-flex u-align-center"><div class="ArticleFooter__stock"><div class="js-stockbutton" data-position="footer_menu" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="ArticleFooter__editRequest"><a class="u-link-no-underline" data-toggle="tooltip" title="You can propose improvements about the article to the author 💪" href="/drafts/ff746903680ae8d0d7ce/edit"><span class="fa fa-send-o fa-lg"></span> <span>Edit request</span></a></div><div class="dropdown ArticleFooter__dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h"></span></a><ul class="dropdown-menu dropdown-menu-right"><li><a href="/7shi/items/ff746903680ae8d0d7ce.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><i class="fa fa-fw fa-flag"></i> Report article</a></li></ul></div></div></div><ul class="references js-referencesView"><li class="references_header"><i class="fa fa-fw fa-link"></i> Linked from these articles</li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/5fc7d6477d96bbd7a71d#_reference-0d3b968e64f6991a3e98"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />F#開発環境の紹介</a><time class="references_datetime js-dateTimeView" datetime="2017-01-04T13:36:52+00:00">about 2 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/4fb60dacad46cb8e63b3#_reference-14f0644e50108ce38f8d"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />多項式の積を計算</a><time class="references_datetime js-dateTimeView" datetime="2017-01-04T13:39:53+00:00">about 2 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/1d3750ba17f5a88b8405#_reference-7bb14d4b8db714b3b354"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskellで学ぶF#入門</a><time class="references_datetime js-dateTimeView" datetime="2017-01-11T09:42:47+00:00">about 2 months ago</time></li></ul><div class="itemsShowBody_articleColumnFooter"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="C#/JavaScriptで学ぶF#入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="C#/JavaScriptで学ぶF#入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/ff746903680ae8d0d7ce" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div></div><div class="itemsShowComment_wrapper" id="comments"><div data-react-class="T.CommentListContainer" data-react-props="{&quot;currentUser&quot;:null,&quot;initialComments&quot;:[],&quot;monthly_public_image_uploadable_size_limit&quot;:null,&quot;total_uploaded_public_image_size_in_current_month&quot;:null,&quot;item&quot;:{&quot;id&quot;:457631,&quot;uuid&quot;:&quot;ff746903680ae8d0d7ce&quot;,&quot;suspended&quot;:false,&quot;secret&quot;:false},&quot;owner&quot;:{&quot;url_name&quot;:&quot;7shi&quot;},&quot;is_team&quot;:false,&quot;is_project&quot;:false,&quot;logged_in&quot;:false,&quot;polling&quot;:false,&quot;mention_candidates&quot;:[{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}]}">Comments Loading...</div></div></div></div></div></article><div class="js-report-form modal fade reportForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Report article</h4></div><div class="modal-body"><form action="/reports" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="PSWoxOciJ9WhLieuUk/Y3ilgtoEmzVDT4ztIv1X0XJ5TpzOcfAwenl79krIiumaHSSeSMrEJCiTf5UFEtPpSWA==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/ff746903680ae8d0d7ce" /><input type="hidden" name="item_uuid" id="item_uuid" value="ff746903680ae8d0d7ce" /><p>Help us understand the problem. What is going on with this item?</p><br /><div class="form-group"><ul class="list-unstyled"><li><label><input type="radio" name="report_type" id="report_type_spam" value="spam" required="required" /> It&#39;s spam </label></li><li><label><input type="radio" name="report_type" id="report_type_harassment" value="harassment" required="required" /> It&#39;s abusive or harmful </label></li><li><label><input type="radio" name="report_type" id="report_type_inappropriate_content" value="inappropriate_content" required="required" /> It contains inappropriate content </label></li></ul></div><div class="reportForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary reportForm_submitButton"><i class="fa fa-send"></i> Submit</button></div></form></div></div></div></div><script id="js-item" type="application/json">{ "url": "http://qiita.com/7shi/items/ff746903680ae8d0d7ce", "id": 457631, "uuid": "ff746903680ae8d0d7ce" }</script><script class="js-user" type="application/json">{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}</script><script language="JavaScript" src="//cdn.bigmining.com/private/js/qiita_bigmining.js" type="text/javascript"></script></div><footer class="footer"><div class="footer_inner"><div class="footer_container"><ul class="footer_links-left"><li class="footer_link"><a class="footer_copyright" href="http://increments.co.jp">© 2011-2017 Increments Inc.</a></li><li class="footer_link"><a href="http://qiita.com/terms">Terms</a></li><li class="footer_link"><a href="http://qiita.com/privacy">Privacy</a></li><li class="footer_link"><a href="http://help.qiita.com">Help</a></li><li class="footer_link"><a href="https://increments.zendesk.com/anonymous_requests/new">Contact</a></li></ul><ul class="footer_links-right"><li class="footer_link"><a href="http://qiita.com/about">About</a></li><li class="footer_link"><a href="/users">Users</a></li><li class="footer_link"><a href="/tags">Tags</a></li><li class="footer_link"><a href="http://blog.qiita.com">Blog</a></li><li class="footer_link"><a href="http://qiita.com/api/v2/docs">API</a></li><li class="footer_link"><a href="https://teams.qiita.com/">Team</a></li><li class="footer_link"><a href="http://kobito.qiita.com">Kobito</a></li><li class="footer_link"><a class="js-public-form-feedback-link" data-target=".js-feedback-form" data-toggle="modal" href=""><i class="fa fa-heart"></i> Feedback <i class="fa fa-caret-down"></i></a></li></ul></div></div></footer><div class="js-feedback-form modal fade feedbackForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Feedback</h4></div><div class="modal-body"><form class="js-feedback-form-form" action="/feedbacks" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="Qhq16kXM3cPFVs3Lo54HRmG15ZTVIWmzAJsD3Q/qQcssmC6y3uLkiDqFeNfTa7kfAfLBJ0LlM0Q8RQom7uRPDQ==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/ff746903680ae8d0d7ce" /><div class="form-group"><textarea name="feedback[message]" id="feedback_message" class="form-control js-feedback-form-text-area" placeholder="Please give us any feedback about Qiita." required="required" rows="5">
</textarea></div><div class="feedbackForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary feedbackForm_submitButton"><i class="fa fa-send"></i> Submit</button><p class="feedbackForm_note">We don&#39;t reply to any feedback.<br />If you need help with Qiita, please send a support request from <a href="https://increments.zendesk.com/anonymous_requests/new">here</a>.</p></div><div style="position:fixed;top:-99999px;opacity:0.0001;"><input name="feedback[name]" type="text" /></div></form></div></div></div></div><script>// if (window.mixpanel instanceof Element) {
//   window.mixpanel = [];
// }
// (function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
// for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);</script><script src="http://cdn.qiita.com/assets/public-8c6201a66dc6db6f64a9017391c319bf.min.js"></script><script>
  (function () {
    var script = document.getElementsByTagName('script')[0];
    var load = function (src, id) {
      var el = document.createElement('script');
      el.async = true;
      el.src = src;
      el.id = id;
      script.parentNode.insertBefore(el, script);
    };
      // Optimizely
      load('//cdn.optimizely.com/js/52738645.js', 'optimizely-jssdk');
      // Google Analytics
      window._gaq = window._gaq || [];
      var isCareer = location.hostname.split('.')[0] == 'career';
      if (isCareer) {
        window._gaq.push(['_setAccount', 'UA-24675221-11']);
        window._gaq.push(['_setDomainName', 'qiita.com']);
      } else {
        window._gaq.push(['_setAccount', 'UA-24675221-1']);
      }
      window._gaq.push(['_setCustomVar', 1, 'logged_in', 'false', 2]);
      window._gaq.push(['_trackPageview']);
      var src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      load(src, 'google-analytics-jssdk');
    // Google Analytics - Universal Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-24675221-12', {
          
        });
        ga('set', 'dimension1', 'false');
        ga('set', 'dimension3', 'false');
      ga('require', 'displayfeatures');
      ga('set', 'forceSSL', true);
      ga('send', 'pageview');
    // Google Tag Manager
      (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-TBQWPN');
  })();
</script>
</body></html>