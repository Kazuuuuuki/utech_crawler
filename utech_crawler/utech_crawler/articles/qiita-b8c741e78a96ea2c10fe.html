<!DOCTYPE html><html xmlns:og="http://ogp.me/ns#"><head><meta charset="UTF-8" /><title>Haskell 構文解析 超入門 - Qiita</title><meta content="width=device-width,initial-scale=1" name="viewport" /><meta content="Haskellではモナドと呼ばれる部品を組み合わせて構文解析を行います。この方式をパーサコンビネータと呼びます。動作原理を簡単に説明しながら使い方の初歩を説明します。Parsecというライブラリで簡単な四則演算器を作成します。

シリーズの記事です。


Haskell 超入門
Haskell 代数的データ型 超入門
Haskell アクション 超入門
Haskell ラムダ 超入門
Haskell アクションとラムダ 超入門
Haskell IOモナド 超入門
Has..." name="description" /><meta content="summary" name="twitter:card" /><meta content="@Qiita" name="twitter:site" /><meta content="7shi" name="twitter:creator" /><meta content="Haskell 構文解析 超入門 - Qiita" property="og:title" /><meta content="article" property="og:type" /><meta content="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" property="og:url" /><meta content="http://cdn.qiita.com/assets/qiita-fb-2887e7b4aad86fd8c25cea84846f2236.png" property="og:image" /><meta content="Haskellではモナドと呼ばれる部品を組み合わせて構文解析を行います。この方式をパーサコンビネータと呼びます。動作原理を簡単に説明しながら使い方の初歩を説明します。Parsecというライブラリで簡単な四則演算器を作成します。

シリ..." property="og:description" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><link rel="shortcut icon" type="image/x-icon" href="http://cdn.qiita.com/assets/favicons/public/production-4ff10c1e1e2b5fcb353ff9cafdd56c70.ico" /><link rel="apple-touch-icon" type="image/png" href="http://cdn.qiita.com/assets/favicons/public/apple-touch-icon-f9a6afad761ec2306e10db2736187c8b.png" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link rel="stylesheet" media="all" href="http://cdn.qiita.com/assets/public-e8d29e8ff1879118096f0f5877946857.min.css" /><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="eNXEVpGFgNcJV02qwkeMN0zuxnAxM6HmLpGJzoy/VvIWV18OCqu5nPaE+LaysjJuLKniw6b3+xEST4A1bbFYNA==" /></head><body class="without-js" id=""><noscript><iframe height="0" src="//www.googletagmanager.com/ns.html?id=GTM-TBQWPN" style="display:none;visibility:hidden" width="0"></iframe></noscript><script>
  document.body.className = document.body.className.replace('without-js', '') + ' with-js';
  window.Qiita = {"asset_host":"cdn.qiita.com","TLD":"com","controller_path":"public/items","controller_action":"public/items#show","controller":"items","action":"show","env":"production","flash":{},"is_landing_page":false,"is_team_page":false,"root_domain":"qiita.com","variant":null,"config":{"mixpanel":{"career":"dd35af27e959781713d63fd7ca898a8d","per_team":"c0a2116368b33b44b5029ebd2cc9b094","public":"be87616606b0e26a87689099aab2c4e5","team":"b7c0342acba2dbc8742484d98788efb3"},"default_locale":"ja","locale":"en"},"team":null,"user":null,"GIT_BRANCH":null,"DEBUG":false};

</script>
<div class="headerContainer headerContainer-public" role="navigation"><div data-react-class="T.HeaderContainer" data-react-props="{&quot;user&quot;:null,&quot;team&quot;:null,&quot;news&quot;:{&quot;type&quot;:&quot;募集&quot;,&quot;content&quot;:&quot;QiitaやQiita:Teamを良くしたいエンジニア&quot;,&quot;url&quot;:&quot;http://increments.co.jp/jobs/engineers?utm_source=qiita\u0026utm_medium=header_news&quot;},&quot;initial_unread_count&quot;:null,&quot;siteid_image&quot;:&quot;http://cdn.qiita.com/siteid-reverse.png&quot;,&quot;is_team_page&quot;:false,&quot;on_team_setting&quot;:false,&quot;show_post_menu&quot;:true,&quot;show_search_menu&quot;:true,&quot;is_fluid&quot;:false,&quot;locale&quot;:&quot;en&quot;}"></div></div><div id="main"><ol class="itemBreadcrumbs" itemscope="" itemtype="http://schema.org/BreadcrumbList"><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/"><span itemprop="name">Qiita</span></a><meta content="1" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/items"><span itemprop="name">Items</span></a><meta content="2" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/tags/Haskell"><span itemprop="name">Haskell</span></a><meta content="3" itemprop="position" /></li></ol><article itemscope="" itemtype="http://schema.org/Article"><div class="ArticleMainHeader "><div class="container"></div><div class="container"><div class="row s-flex-align-center"><div class="col-sm-9"><h1 class="ArticleMainHeader__title">Haskell 構文解析 超入門</h1><ul class="TagList"><li class="TagList__item" data-count="1345"><a class="u-link-unstyled TagList__label" href="/tags/Haskell"><img alt="Haskell" class="TagList__icon" src="https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/373b3b0595a92712b2a45616f53dae97bc1a04e5/medium.jpg?1387913155" /><span>Haskell</span></a></li><li class="TagList__item" data-count="5"><a class="u-link-unstyled TagList__label" href="/tags/parsec"><img alt="parsec" class="TagList__icon" src="//cdn.qiita.com/assets/icons/medium/missing-2e17009a0b32a6423572b0e6dc56727e.png" /><span>parsec</span></a></li></ul></div><div class="col-sm-3"><div class="itemsShowHeaderStock"><ul class="list-unstyled itemsShowHeaderStock_statusList"><li><div class="itemsShowHeaderStock_count stock"><span class="fa fa-thumbs-up"></span><span class="js-likecount">37</span></div><div class="itemsShowHeaderStock_countText">Like</div></li><li><div class="itemsShowHeaderStock_count" content="0 UserComments" itemprop="interactionCount"><span class="fa fa-comment"></span>0</div><div class="itemsShowHeaderStock_countText">Comment</div></li></ul></div><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:37,&quot;uuid&quot;:&quot;b8c741e78a96ea2c10fe&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-header&quot;}"></div><ul class="list-inline ArticleMainHeader__users"><li class="js-hovercard" data-hovercard-target-name="cotrpepe"><a itemprop="url" href="/cotrpepe"><img alt="cotrpepe" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/46434/profile-images/1473690647" /></a></li><li class="js-hovercard" data-hovercard-target-name="nagai_akinari"><a itemprop="url" href="/nagai_akinari"><img alt="nagai_akinari" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/53556/profile-images/1475478164" /></a></li><li class="js-hovercard" data-hovercard-target-name="tapioga"><a itemprop="url" href="/tapioga"><img alt="tapioga" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38349/profile-images/1473687732" /></a></li><li class="js-hovercard" data-hovercard-target-name="bells17"><a itemprop="url" href="/bells17"><img alt="bells17" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/13148/profile-images/1473682696" /></a></li><li class="js-hovercard" data-hovercard-target-name="junnpit"><a itemprop="url" href="/junnpit"><img alt="junnpit" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/37177/profile-images/1473687332" /></a></li><li class="js-hovercard" data-hovercard-target-name="lesguillemets"><a itemprop="url" href="/lesguillemets"><img alt="lesguillemets" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/63937/profile-images/1473696424" /></a></li><li class="js-hovercard" data-hovercard-target-name="takehiroman"><a itemprop="url" href="/takehiroman"><img alt="takehiroman" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/37030/profile-images/1473687285" /></a></li><li class="js-hovercard" data-hovercard-target-name="HiromiKai_Green"><a itemprop="url" href="/HiromiKai_Green"><img alt="HiromiKai_Green" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/12864/profile-images/1473682573" /></a></li><li class="js-hovercard" data-hovercard-target-name="wadahiro"><a itemprop="url" href="/wadahiro"><img alt="wadahiro" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/35233/profile-images/1473686651" /></a></li><li class="js-hovercard" data-hovercard-target-name="ksoda"><a itemprop="url" href="/ksoda"><img alt="ksoda" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/42409/profile-images/1473689147" /></a></li><li><a href="/7shi/items/b8c741e78a96ea2c10fe/likers"><span class="fa fa-ellipsis-h"></span></a></li></ul></div></div></div></div><div class="ArticleAsideHeader"><div class="container"><div class="u-flex u-space-between"><div class="u-flex u-flex-wrap"><div class="u-flex u-align-center s-pdv-5 u-flex-wrap"><div class="ArticleAsideHeader__author"><a href="/7shi"><img class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" alt="1473685823" /></a> <a class="u-link-unstyled" href="/7shi">7shi</a> </div><div class="ArticleAsideHeader__date"><span data-toggle="tooltip" title="posted at 2015-07-31">Edited at <time datetime="2016-12-27T02:36:21+09:00" itemprop="dateModified">2016-12-27</time></span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"><div class="ArticleAsideHeader__revision"> <a data-toggle="tooltip" title="Revisions" href="/7shi/items/b8c741e78a96ea2c10fe/revisions"><span class="fa fa-history"></span></a><span class="ArticleAsideHeader__revisionCount">83</span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"></div></div><div class="u-flex u-align-center s-flex-justiry-between s-pdv-5 u-shrink-0"><div class="ArticleAsideHeader__stock"><div class="js-stockbutton" data-position="top" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h fa-lg"></span></a><ul class="dropdown-menu dropdown-menu-right"><li class="dropdown__item--mobile"><a href="/7shi/items/b8c741e78a96ea2c10fe/revisions"><span class="fa fa-fw fa-history"></span> Revisions<span>(83)</span></a></li><li><a href="/7shi/items/b8c741e78a96ea2c10fe.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><span class="fa fa-fw fa-flag"></span> Report article</a></li></ul></div></div></div></div></div><div class="container"><div class="row" id="article-body-wrapper"><div class="col-sm-9"><section class="markdownContent markdownContent-headingEnabled js-task-list-container clearfix position-relative" id="item-b8c741e78a96ea2c10fe" itemprop="articleBody"><p>Haskellではモナドと呼ばれる部品を組み合わせて構文解析を行います。この方式をパーサコンビネータと呼びます。動作原理を簡単に説明しながら使い方の初歩を説明します。Parsecというライブラリで簡単な四則演算器を作成します。</p>

<p>シリーズの記事です。</p>

<ol>
<li><a href="http://qiita.com/7shi/items/145f1234f8ec2af923ef" id="reference-cce9533b3dab5d74f48a">Haskell 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/1ce76bde464b4a55c143" id="reference-29ac93d6f2ae004b6544">Haskell 代数的データ型 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/85afd7bbd5d6c4115ad6" id="reference-349814e993418384d0c8">Haskell アクション 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/1345bf32003faff435cb" id="reference-01b8b32857251d369882">Haskell ラムダ 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/4a8a2807bb5186576c61" id="reference-823499b019b535fed407">Haskell アクションとラムダ 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/d3d3492ddd90d47160f2" id="reference-5ddef01ee351c595f2f4">Haskell IOモナド 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/deb19c4cba933590ffbf" id="reference-76855d2b4a64a8f87d7a">Haskell リストモナド 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/c7d7eec066af0fe0688d" id="reference-bf1c0280288729e4f26a">Haskell Maybeモナド 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/2e9bff5d88302de1a9e9" id="reference-8042913034a33a46a4ee">Haskell 状態系モナド 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/4408b76624067c17e933" id="reference-2e9828a2546a1d3bf9f1">Haskell モナド変換子 超入門</a></li>
<li><a href="http://qiita.com/7shi/items/73e534c47bbebc71b37e" id="reference-74efd4551245c6c7699d">Haskell 例外処理 超入門</a></li>
<li>Haskell 構文解析 超入門 ← この記事</li>
<li>【予定】Haskell 継続モナド 超入門</li>
<li>【予定】Haskell 型クラス 超入門</li>
<li>【予定】Haskell モナドとゆかいな仲間たち</li>
<li>【予定】Haskell Freeモナド 超入門</li>
<li>【予定】Haskell Operationalモナド 超入門</li>
<li>【予定】Haskell Effモナド 超入門</li>
<li>【予定】Haskell アロー 超入門</li>
</ol>

<p>練習の解答例は別記事に掲載します。</p>

<ul>
<li><a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12" id="reference-cfd65e8476f0bb989b07">【解答例】Haskell 構文解析 超入門</a></li>
</ul>

<p>この記事には関連記事があります。</p>

<ul>
<li><a href="http://qiita.com/7shi/items/ee5afe4f088f0a1fc8c2" id="reference-731fc804466a3add9f6f">Stateモナドによる中置記法の処理</a></li>
</ul>

<p>この記事には他言語版があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/6a12160276a8db358e34" id="reference-8dbacbfc62ad15772237">C++11 パーサコンビネータ 超入門</a> 2015.11.27</li>
<li>
<a href="http://qiita.com/7shi/items/f86f2f7ad68cfff1b399" id="reference-c292defb70c2cacbfbfd">C++11 パーサコンビネータ 超入門 2</a> 2015.11.30</li>
<li>
<a href="http://qiita.com/7shi/items/68228e19552c271bea81" id="reference-086ea9ca2bd62e08949a">Java パーサコンビネータ 超入門</a> 2016.05.12</li>
<li>
<a href="http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142" id="reference-12c26fc6ef7132493c89">Java パーサコンビネータ 超入門 2</a> 2016.05.14</li>
</ul>

<p>この記事には関連記事があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/04c2991239894687ef2f" id="reference-b60774f21a6d08a9b839">JSONパーサーを作る</a> 2016.12.26</li>
</ul>

<h1>
<span id="動作原理" class="fragment"></span><a href="#%E5%8B%95%E4%BD%9C%E5%8E%9F%E7%90%86"><i class="fa fa-link"></i></a>動作原理</h1>

<p>パーサコンビネータとは単純なパーサ（構文解析器）を組み合わせることで複雑な構文解析にも対応できる仕組みです。その動作原理をなるべく平易な実装で説明します。</p>

<h2>
<span id="モナドなし" class="fragment"></span><a href="#%E3%83%A2%E3%83%8A%E3%83%89%E3%81%AA%E3%81%97"><i class="fa fa-link"></i></a>モナドなし</h2>

<p>まずモナドなしでパーサを作ります。</p>

<h3>
<span id="1文字取得" class="fragment"></span><a href="#1%E6%96%87%E5%AD%97%E5%8F%96%E5%BE%97"><i class="fa fa-link"></i></a>1文字取得</h3>

<p>指定した文字列から先頭の1文字を取得します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
</pre></div>
</div>

<p><code>anyChar</code>が最初のパーサです。</p>

<h3>
<span id="連続呼び出し" class="fragment"></span><a href="#%E9%80%A3%E7%B6%9A%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97"><i class="fa fa-link"></i></a>連続呼び出し</h3>

<p><code>anyChar</code>を連続呼び出しすることで複数文字を取得できるように拡張します。</p>

<p>まだ読み取っていない残りの文字列をタプルで返せば、次の呼び出しで次の文字が取得できます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">r1</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
        <span class="n">r2</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="o">$</span> <span class="n">snd</span> <span class="n">r1</span>
    <span class="n">print</span> <span class="n">r1</span>
    <span class="n">print</span> <span class="n">r2</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
('a',"bc")
('b',"c")
</pre></div>
</div>

<h3>
<span id="結果の分離" class="fragment"></span><a href="#%E7%B5%90%E6%9E%9C%E3%81%AE%E5%88%86%E9%9B%A2"><i class="fa fa-link"></i></a>結果の分離</h3>

<p>結果として返されるタプルの中身を分離して受け取ります。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="n">print</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
</pre></div>
</div>

<p><code>anyChar</code>を2回繰り返すことで、先頭から2文字取得しています。</p>

<h3>
<span id="関数化" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E5%8C%96"><i class="fa fa-link"></i></a>関数化</h3>

<p>2文字取得する部分を関数化します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">test1</span> <span class="n">xs0</span> <span class="ow">=</span>                      <span class="c1">-- 関数化</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">test1</span>   <span class="s">"abc"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
('a',"bc")
"ab"
</pre></div>
</div>

<h3>
<span id="組み合わせ" class="fragment"></span><a href="#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B"><i class="fa fa-link"></i></a>組み合わせ</h3>

<p><code>test1</code>も残りの文字列を返すようにすれば、別の箇所で<code>anyChar</code>と組み合わせて利用できるようになります。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">test1</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>           <span class="c1">-- 残りの文字列を返す</span>

<span class="nf">test2</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">test1</span>   <span class="n">xs0</span>  <span class="c1">-- test1で処理した残りを</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>  <span class="c1">-- anyCharで処理する</span>
    <span class="kr">in</span> <span class="p">(</span><span class="n">x1</span> <span class="o">++</span> <span class="p">[</span><span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">test1</span>   <span class="s">"abc"</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">test2</span>   <span class="s">"abc"</span>        <span class="c1">-- 追加</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
('a',"bc")
("ab","c")
("abc","")
</pre></div>
</div>

<p><code>test1</code>は<code>anyChar</code>を2つ組み合わせて作ったパーサです。<code>test2</code>は<code>test1</code>と<code>anyChar</code>を組み合わせて作ったパーサです。このように簡単なパーサを組み合わせて複雑なパーサを作っていくのが、パーサコンビネータの基本的な考え方です。</p>

<p><code>main</code>の中で<code>anyChar</code>と<code>test1</code>と<code>test2</code>が同列に並んでいますが、どれもパーサとして同じような位置付けだと見立ててください。</p>

<h3>
<span id="エラー" class="fragment"></span><a href="#%E3%82%A8%E3%83%A9%E3%83%BC"><i class="fa fa-link"></i></a>エラー</h3>

<p>文字数が足りなければエラーで止まります。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">test1</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">test2</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">test1</span>   <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">(</span><span class="n">x1</span> <span class="o">++</span> <span class="p">[</span><span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">test1</span>   <span class="s">"abc"</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">test2</span>   <span class="s">"abc"</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">test2</span>   <span class="s">"12"</span>   <span class="c1">-- エラー</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">test2</span>   <span class="s">"123"</span>  <span class="c1">-- ここに来ない</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
('a',"bc")
("ab","c")
("abc","")
xxx: Main.hs:1:1-24: Non-exhaustive patterns in function anyChar

</pre></div>
</div>

<h3>
<span id="テスト関数" class="fragment"></span><a href="#%E3%83%86%E3%82%B9%E3%83%88%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>テスト関数</h3>

<p>エラーが出ても続行できるように、テスト用の関数<code>parseTest</code>を作成して例外を処理します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Exception</span>           <span class="c1">-- 追加</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span>                 <span class="c1">-- 追加</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">p</span> <span class="n">s</span>              <span class="c1">-- タプルの第1要素を表示</span>
    <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="p">(</span><span class="kt">SomeException</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="n">putStr</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>

<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">test1</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">test2</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">test1</span>   <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">(</span><span class="n">x1</span> <span class="o">++</span> <span class="p">[</span><span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test1</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"12"</span>         <span class="c1">-- エラー</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"123"</span>        <span class="c1">-- 続行</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
"ab"
"abc"
Main.hs:8:1-24: Non-exhaustive patterns in function anyChar
"123"
</pre></div>
</div>

<h3>
<span id="条件取得" class="fragment"></span><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%96%E5%BE%97"><i class="fa fa-link"></i></a>条件取得</h3>

<p><code>anyChar</code>は無条件で文字を取得していましたが、条件が指定できる<code>satisfy</code>を追加します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Exception</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>                        <span class="c1">-- 追加</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">p</span> <span class="n">s</span>
    <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="p">(</span><span class="kt">SomeException</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="n">putStr</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>

<span class="nf">anyChar</span>   <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>       <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">satisfy</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>        <span class="c1">-- 追加</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">'a'</span><span class="p">))</span> <span class="s">"abc"</span>  <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">'a'</span><span class="p">))</span> <span class="s">"123"</span>  <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">isDigit</span> <span class="p">)</span> <span class="s">"abc"</span>  <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">isDigit</span> <span class="p">)</span> <span class="s">"123"</span>  <span class="c1">-- OK</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
'1'
</pre></div>
</div>

<p>今回の機能追加に直接関係ない<code>test1</code>と<code>test2</code>は削除しました。</p>

<h3>
<span id="事前定義" class="fragment"></span><a href="#%E4%BA%8B%E5%89%8D%E5%AE%9A%E7%BE%A9"><i class="fa fa-link"></i></a>事前定義</h3>

<p><code>satisfy</code>で条件を指定するのは冗長なので、よく使うパターンを事前定義します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Exception</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">p</span> <span class="n">s</span>
    <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="p">(</span><span class="kt">SomeException</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="n">putStr</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>

<span class="nf">anyChar</span>   <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>       <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">satisfy</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>         <span class="c1">-- 追加</span>
<span class="nf">digit</span>  <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>        <span class="c1">-- 追加</span>
<span class="nf">letter</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span>       <span class="c1">-- 追加</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"abc"</span>  <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"123"</span>  <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"123"</span>      <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"abc"</span>      <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"123"</span>      <span class="c1">-- NG</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
'1'
'a'
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
</pre></div>
</div>

<h3>
<span id="組み合わせ判定" class="fragment"></span><a href="#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E5%88%A4%E5%AE%9A"><i class="fa fa-link"></i></a>組み合わせ判定</h3>

<p>先ほど追加したパーサを組み合わせて、先頭から「アルファベット」「数字」「数字」という組み合わせを判定するパーサを示します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Exception</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">p</span> <span class="n">s</span>
    <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="p">(</span><span class="kt">SomeException</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="n">putStr</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>

<span class="nf">anyChar</span>   <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>       <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">satisfy</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">digit</span>  <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>
<span class="nf">letter</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span>

<span class="nf">test3</span> <span class="n">xs0</span> <span class="ow">=</span>                     <span class="c1">-- 追加</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">letter</span> <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">digit</span>  <span class="n">xs1</span>
        <span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">xs3</span><span class="p">)</span> <span class="ow">=</span> <span class="n">digit</span>  <span class="n">xs2</span>
    <span class="kr">in</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">],</span> <span class="n">xs3</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"abc"</span>       <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"123"</span>       <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"a23"</span>       <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"a234"</span>      <span class="c1">-- OK</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
"a23"
"a23"
</pre></div>
</div>

<h3>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h3>

<p>ここまでがパーサコンビネータの動作原理を理解するために最低限必要な実装です。登場したテストを1つにまとめます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Exception</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">p</span> <span class="n">s</span>
    <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="p">(</span><span class="kt">SomeException</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="n">putStr</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>

<span class="nf">anyChar</span>   <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>       <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">satisfy</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">digit</span>  <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>
<span class="nf">letter</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span>

<span class="nf">test1</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">test2</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">test1</span>   <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="kr">in</span> <span class="p">(</span><span class="n">x1</span> <span class="o">++</span> <span class="p">[</span><span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">test3</span> <span class="n">xs0</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">letter</span> <span class="n">xs0</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">digit</span>  <span class="n">xs1</span>
        <span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">xs3</span><span class="p">)</span> <span class="ow">=</span> <span class="n">digit</span>  <span class="n">xs2</span>
    <span class="kr">in</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">],</span> <span class="n">xs3</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test1</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"12"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"123"</span>  <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a23"</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a234"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
"ab"
"abc"
Main.hs:9:1-32: Non-exhaustive patterns in function anyChar
"123"
'a'
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
'1'
'a'
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
"a23"
"a23"
</pre></div>
</div>

<p>このコードをモナドで書き換えて、足りない機能を追加します。</p>

<h2>
<span id="stateモナド" class="fragment"></span><a href="#state%E3%83%A2%E3%83%8A%E3%83%89"><i class="fa fa-link"></i></a>Stateモナド</h2>

<p>解析対象の文字列を状態と見なせばStateモナドが使えます。</p>

<h3>
<span id="練習" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92"><i class="fa fa-link"></i></a>練習</h3>

<p>【問1】モナドなしのまとめのコードをStateモナドを使って書き換えてください。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#state%E3%83%A2%E3%83%8A%E3%83%89" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<p>引数が減ってコードが短くなります。元の<code>test1</code>などにあった <code>xs0</code> → <code>xs1</code> → <code>xs2</code> という状態の受け渡しが省略されたことで、変数名の管理も簡単になります。</p>

<h3>
<span id="sequence" class="fragment"></span><a href="#sequence"><i class="fa fa-link"></i></a>sequence</h3>

<p>モナド化したことで連続した文字取得は<code>sequence</code>を使って簡単に書けます。</p>

<p>競合を避けるためControl.Applicativeは選択的に<code>import</code>します。選択する対象全体を括弧で囲みますが、演算子は個別に括弧で囲むため、結果として二重に括弧で囲むことになります。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Exception</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;$&gt;</span><span class="p">),</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">))</span>      <span class="c1">-- 選択的import</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">evalState</span> <span class="n">p</span> <span class="n">s</span>
    <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="p">(</span><span class="kt">SomeException</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="n">putStr</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>

<span class="nf">anyChar</span> <span class="ow">=</span> <span class="n">state</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="kr">where</span>
    <span class="n">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">satisfy</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">String</span> <span class="kt">Char</span>
<span class="nf">satisfy</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">state</span> <span class="o">$</span> <span class="n">satisfy</span> <span class="kr">where</span>
    <span class="n">satisfy</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">digit</span>  <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>
<span class="nf">letter</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span>

<span class="nf">test1</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">anyChar</span><span class="p">,</span> <span class="n">anyChar</span><span class="p">]</span>            <span class="c1">-- 単純化</span>
<span class="nf">test2</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">test1</span> <span class="o">&lt;*&gt;</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">anyChar</span><span class="p">]</span>  <span class="c1">-- 少しややこしい</span>
<span class="nf">test3</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="n">digit</span><span class="p">,</span> <span class="n">digit</span><span class="p">]</span>        <span class="c1">-- 単純化</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test1</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span> <span class="s">"12"</span>                       <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test2</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"abc"</span>                      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"123"</span>                      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"a23"</span>
    <span class="n">parseTest</span> <span class="n">test3</span> <span class="s">"a234"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
"abc"
Main.hs:13:5-28: Non-exhaustive patterns in function anyChar
"123"
Main.hs:17:5-34: Non-exhaustive patterns in function satisfy
Main.hs:17:5-34: Non-exhaustive patterns in function satisfy
"a23"
"a23"
</pre></div>
</div>

<h2>
<span id="maybeモナド" class="fragment"></span><a href="#maybe%E3%83%A2%E3%83%8A%E3%83%89"><i class="fa fa-link"></i></a>Maybeモナド</h2>

<p>Maybeモナドを使えば例外を使わずに失敗が扱えます。</p>

<h3>
<span id="練習-1" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-1"><i class="fa fa-link"></i></a>練習</h3>

<p>【問2】モナドなしのまとめのコードをMaybeモナドを使って書き換えてください。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#maybe%E3%83%A2%E3%83%8A%E3%83%89" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<h2>
<span id="eitherモナド" class="fragment"></span><a href="#either%E3%83%A2%E3%83%8A%E3%83%89"><i class="fa fa-link"></i></a>Eitherモナド</h2>

<p>Maybeモナドにより例外処理をなくしても、失敗はすべて<code>Nothing</code>のため理由がよく分かりません。</p>

<p>Eitherモナドを使って、失敗した理由を<code>Left</code>で返します。Either用の<code>&lt;|&gt;</code>を独自に定義します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">p</span> <span class="n">s</span> <span class="kr">of</span>
    <span class="kt">Right</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">print</span> <span class="n">r</span>
    <span class="kt">Left</span>  <span class="n">e</span>      <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"["</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span> <span class="o">++</span> <span class="s">"] "</span> <span class="o">++</span> <span class="n">e</span>

<span class="nf">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">anyChar</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="kt">Left</span> <span class="s">"too short"</span>

<span class="nf">satisfy</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">not</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">": "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
<span class="nf">satisfy</span> <span class="n">f</span>    <span class="n">xs</span>              <span class="ow">=</span> <span class="n">anyChar</span> <span class="n">xs</span>

<span class="kt">Left</span> <span class="n">a</span> <span class="o">&lt;|&gt;</span> <span class="kt">Left</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
<span class="kt">Left</span> <span class="kr">_</span> <span class="o">&lt;|&gt;</span> <span class="n">b</span>      <span class="ow">=</span> <span class="n">b</span>
<span class="nf">a</span>      <span class="o">&lt;|&gt;</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="n">a</span>

<span class="nf">char</span> <span class="n">c</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>   <span class="n">xs</span> <span class="o">&lt;|&gt;</span> <span class="kt">Left</span> <span class="p">(</span><span class="s">"not char "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">digit</span>  <span class="n">xs</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>  <span class="n">xs</span> <span class="o">&lt;|&gt;</span> <span class="kt">Left</span> <span class="s">"not digit"</span>
<span class="nf">letter</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span> <span class="n">xs</span> <span class="o">&lt;|&gt;</span> <span class="kt">Left</span> <span class="s">"not letter"</span>

<span class="nf">test1</span> <span class="n">xs0</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">anyChar</span> <span class="n">xs0</span>
    <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="n">return</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">test2</span> <span class="n">xs0</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">test1</span>   <span class="n">xs0</span>
    <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">anyChar</span> <span class="n">xs1</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">x1</span> <span class="o">++</span> <span class="p">[</span><span class="n">x2</span><span class="p">],</span> <span class="n">xs2</span><span class="p">)</span>

<span class="nf">test3</span> <span class="n">xs0</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">xs1</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">letter</span> <span class="n">xs0</span>
    <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">digit</span>  <span class="n">xs1</span>
    <span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">xs3</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">digit</span>  <span class="n">xs2</span>
    <span class="n">return</span> <span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">],</span> <span class="n">xs3</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test1</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"12"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"123"</span>  <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a23"</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a234"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
"ab"
"abc"
["12"] too short
"123"
'a'
["123"] not char 'a': '1'
["abc"] not digit: 'a'
'1'
'a'
["123"] not letter: '1'
["abc"] not digit: 'b'
["123"] not letter: '1'
"a23"
"a23"
</pre></div>
</div>

<p>エラーメッセージをカスタマイズして分かりやすくなりました。</p>

<h2>
<span id="モナド変換子で合成" class="fragment"></span><a href="#%E3%83%A2%E3%83%8A%E3%83%89%E5%A4%89%E6%8F%9B%E5%AD%90%E3%81%A7%E5%90%88%E6%88%90"><i class="fa fa-link"></i></a>モナド変換子で合成</h2>

<p>StateTモナド変換子でEitherモナドと合成すれば、StateモナドとEitherモナドの両方の特徴が使えます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;$&gt;</span><span class="p">),</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">evalStateT</span> <span class="n">p</span> <span class="n">s</span> <span class="kr">of</span>
    <span class="kt">Right</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">print</span> <span class="n">r</span>
    <span class="kt">Left</span>  <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"["</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span> <span class="o">++</span> <span class="s">"] "</span> <span class="o">++</span> <span class="n">e</span>

<span class="nf">anyChar</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="kr">where</span>
    <span class="n">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">anyChar</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="kt">Left</span> <span class="s">"too short"</span>

<span class="nf">satisfy</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="n">satisfy</span> <span class="kr">where</span>
    <span class="n">satisfy</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">not</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">": "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
    <span class="n">satisfy</span>    <span class="n">xs</span>              <span class="ow">=</span> <span class="n">runStateT</span> <span class="n">anyChar</span> <span class="n">xs</span>

<span class="p">(</span><span class="kt">StateT</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span>
    <span class="p">(</span><span class="n">a</span> <span class="n">s</span><span class="p">)</span>  <span class="o">&lt;|&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Left</span> <span class="n">a</span> <span class="o">&lt;|&gt;</span> <span class="kt">Left</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
    <span class="kt">Left</span> <span class="kr">_</span> <span class="o">&lt;|&gt;</span> <span class="n">b</span>      <span class="ow">=</span> <span class="n">b</span>
    <span class="n">a</span>      <span class="o">&lt;|&gt;</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="n">a</span>

<span class="nf">left</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="kt">Left</span>

<span class="nf">char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>   <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="p">(</span><span class="s">"not char "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">digit</span>  <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>  <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="s">"not digit"</span>
<span class="nf">letter</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span> <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="s">"not letter"</span>

<span class="nf">test1</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">anyChar</span><span class="p">,</span> <span class="n">anyChar</span><span class="p">]</span>
<span class="nf">test2</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">test1</span> <span class="o">&lt;*&gt;</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">anyChar</span><span class="p">]</span>
<span class="nf">test3</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="n">digit</span><span class="p">,</span> <span class="n">digit</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test1</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"12"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"123"</span>  <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a23"</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a234"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
"ab"
"abc"
["12"] too short
"123"
'a'
["123"] not char 'a': '1'
["abc"] not digit: 'a'
'1'
'a'
["123"] not letter: '1'
["abc"] not digit: 'b'
["123"] not letter: '1'
"a23"
"a23"
</pre></div>
</div>

<p>合成による複雑さが<code>&lt;|&gt;</code>に集約されています。こういったものは通常はライブラリが用意するので、あまり意識する必要はない部分ではあります。</p>

<h3>
<span id="選択" class="fragment"></span><a href="#%E9%81%B8%E6%8A%9E"><i class="fa fa-link"></i></a>選択</h3>

<p><code>&lt;|&gt;</code>を使えば「アルファベットまたは数字」のような選択的なパーサを構築できます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;$&gt;</span><span class="p">),</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">evalStateT</span> <span class="n">p</span> <span class="n">s</span> <span class="kr">of</span>
    <span class="kt">Right</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">print</span> <span class="n">r</span>
    <span class="kt">Left</span>  <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"["</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span> <span class="o">++</span> <span class="s">"] "</span> <span class="o">++</span> <span class="n">e</span>

<span class="nf">anyChar</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="kr">where</span>
    <span class="n">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">anyChar</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="kt">Left</span> <span class="s">"too short"</span>

<span class="nf">satisfy</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="n">satisfy</span> <span class="kr">where</span>
    <span class="n">satisfy</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">not</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">": "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
    <span class="n">satisfy</span>    <span class="n">xs</span>              <span class="ow">=</span> <span class="n">runStateT</span> <span class="n">anyChar</span> <span class="n">xs</span>

<span class="p">(</span><span class="kt">StateT</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span>
    <span class="p">(</span><span class="n">a</span> <span class="n">s</span><span class="p">)</span>  <span class="o">&lt;|&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Left</span> <span class="n">a</span> <span class="o">&lt;|&gt;</span> <span class="kt">Left</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
    <span class="kt">Left</span> <span class="kr">_</span> <span class="o">&lt;|&gt;</span> <span class="n">b</span>      <span class="ow">=</span> <span class="n">b</span>
    <span class="n">a</span>      <span class="o">&lt;|&gt;</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="n">a</span>

<span class="nf">left</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="kt">Left</span>

<span class="nf">char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>   <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="p">(</span><span class="s">"not char "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">digit</span>  <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>  <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="s">"not digit"</span>
<span class="nf">letter</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span> <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="s">"not letter"</span>

<span class="nf">test4</span> <span class="ow">=</span> <span class="n">letter</span> <span class="o">&lt;|&gt;</span> <span class="n">digit</span>  <span class="c1">-- 選択</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test4</span> <span class="s">"a"</span>   <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">test4</span> <span class="s">"1"</span>   <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">test4</span> <span class="s">"!"</span>   <span class="c1">-- NG</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
'1'
["!"] not digit: '!'not letter: '!'
</pre></div>
</div>

<p>エラーがごちゃごちゃしていますが、動作原理の説明が目的のため気にしないことにします。</p>

<h3>
<span id="関数で繰り返し" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E3%81%A7%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97"><i class="fa fa-link"></i></a>関数で繰り返し</h3>

<p>モナドは関数で繰り返しを表現できます。「先頭がアルファベットで、その後に3桁の数字が続く」というパーサを見てみます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;$&gt;</span><span class="p">),</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">parseTest</span> <span class="n">p</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">evalStateT</span> <span class="n">p</span> <span class="n">s</span> <span class="kr">of</span>
    <span class="kt">Right</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">print</span> <span class="n">r</span>
    <span class="kt">Left</span>  <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"["</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span> <span class="o">++</span> <span class="s">"] "</span> <span class="o">++</span> <span class="n">e</span>

<span class="nf">anyChar</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="n">anyChar</span> <span class="kr">where</span>
    <span class="n">anyChar</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">anyChar</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="kt">Left</span> <span class="s">"too short"</span>

<span class="nf">satisfy</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="n">satisfy</span> <span class="kr">where</span>
    <span class="n">satisfy</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">not</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">": "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
    <span class="n">satisfy</span>    <span class="n">xs</span>              <span class="ow">=</span> <span class="n">runStateT</span> <span class="n">anyChar</span> <span class="n">xs</span>

<span class="p">(</span><span class="kt">StateT</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span>
    <span class="p">(</span><span class="n">a</span> <span class="n">s</span><span class="p">)</span>  <span class="o">&lt;|&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Left</span> <span class="n">a</span> <span class="o">&lt;|&gt;</span> <span class="kt">Left</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">$</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
    <span class="kt">Left</span> <span class="kr">_</span> <span class="o">&lt;|&gt;</span> <span class="n">b</span>      <span class="ow">=</span> <span class="n">b</span>
    <span class="n">a</span>      <span class="o">&lt;|&gt;</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="n">a</span>

<span class="nf">left</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="kt">Left</span>

<span class="nf">char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span>   <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="p">(</span><span class="s">"not char "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">digit</span>  <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>  <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="s">"not digit"</span>
<span class="nf">letter</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isLetter</span> <span class="o">&lt;|&gt;</span> <span class="n">left</span> <span class="s">"not letter"</span>

<span class="nf">test5</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="n">digit</span><span class="p">,</span> <span class="n">digit</span><span class="p">,</span> <span class="n">digit</span><span class="p">]</span>  <span class="c1">-- ベタ書き</span>
<span class="nf">test6</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="o">$</span> <span class="n">letter</span> <span class="kt">:</span> <span class="n">replicate</span> <span class="mi">3</span> <span class="n">digit</span>   <span class="c1">-- 関数使用</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test5</span> <span class="s">"a123"</span>                      <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">test5</span> <span class="s">"ab123"</span>                     <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test6</span> <span class="s">"a123"</span>                      <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">test6</span> <span class="s">"ab123"</span>                     <span class="c1">-- NG</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"a123"
["ab123"] not digit: 'b'
"a123"
["ab123"] not digit: 'b'
</pre></div>
</div>

<p>文字通り「モナドを部品として組み合わせてパーサを構築」というコードです。工夫すれば色々できそうだと気付けばしめたものです。</p>

<h2>
<span id="練習-2" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-2"><i class="fa fa-link"></i></a>練習</h2>

<p>【問3】指定したパーサを0回以上適用して返すコンビネータ<code>many</code>を実装してください。</p>

<p>具体的には次のコードが動くようにしてください。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">test7</span> <span class="ow">=</span> <span class="n">many</span> <span class="n">letter</span>
<span class="nf">test8</span> <span class="ow">=</span> <span class="n">many</span> <span class="p">(</span><span class="n">letter</span> <span class="o">&lt;|&gt;</span> <span class="n">digit</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test7</span> <span class="s">"abc123"</span>
    <span class="n">parseTest</span> <span class="n">test7</span> <span class="s">"123abc"</span>
    <span class="n">parseTest</span> <span class="n">test8</span> <span class="s">"abc123"</span>
    <span class="n">parseTest</span> <span class="n">test8</span> <span class="s">"123abc"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"abc"
""
"abc123"
"123abc"
</pre></div>
</div>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#many" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<h1>
<span id="parsec" class="fragment"></span><a href="#parsec"><i class="fa fa-link"></i></a>Parsec</h1>

<p>ここまで実装して来たパーサはすべてParsecというライブラリで提供されています。Parsecと関数名を合わせたため、今までのテストがそのまま実行できます。</p>

<p>依存パッケージ: <a href="https://hackage.haskell.org/package/parsec" rel="nofollow noopener" target="_blank">parsec</a></p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;$&gt;</span><span class="p">),</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">))</span>

<span class="nf">test1</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">anyChar</span><span class="p">,</span> <span class="n">anyChar</span><span class="p">]</span>
<span class="nf">test2</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">test1</span> <span class="o">&lt;*&gt;</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">anyChar</span><span class="p">]</span>
<span class="nf">test3</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="n">digit</span><span class="p">,</span> <span class="n">digit</span><span class="p">]</span>
<span class="nf">test4</span> <span class="ow">=</span> <span class="n">letter</span> <span class="o">&lt;|&gt;</span> <span class="n">digit</span>
<span class="nf">test5</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="n">digit</span><span class="p">,</span> <span class="n">digit</span><span class="p">,</span> <span class="n">digit</span><span class="p">]</span>
<span class="nf">test6</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="o">$</span> <span class="n">letter</span> <span class="kt">:</span> <span class="n">replicate</span> <span class="mi">3</span> <span class="n">digit</span>
<span class="nf">test7</span> <span class="ow">=</span> <span class="n">many</span> <span class="n">letter</span>
<span class="nf">test8</span> <span class="ow">=</span> <span class="n">many</span> <span class="p">(</span><span class="n">letter</span> <span class="o">&lt;|&gt;</span> <span class="n">digit</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">anyChar</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test1</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"12"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test2</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">char</span> <span class="n">'a'</span><span class="p">)</span> <span class="s">"123"</span>  <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">digit</span>  <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"abc"</span>
    <span class="n">parseTest</span> <span class="n">letter</span> <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"abc"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"123"</span>      <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a23"</span>
    <span class="n">parseTest</span> <span class="n">test3</span>  <span class="s">"a234"</span>
    <span class="n">parseTest</span> <span class="n">test4</span>  <span class="s">"a"</span>
    <span class="n">parseTest</span> <span class="n">test4</span>  <span class="s">"1"</span>
    <span class="n">parseTest</span> <span class="n">test4</span>  <span class="s">"!"</span>        <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test5</span>  <span class="s">"a123"</span>
    <span class="n">parseTest</span> <span class="n">test5</span>  <span class="s">"ab123"</span>    <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test6</span>  <span class="s">"a123"</span>
    <span class="n">parseTest</span> <span class="n">test6</span>  <span class="s">"ab123"</span>    <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">test7</span>  <span class="s">"abc123"</span>
    <span class="n">parseTest</span> <span class="n">test7</span>  <span class="s">"123abc"</span>
    <span class="n">parseTest</span> <span class="n">test8</span>  <span class="s">"abc123"</span>
    <span class="n">parseTest</span> <span class="n">test8</span>  <span class="s">"123abc"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
"ab"
"abc"
parse error at (line 1, column 3):
unexpected end of input
"123"
'a'
parse error at (line 1, column 1):
unexpected "1"
expecting "a"
parse error at (line 1, column 1):
unexpected "a"
expecting digit
'1'
'a'
parse error at (line 1, column 1):
unexpected "1"
expecting letter
parse error at (line 1, column 2):
unexpected "b"
expecting digit
parse error at (line 1, column 1):
unexpected "1"
expecting letter
"a23"
"a23"
'a'
'1'
parse error at (line 1, column 1):
unexpected "!"
expecting letter or digit
"a123"
parse error at (line 1, column 2):
unexpected "b"
expecting digit
"a123"
parse error at (line 1, column 2):
unexpected "b"
expecting digit
"abc"
""
"abc123"
"123abc"
</pre></div>
</div>

<p>エラーメッセージが詳細です。</p>

<h2>
<span id="エラーチェック" class="fragment"></span><a href="#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>エラーチェック</h2>

<p>Parsecでは<code>&lt;|&gt;</code>でエラーが細かくチェックされます。</p>

<p><code>左 &lt;|&gt; 右</code>として、左のパーサが内部で複数のパーサから構成されるとき、そのうち1つでも成功してその後で失敗したなら、右のパーサは処理されずにエラーとなります。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">test9</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'b'</span><span class="p">]</span>  <span class="c1">-- 'a'が成功して'b'で失敗したらエラー</span>
    <span class="o">&lt;|&gt;</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'c'</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test9</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test9</span> <span class="s">"ac"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
parse error at (line 1, column 2):
unexpected "c"
expecting "b"
</pre></div>
</div>

<p>この挙動を把握しておかないとハマります。</p>

<h3>
<span id="練習-3" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-3"><i class="fa fa-link"></i></a>練習</h3>

<p>【問4】問3の解答の自前実装では失敗時に返される<code>Left</code>に状態が含まれず、1つでも成功していたかが判断できません。<code>left</code>を次のように修正することで状態を返して、Parsecと同じようにエラーをチェックしてください。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">left</span> <span class="n">e</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div></div>

<p>具体的には次のコードで2番目のテストが失敗するようにしてください。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">test9</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'b'</span><span class="p">]</span>
    <span class="o">&lt;|&gt;</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'c'</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test9</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test9</span> <span class="s">"ac"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
["ac"] not char 'b': 'c'
</pre></div>
</div>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<h2>
<span id="バックトラック" class="fragment"></span><a href="#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>バックトラック</h2>

<p>パースに失敗したとき、状態を巻き戻して別の方法でパースをやり直すことを<strong>バックトラック</strong>と呼びます。</p>

<h3>
<span id="try" class="fragment"></span><a href="#try"><i class="fa fa-link"></i></a>try</h3>

<p>バックトラックするには対象となるパーサを<code>try</code>で囲みます。失敗すると元の状態に戻って<code>&lt;|&gt;</code>の右のパーサが処理されます。</p>

<p>※ 例外処理の<code>try</code>と同名ですが、別の関数です。</p>

<p>エラーチェックで登場した<code>test9</code>と挙動を比較します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">test9</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'b'</span><span class="p">]</span>
    <span class="o">&lt;|&gt;</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'c'</span><span class="p">]</span>
<span class="nf">test10</span> <span class="ow">=</span> <span class="n">try</span> <span class="p">(</span><span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'b'</span><span class="p">])</span>
         <span class="o">&lt;|&gt;</span>  <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'c'</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test9</span>  <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test9</span>  <span class="s">"ac"</span>
    <span class="n">parseTest</span> <span class="n">test10</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test10</span> <span class="s">"ac"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
parse error at (line 1, column 2):
unexpected "c"
expecting "b"
"ab"
"ac"
</pre></div>
</div>

<h3>
<span id="string" class="fragment"></span><a href="#string"><i class="fa fa-link"></i></a>string</h3>

<p>1文字ずつ<code>char</code>でパースしなくても、文字列で指定できる<code>string</code>があります。ただし内部では1文字ずつ処理されているため、途中の失敗をバックトラックするには<code>try</code>が必要です。</p>

<p>挙動の違いを比較します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">test11</span> <span class="ow">=</span>      <span class="n">string</span> <span class="s">"ab"</span>  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"ac"</span>
<span class="nf">test12</span> <span class="ow">=</span> <span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">"ab"</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"ac"</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test11</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test11</span> <span class="s">"ac"</span>
    <span class="n">parseTest</span> <span class="n">test12</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test12</span> <span class="s">"ac"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
parse error at (line 1, column 1):
unexpected "c"
expecting "ab"
"ab"
"ac"
</pre></div>
</div>

<p>デフォルトのトランザクションの範囲は<code>char</code>で、<code>string</code><strong>ではない</strong>と解釈できます。<code>try</code>によってトランザクションの範囲を広げることになります。</p>

<h3>
<span id="ll1" class="fragment"></span><a href="#ll1"><i class="fa fa-link"></i></a>LL(1)</h3>

<p>バックトラックなしで処理できる文法をLL(1)文法と呼びます。</p>

<ul>
<li><a href="https://ja.wikipedia.org/wiki/LL%E6%B3%95" rel="nofollow noopener" target="_blank">LL法 - Wikipedia</a></li>
</ul>

<p>以下の記事にParsecはLL(1)で最高の性能を発揮するとあります。</p>

<ul>
<li>
<a href="https://twitter.com/kazu_yamamoto" rel="nofollow noopener" target="_blank">@kazu_yamamoto</a>: <a href="http://d.hatena.ne.jp/kazu-yamamoto/20081201/1228115457" rel="nofollow noopener" target="_blank">とりとめのないパーサー談義 - あどけない話</a> 2008.12.1</li>
</ul>

<p>先ほどの<code>test10</code>は、重複する<code>char 'a'</code>をまとめることでバックトラックのないLL(1)となります。両者を比較します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">test10</span> <span class="ow">=</span> <span class="n">try</span> <span class="p">(</span><span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'b'</span><span class="p">])</span>
         <span class="o">&lt;|&gt;</span>  <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'c'</span><span class="p">]</span>
<span class="nf">test13</span> <span class="ow">=</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'b'</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="n">'c'</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test10</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test10</span> <span class="s">"ac"</span>
    <span class="n">parseTest</span> <span class="n">test13</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test13</span> <span class="s">"ac"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
"ac"
"ab"
"ac"
</pre></div>
</div>

<p>この例によりLL(1)が高速な理由が直感的に伝わるでしょうか？</p>

<p><code>test10</code>から<code>test13</code>への変形は数式の因数分解に似ています。コードでの<code>&lt;|&gt;</code>を足し算、<code>,</code>を掛け算に見立てます。簡単のため<code>sequence</code>を省略して比較します。</p>

<table>
<tr>
<th>コード</th>
<th>数式</th>
</tr>
<tr>
<td><code>[char 'a', char 'b'] &lt;|&gt; [char 'a', char 'c']</code></td>
<td>$ab + ac$</td>
</tr>
<tr>
<td><code>[char 'a', char 'b' &lt;|&gt; char 'c']</code></td>
<td>$a(b + c)$</td>
</tr>
</table>

<h3>
<span id="練習-4" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-4"><i class="fa fa-link"></i></a>練習</h3>

<p>【問5】問4の解答の自前実装に<code>try</code>と<code>string</code>を実装してください。</p>

<p>具体的には次のコードが動くようにしてください。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">test10</span> <span class="ow">=</span> <span class="n">try</span> <span class="p">(</span><span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'b'</span><span class="p">])</span>
         <span class="o">&lt;|&gt;</span>  <span class="n">sequence</span> <span class="p">[</span><span class="n">char</span> <span class="n">'a'</span><span class="p">,</span> <span class="n">char</span> <span class="n">'c'</span><span class="p">]</span>
<span class="nf">test11</span> <span class="ow">=</span>      <span class="n">string</span> <span class="s">"ab"</span>  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"ac"</span>
<span class="nf">test12</span> <span class="ow">=</span> <span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">"ab"</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"ac"</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test10</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test10</span> <span class="s">"ac"</span>
    <span class="n">parseTest</span> <span class="n">test11</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test11</span> <span class="s">"ac"</span>
    <span class="n">parseTest</span> <span class="n">test12</span> <span class="s">"ab"</span>
    <span class="n">parseTest</span> <span class="n">test12</span> <span class="s">"ac"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"ab"
"ac"
"ab"
["ac"] not char 'b': 'c'
"ab"
"ac"
</pre></div>
</div>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<h1>
<span id="四則演算器" class="fragment"></span><a href="#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97%E5%99%A8"><i class="fa fa-link"></i></a>四則演算器</h1>

<p>Parsecの練習として、簡単な四則演算器を作ります。文字列で式を与えると計算して答えを返します。</p>

<p>例: <code>"1+2*3"</code> → <code>7</code></p>

<p>ここから先の内容から構文解析に関係する部分を省いて計算だけに特化した記事があります。<code>many</code>がないため作り方が少し違います。</p>

<ul>
<li><a href="http://qiita.com/7shi/items/ee5afe4f088f0a1fc8c2">Stateモナドによる中置記法の処理</a></li>
</ul>

<h2>
<span id="数字" class="fragment"></span><a href="#%E6%95%B0%E5%AD%97"><i class="fa fa-link"></i></a>数字</h2>

<p>数字を読み込むパーサを実装します。最低でも1文字は必要なため<code>many</code>（0回以上の繰り返し）ではなく<code>many1</code>（1回以上の繰り返し）を使います。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="n">many1</span> <span class="n">digit</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"123"
</pre></div>
</div>

<h3>
<span id="数値" class="fragment"></span><a href="#%E6%95%B0%E5%80%A4"><i class="fa fa-link"></i></a>数値</h3>

<p>結果を数値で返すように修正します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>  <span class="c1">-- 変換</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
</pre></div>
</div>

<h2>
<span id="足し算" class="fragment"></span><a href="#%E8%B6%B3%E3%81%97%E7%AE%97"><i class="fa fa-link"></i></a>足し算</h2>

<p>足し算を計算するパーサを実装します。</p>

<p><code>'+'</code>で区切って項を個別に取り出します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kr">do</span>                   <span class="c1">-- 追加</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">number</span>
    <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span>
    <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
    <span class="n">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2"</span>  <span class="c1">-- 追加</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
[1,2]
</pre></div>
</div>

<h3>
<span id="many" class="fragment"></span><a href="#many"><i class="fa fa-link"></i></a>many</h3>

<p><code>+数値</code>を<code>many</code>により0回以上の繰り返しとして扱います。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span>  <span class="ow">&lt;-</span> <span class="n">number</span>
    <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="o">$</span> <span class="kr">do</span>           <span class="c1">-- 繰り返し</span>
        <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span>
        <span class="n">number</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span>             <span class="c1">-- 連結</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2"</span>    <span class="c1">-- '+'が1個</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"123"</span>    <span class="c1">-- '+'が0個</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2+3"</span>  <span class="c1">-- '+'が2個</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
[1,2]
[123]
[1,2,3]
</pre></div>
</div>

<h3>
<span id="sum" class="fragment"></span><a href="#sum"><i class="fa fa-link"></i></a>sum</h3>

<p>リストを合計すれば計算できます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span>  <span class="ow">&lt;-</span> <span class="n">number</span>
    <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span>
        <span class="n">number</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span>       <span class="c1">-- 合計</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2"</span>    <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"123"</span>    <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2+3"</span>  <span class="c1">-- OK</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
3
123
6
</pre></div>
</div>

<p>構文解析と計算を分離せずに同時に処理しているのがポイントです。</p>

<h2>
<span id="引き算" class="fragment"></span><a href="#%E5%BC%95%E3%81%8D%E7%AE%97"><i class="fa fa-link"></i></a>引き算</h2>

<p>マイナスの項を足すとして処理します。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span>  <span class="ow">&lt;-</span> <span class="n">number</span>
    <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span>
            <span class="n">number</span>
        <span class="o">&lt;|&gt;</span> <span class="kr">do</span>                <span class="c1">-- 追加</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">-</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
            <span class="n">return</span> <span class="o">$</span> <span class="o">-</span><span class="n">y</span>       <span class="c1">-- マイナスの項</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2+3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2-3"</span>  <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2+3"</span>  <span class="c1">-- OK</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
3
123
6
-4
2
</pre></div>
</div>

<h2>
<span id="四則演算" class="fragment"></span><a href="#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97"><i class="fa fa-link"></i></a>四則演算</h2>

<p>掛け算や割り算は<code>sum</code>では処理できないため、<code>many</code>で関数のリストを返して<code>foldl</code>で畳み込みます。</p>

<p>引き算でセクションを作ろうとすると単項演算子扱いされてしまうため、代用関数<code>subtract</code>を使います。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span>  <span class="ow">&lt;-</span> <span class="n">number</span>
    <span class="n">fs</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
            <span class="n">return</span> <span class="p">(</span><span class="o">+</span> <span class="n">y</span><span class="p">)</span>               <span class="c1">-- セクション</span>
        <span class="o">&lt;|&gt;</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">-</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
            <span class="n">return</span> <span class="o">$</span> <span class="n">subtract</span> <span class="n">y</span>        <span class="c1">-- 部分適用</span>
        <span class="o">&lt;|&gt;</span> <span class="kr">do</span>                         <span class="c1">-- 追加：ここから</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">*</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
            <span class="n">return</span> <span class="p">(</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span>
        <span class="o">&lt;|&gt;</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">/</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
            <span class="n">return</span> <span class="p">(`</span><span class="n">div</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span>           <span class="c1">-- 追加：ここまで</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">x</span> <span class="n">fs</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2+3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2-3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2+3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"2*3+4"</span>           <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"2+3*4"</span>           <span class="c1">-- NG</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"100/10/2"</span>        <span class="c1">-- OK</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
3
123
6
-4
2
10
20
5
</pre></div>
</div>

<p>演算子の優先順位が処理できていません。</p>

<h3>
<span id="演算子の優先順位" class="fragment"></span><a href="#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%84%AA%E5%85%88%E9%A0%86%E4%BD%8D"><i class="fa fa-link"></i></a>演算子の優先順位</h3>

<p>足し算から見ると、1つの数字と掛け算のブロックは項（term）として対等です。数式で例えると $2x+1$ において $2x$ と $1$ が項という単位として $+$ から並列に扱われていることに相当します。</p>

<p>項単位で計算するように分離すれば演算子の優先順位が表現できます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span>  <span class="ow">&lt;-</span> <span class="n">term</span>                         <span class="c1">-- 項を取得</span>
    <span class="n">fs</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">term</span>                  <span class="c1">-- 項を取得</span>
            <span class="n">return</span> <span class="p">(</span><span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="o">&lt;|&gt;</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">-</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">term</span>                  <span class="c1">-- 項を取得</span>
            <span class="n">return</span> <span class="o">$</span> <span class="n">subtract</span> <span class="n">y</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">x</span> <span class="n">fs</span>

<span class="nf">term</span> <span class="ow">=</span> <span class="kr">do</span>                              <span class="c1">-- exprと同じ構造</span>
    <span class="n">x</span>  <span class="ow">&lt;-</span> <span class="n">number</span>
    <span class="n">fs</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">*</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
            <span class="n">return</span> <span class="p">(</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span>
        <span class="o">&lt;|&gt;</span> <span class="kr">do</span>
            <span class="n">char</span> <span class="n">'</span><span class="o">/</span><span class="n">'</span>
            <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">number</span>
            <span class="n">return</span> <span class="p">(`</span><span class="n">div</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">x</span> <span class="n">fs</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2+3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2-3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2+3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"2*3+4"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"2+3*4"</span>           <span class="c1">-- OK</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"100/10/2"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
3
123
6
-4
2
10
14
5
</pre></div>
</div>

<h2>
<span id="演算子" class="fragment"></span><a href="#%E6%BC%94%E7%AE%97%E5%AD%90"><i class="fa fa-link"></i></a>演算子</h2>

<p>パースに便利な演算子<code>&lt;*</code>を紹介します。Applicativeスタイルの一種です。</p>

<p><code>左 &lt;* 右</code>は右の値を捨てて、左の値を返します。<code>=&lt;&lt;</code>と違って評価の流れを記号化したわけではなく、左から右に評価されます。</p>

<p>一時変数を避けるのに使えます。同じ結果になるのを確認してください。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;*</span><span class="p">))</span>

<span class="nf">test1</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">letter</span>          <span class="c1">-- 一時変数に結果を束縛</span>
    <span class="n">digit</span>                <span class="c1">-- 文字は確認するが結果は捨てる</span>
    <span class="n">return</span> <span class="n">x</span>             <span class="c1">-- 一時変数を返す</span>

<span class="nf">test2</span> <span class="ow">=</span> <span class="n">letter</span> <span class="o">&lt;*</span> <span class="n">digit</span>  <span class="c1">-- test1と同じ処理</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">test1</span> <span class="s">"a1"</span>
    <span class="n">parseTest</span> <span class="n">test2</span> <span class="s">"a1"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
'a'
'a'
</pre></div>
</div>

<p>逆を指す<code>*&gt;</code>もありますが<code>&gt;&gt;</code>と同じです。<code>&lt;*</code>と<code>*&gt;</code>は残す値を指示していると見立てます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;*</span><span class="p">),</span> <span class="p">(</span><span class="o">*&gt;</span><span class="p">))</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span><span class="p">,</span>    <span class="n">digit</span><span class="p">,</span> <span class="n">letter</span><span class="p">])</span> <span class="s">"a1c"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span> <span class="o">&lt;*</span>  <span class="n">digit</span><span class="p">,</span> <span class="n">letter</span><span class="p">])</span> <span class="s">"a1c"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span>  <span class="o">*&gt;</span> <span class="n">digit</span><span class="p">,</span> <span class="n">letter</span><span class="p">])</span> <span class="s">"a1c"</span>
    <span class="n">parseTest</span> <span class="p">(</span><span class="n">sequence</span> <span class="p">[</span><span class="n">letter</span>  <span class="o">&gt;&gt;</span> <span class="n">digit</span><span class="p">,</span> <span class="n">letter</span><span class="p">])</span> <span class="s">"a1c"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
"a1c"
"ac"
"1c"
"1c"
</pre></div>
</div>

<h2>
<span id="整理" class="fragment"></span><a href="#%E6%95%B4%E7%90%86"><i class="fa fa-link"></i></a>整理</h2>

<p>共通する処理を関数化して、Applicativeスタイルでコードを整理します。処理の流れは同じです。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="kr">import</span> <span class="nn">Text.Parsec</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;$&gt;</span><span class="p">),</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">),</span> <span class="p">(</span><span class="o">*&gt;</span><span class="p">))</span>

<span class="nf">eval</span> <span class="n">m</span> <span class="n">fs</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">m</span> <span class="o">&lt;*&gt;</span> <span class="n">fs</span>
<span class="nf">apply</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">flip</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">m</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">term</span> <span class="o">$</span> <span class="n">many</span> <span class="o">$</span>
        <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">term</span>
    <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="n">'</span><span class="o">-</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="n">term</span>

<span class="nf">term</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">number</span> <span class="o">$</span> <span class="n">many</span> <span class="o">$</span>
        <span class="n">char</span> <span class="n">'</span><span class="o">*</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">number</span>
    <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="n">'</span><span class="o">/</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="n">div</span> <span class="n">number</span>

<span class="nf">number</span> <span class="ow">=</span> <span class="n">read</span> <span class="o">&lt;$&gt;</span> <span class="n">many1</span> <span class="n">digit</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">number</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1+2+3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2-3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"1-2+3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"2*3+4"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"2+3*4"</span>
    <span class="n">parseTest</span> <span class="n">expr</span>   <span class="s">"100/10/2"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
123
3
123
6
-4
2
10
14
5
</pre></div>
</div>

<p>簡潔で形式的な記述になりました。いきなりこのコードを見ても形式的過ぎて理解しにくいかもしれませんが、コードの変形過程を追ってみてください。</p>

<h2>
<span id="bnf" class="fragment"></span><a href="#bnf"><i class="fa fa-link"></i></a>BNF</h2>

<p>ここまで実装したような処理はBNF（<a href="https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95" rel="nofollow noopener" target="_blank">バッカス・ナウア記法</a>）と呼ばれる形式言語で記述できます。</p>

<p>拡張版の<a href="https://ja.wikipedia.org/wiki/EBNF" rel="nofollow noopener" target="_blank">EBNF</a>で示します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">EBNF</span></div>
<div class="highlight"><pre>
expr = term  , {"+"|"-", term  }
term = number, {"*"|"/", number}
</pre></div>
</div>

<h3>
<span id="変形" class="fragment"></span><a href="#%E5%A4%89%E5%BD%A2"><i class="fa fa-link"></i></a>変形</h3>

<p>今回のコードに合わせてEBNFを変形します。</p>

<p>演算子それぞれに処理を記述します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">EBNF</span></div>
<div class="highlight"><pre>
expr = term  , {("+", term  ) | ("-", term  )}
term = number, {("*", number) | ("/", number)}
</pre></div>
</div>

<p>この変形は数式の展開に似ています。EBNFの<code>|</code>を足し算、<code>,</code>を掛け算に見立てます。コードでは<code>&lt;|&gt;</code>と<code>*&gt;</code>に相当します。<code>*&gt;</code>は<code>*</code>が掛け算っぽいです。</p>

<table>
<tr>
<th>種類</th>
<th>展開前</th>
<th>展開後</th>
</tr>
<tr>
<td>数式</td>
<td>$(p + m)t$</td>
<td>$pt + mt$</td>
</tr>
<tr>
<td>EBNF</td>
<td><code>"+"|"-", term</code></td>
<td><code>("+", term) | ("-", term)</code></td>
</tr>
<tr>
<td>コード</td>
<td><code>(char '+' &lt;|&gt; char '-') *&gt; term</code></td>
<td><code>char '+' *&gt; term &lt;|&gt; char '-' *&gt; term</code></td>
</tr>
</table>

<p>※ <code>*&gt;</code>の実体は<code>&gt;&gt;</code>と同じで<code>&gt;&gt;=</code>に行きつくため（<code>a &gt;&gt; b = a &gt;&gt;= \_ -&gt; b</code>）、<code>&gt;&gt;=</code>も掛け算だと見立てられることになります。今回の範囲を超えるため詳細は省略します。</p>

<h3>
<span id="比較" class="fragment"></span><a href="#%E6%AF%94%E8%BC%83"><i class="fa fa-link"></i></a>比較</h3>

<p>コードにコメントとして追記するので比較してください。慣れて来れば、先にBNFで定義してからコードを書いた方が効率的だと感じるでしょう。</p>

<div class="code-frame" data-lang="hs">
<div class="code-lang"><span class="bold">比較</span></div>
<div class="highlight"><pre>
<span class="c1">-- expr = term, {("+", term) | ("-", term)}</span>
<span class="nf">expr</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">term</span> <span class="o">$</span> <span class="n">many</span> <span class="o">$</span>
        <span class="n">char</span> <span class="n">'</span><span class="o">+</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">term</span>
    <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="n">'</span><span class="o">-</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="n">term</span>

<span class="c1">-- term = number, {("*", number) | ("/", number)}</span>
<span class="nf">term</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">number</span> <span class="o">$</span> <span class="n">many</span> <span class="o">$</span>
        <span class="n">char</span> <span class="n">'</span><span class="o">*</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">number</span>
    <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="n">'</span><span class="o">/</span><span class="n">'</span> <span class="o">*&gt;</span> <span class="n">apply</span> <span class="n">div</span> <span class="n">number</span>
</pre></div>
</div>

<p>このコードはなるべくBNFに近付けるよう意識しています。このような使い方は<a href="https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%9B%BA%E6%9C%89%E8%A8%80%E8%AA%9E" rel="nofollow noopener" target="_blank">ドメイン固有言語</a>（DSL）に見立てられます。</p>

<blockquote class="twitter-tweet" lang="ja">
<p lang="ja">Haskellのモナドは、言語内DSLを定義するための型クラスです。モナドのインスタンスは、何か用のDSLなんだと思えばいいです。それ以上、難しく考える必要はありません。</p>— 山本和彦 (@kazu_yamamoto) <a href="https://twitter.com/kazu_yamamoto/status/555195571724492800" rel="nofollow noopener" target="_blank">2015, 1月 14</a>
</blockquote>

<blockquote class="twitter-tweet" lang="ja">
<p lang="ja">モナドって文字を見たら、言語内DSLに変換して下さい。たとえば、Parser モナドは、Parser 用の DSL です。</p>— 山本和彦 (@kazu_yamamoto) <a href="https://twitter.com/kazu_yamamoto/status/406047095708082176" rel="nofollow noopener" target="_blank">2013, 11月 28</a>
</blockquote>

<h2>
<span id="練習-5" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-5"><i class="fa fa-link"></i></a>練習</h2>

<p>【問6】項の下位に因子（factor）という層を追加して、括弧をサポートしてください。<code>&lt;*</code>を使ってください。</p>

<p>具体的には次のコードが動くようにしてください。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"(2+3)*4"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
20
</pre></div>
</div>

<p>ヒント: <code>factor = ("(", expr, ")") | number</code></p>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E6%8B%AC%E5%BC%A7" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<p>【問7】スペースを無視してください。</p>

<p>具体的には次のコードが動くようにしてください。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"1 + 2"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"123"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"1 + 2 + 3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"1 - 2 - 3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"1 - 2 + 3"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"2 * 3 + 4"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"2 + 3 * 4"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"100 / 10 / 2"</span>
    <span class="n">parseTest</span> <span class="n">expr</span> <span class="s">"( 2 + 3 ) * 4"</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
3
123
6
-4
2
10
14
5
20
</pre></div>
</div>

<p>ヒント: <a href="https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Char.html#v:spaces" rel="nofollow noopener" target="_blank">spaces</a></p>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E3%82%B9%E3%83%9A%E3%83%BC%E3%82%B9" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<p>【問8】問7の解答を、Parsecを使わずに問5の解答の自前実装に足りない関数を補って動かしてください。ただし次のように演算子の優先順位を指定する必要があります。</p>

<div class="code-frame" data-lang="hs">
<div class="code-lang"><span class="bold">演算子の優先順位</span></div>
<div class="highlight"><pre>
<span class="kr">infixr</span> <span class="mi">1</span> <span class="o">&lt;|&gt;</span>
</pre></div>
</div>

<p>ヒント: <code>spaces = skipMany space</code></p>

<p>⇒ <a href="http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E8%87%AA%E5%89%8D%E5%AE%9F%E8%A3%85" id="reference-cfd65e8476f0bb989b07">解答例</a></p>

<h1>
<span id="リファレンス" class="fragment"></span><a href="#%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9"><i class="fa fa-link"></i></a>リファレンス</h1>

<p>ここまで自前実装すればもう十分でしょう。この先はParsecを使いこなすことに集中する段階です。必要に応じてリファレンスを参照してください。</p>

<ul>
<li><a href="http://hackage.haskell.org/package/parsec-3.1.9" rel="nofollow noopener" target="_blank">parsec</a></li>
</ul>

<p>よく使うのは以下のモジュールです。</p>

<ul>
<li><a href="http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html" rel="nofollow noopener" target="_blank">Text.Parsec</a></li>
<li><a href="http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Char.html" rel="nofollow noopener" target="_blank">Text.Parsec.Char</a></li>
</ul>

<h1>
<span id="実装解説" class="fragment"></span><a href="#%E5%AE%9F%E8%A3%85%E8%A7%A3%E8%AA%AC"><i class="fa fa-link"></i></a>実装解説</h1>

<p>Parsecのソースは今回の自前実装よりもかなり複雑です。興味があれば<a href="/hiratara" class="user-mention js-hovercard" title="hiratara" data-hovercard-target-type="user" data-hovercard-target-name="hiratara">@hiratara</a>さんの記事を参照してください。</p>

<ul>
<li>2013.02.14 <a href="http://qiita.com/hiratara/items/b10ea9fa5d4e8e471a7c" id="reference-1ab4b2053913ca3b1df3">Parsecのソースちら見</a>
</li>
<li>2013.02.15 <a href="http://qiita.com/hiratara/items/755cd0e7f4b4cecf60da" id="reference-bf245626e37716f971a1">Parsecのソースちら見(2)</a>
</li>
<li>2013.02.15 <a href="http://qiita.com/hiratara/items/a451b04fb19bfcc7ff08" id="reference-cf9e737f7c5355a3e7a4">Parsecのソースちら見(3)</a>
</li>
</ul>

<h1>
<span id="謝辞" class="fragment"></span><a href="#%E8%AC%9D%E8%BE%9E"><i class="fa fa-link"></i></a>謝辞</h1>

<p>パーサについては<a href="https://twitter.com/kazu_yamamoto" rel="nofollow noopener" target="_blank">@kazu_yamamoto</a>先生よりご教示いただきました。</p>

<blockquote lang="ja">
<p lang="ja">&lt;|&gt; は Alternative 型クラスのメソッドです。import Control.Applicative すれば、Maybe でも &lt;|&gt; は使えます。</p>— 山本和彦 (@kazu_yamamoto) <a href="https://twitter.com/kazu_yamamoto/status/519030642428747776" rel="nofollow noopener" target="_blank">2014, 10月 6</a>
</blockquote>

<blockquote lang="ja">
<p lang="ja">Alternative は制限の緩い MonadPlus です。Monad が掛け算、MonadPlus が足し算の系を表します。MonadPlus はもう古いので、忘れて Alternative を使って下さい。</p>— 山本和彦 (@kazu_yamamoto) <a href="https://twitter.com/kazu_yamamoto/status/519031028040474624" rel="nofollow noopener" target="_blank">2014, 10月 6</a>
</blockquote>

<blockquote lang="ja">
<p lang="ja">ちなみに Parsec の &lt;|&gt; は、Alternative ではなく、独自実装だったと思います。</p>— 山本和彦 (@kazu_yamamoto) <a href="https://twitter.com/kazu_yamamoto/status/519031170822975488" rel="nofollow noopener" target="_blank">2014, 10月 6</a>
</blockquote>

<blockquote lang="ja">
<p lang="ja">Alternative に関しては、このスライドを見ると、頭なの中がすっきりするかもしれません。 <a href="http://t.co/v5MH4a6eP5" rel="nofollow noopener" target="_blank">http://t.co/v5MH4a6eP5</a></p>— 山本和彦 (@kazu_yamamoto) <a href="https://twitter.com/kazu_yamamoto/status/519035278321651712" rel="nofollow noopener" target="_blank">2014, 10月 6</a>
</blockquote>

<blockquote lang="ja">
<p lang="ja">パーサに関しては、Hutton さんのページに、ちゃんと動くコードがあるので、それを写経するといいかもしれません。僕がパーサの修行に実装したパーサは、これです。 <a href="http://t.co/1zxNHojuJ2" rel="nofollow noopener" target="_blank">http://t.co/1zxNHojuJ2</a></p>— 山本和彦 (@kazu_yamamoto) <a href="https://twitter.com/kazu_yamamoto/status/519035854237356032" rel="nofollow noopener" target="_blank">2014, 10月 6</a>
</blockquote>

<h1>
<span id="おわりに" class="fragment"></span><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB"><i class="fa fa-link"></i></a>おわりに</h1>

<p>個人的にはParsecの挙動を理解することがHaskellを勉強し始めた動機でした。当初はモナドの扱いに慣れていなかったことと相まって、Parsecが内部でどのような処理を行っているかがまったく想像できずに、ブラックボックスとして使うことすら困難を覚えました。</p>

<p>Haskellの勉強を進めるうちに、パーサがStateモナドとMaybeモナドの合成で表現できることに気付いたのが突破口となりました。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/201f379443079736e18e" id="reference-9af4f41a5f86088d5564">Parsecをモナド変換子で模倣</a> 2015.4.28</li>
</ul>

<p>今回は昔の自分のような困難を感じている人を想定して、Parsecを使う前に動作原理を説明しました。超入門シリーズは今回の構文解析が1つの山場となっているため、Maybeモナド以降は構文解析に関係するサンプルを入れて、今回の内容につながるよう構成しています。</p>

<p>自前実装により動作原理が把握できれば、Parsecを使うときにも何となく動きが推測できるようになるでしょう。そうすれば勘が働いて応用も思い付きやすくなります。</p>
<div class="hidden"><form class="js-task-list-update" action="/7shi/items/b8c741e78a96ea2c10fe" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="_method" value="patch" /><input type="hidden" name="authenticity_token" value="GE6EpwNKnOwOsPV5KBJDNSu00XRANP2Ve+aeINFaG7l2zB//mGSlp/FjQGVY5/1sS/P1x9fwp2JHOJfbMFQVfw==" /><input type="hidden" name="updated_at_confirmation_in_unixtime" id="updated_at_confirmation_in_unixtime" value="1482773781" class="js-task-list-updated-at" /><textarea name="raw_body" id="raw_body" class="js-task-list-field">
Haskellではモナドと呼ばれる部品を組み合わせて構文解析を行います。この方式をパーサコンビネータと呼びます。動作原理を簡単に説明しながら使い方の初歩を説明します。Parsecというライブラリで簡単な四則演算器を作成します。

シリーズの記事です。

1. [Haskell 超入門](http://qiita.com/7shi/items/145f1234f8ec2af923ef)
1. [Haskell 代数的データ型 超入門](http://qiita.com/7shi/items/1ce76bde464b4a55c143)
1. [Haskell アクション 超入門](http://qiita.com/7shi/items/85afd7bbd5d6c4115ad6)
1. [Haskell ラムダ 超入門](http://qiita.com/7shi/items/1345bf32003faff435cb)
1. [Haskell アクションとラムダ 超入門](http://qiita.com/7shi/items/4a8a2807bb5186576c61)
1. [Haskell IOモナド 超入門](http://qiita.com/7shi/items/d3d3492ddd90d47160f2)
1. [Haskell リストモナド 超入門](http://qiita.com/7shi/items/deb19c4cba933590ffbf)
1. [Haskell Maybeモナド 超入門](http://qiita.com/7shi/items/c7d7eec066af0fe0688d)
1. [Haskell 状態系モナド 超入門](http://qiita.com/7shi/items/2e9bff5d88302de1a9e9)
1. [Haskell モナド変換子 超入門](http://qiita.com/7shi/items/4408b76624067c17e933)
1. [Haskell 例外処理 超入門](http://qiita.com/7shi/items/73e534c47bbebc71b37e)
1. Haskell 構文解析 超入門 ← この記事
1. 【予定】Haskell 継続モナド 超入門
1. 【予定】Haskell 型クラス 超入門
1. 【予定】Haskell モナドとゆかいな仲間たち
1. 【予定】Haskell Freeモナド 超入門
1. 【予定】Haskell Operationalモナド 超入門
1. 【予定】Haskell Effモナド 超入門
1. 【予定】Haskell アロー 超入門

練習の解答例は別記事に掲載します。

* [【解答例】Haskell 構文解析 超入門](http://qiita.com/7shi/items/f65814b1e91d48ec8d12)

この記事には関連記事があります。

* [Stateモナドによる中置記法の処理](http://qiita.com/7shi/items/ee5afe4f088f0a1fc8c2)

この記事には他言語版があります。

* [C++11 パーサコンビネータ 超入門](http://qiita.com/7shi/items/6a12160276a8db358e34) 2015.11.27
* [C++11 パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/f86f2f7ad68cfff1b399) 2015.11.30
* [Java パーサコンビネータ 超入門](http://qiita.com/7shi/items/68228e19552c271bea81) 2016.05.12
* [Java パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142) 2016.05.14

この記事には関連記事があります。

* [JSONパーサーを作る](http://qiita.com/7shi/items/04c2991239894687ef2f) 2016.12.26

# 動作原理

パーサコンビネータとは単純なパーサ（構文解析器）を組み合わせることで複雑な構文解析にも対応できる仕組みです。その動作原理をなるべく平易な実装で説明します。

## モナドなし

まずモナドなしでパーサを作ります。

### 1文字取得

指定した文字列から先頭の1文字を取得します。

```hs
anyChar (x:_) = x

main = do
    print $ anyChar &quot;abc&quot;
```
```text:実行結果
&#39;a&#39;
```

`anyChar`が最初のパーサです。

### 連続呼び出し

`anyChar`を連続呼び出しすることで複数文字を取得できるように拡張します。

まだ読み取っていない残りの文字列をタプルで返せば、次の呼び出しで次の文字が取得できます。

```hs
anyChar (x:xs) = (x, xs)

main = do
    let r1 = anyChar &quot;abc&quot;
        r2 = anyChar $ snd r1
    print r1
    print r2
```
```text:実行結果
(&#39;a&#39;,&quot;bc&quot;)
(&#39;b&#39;,&quot;c&quot;)
```

### 結果の分離

結果として返されるタプルの中身を分離して受け取ります。

```hs
anyChar (x:xs) = (x, xs)

main = do
    let (x1, xs1) = anyChar &quot;abc&quot;
        (x2, xs2) = anyChar xs1
    print [x1, x2]
```
```text:実行結果
&quot;ab&quot;
```

`anyChar`を2回繰り返すことで、先頭から2文字取得しています。

### 関数化

2文字取得する部分を関数化します。

```hs
anyChar (x:xs) = (x, xs)

test1 xs0 =                      -- 関数化
    let (x1, xs1) = anyChar xs0
        (x2, xs2) = anyChar xs1
    in [x1, x2]

main = do
    print $ anyChar &quot;abc&quot;
    print $ test1   &quot;abc&quot;
```
```text:実行結果
(&#39;a&#39;,&quot;bc&quot;)
&quot;ab&quot;
```

### 組み合わせ

`test1`も残りの文字列を返すようにすれば、別の箇所で`anyChar`と組み合わせて利用できるようになります。

```hs
anyChar (x:xs) = (x, xs)

test1 xs0 =
    let (x1, xs1) = anyChar xs0
        (x2, xs2) = anyChar xs1
    in ([x1, x2], xs2)           -- 残りの文字列を返す

test2 xs0 =
    let (x1, xs1) = test1   xs0  -- test1で処理した残りを
        (x2, xs2) = anyChar xs1  -- anyCharで処理する
    in (x1 ++ [x2], xs2)

main = do
    print $ anyChar &quot;abc&quot;
    print $ test1   &quot;abc&quot;
    print $ test2   &quot;abc&quot;        -- 追加
```
```text:実行結果
(&#39;a&#39;,&quot;bc&quot;)
(&quot;ab&quot;,&quot;c&quot;)
(&quot;abc&quot;,&quot;&quot;)
```

`test1`は`anyChar`を2つ組み合わせて作ったパーサです。`test2`は`test1`と`anyChar`を組み合わせて作ったパーサです。このように簡単なパーサを組み合わせて複雑なパーサを作っていくのが、パーサコンビネータの基本的な考え方です。

`main`の中で`anyChar`と`test1`と`test2`が同列に並んでいますが、どれもパーサとして同じような位置付けだと見立ててください。

### エラー

文字数が足りなければエラーで止まります。

```hs
anyChar (x:xs) = (x, xs)

test1 xs0 =
    let (x1, xs1) = anyChar xs0
        (x2, xs2) = anyChar xs1
    in ([x1, x2], xs2)

test2 xs0 =
    let (x1, xs1) = test1   xs0
        (x2, xs2) = anyChar xs1
    in (x1 ++ [x2], xs2)

main = do
    print $ anyChar &quot;abc&quot;
    print $ test1   &quot;abc&quot;
    print $ test2   &quot;abc&quot;
    print $ test2   &quot;12&quot;   -- エラー
    print $ test2   &quot;123&quot;  -- ここに来ない
```
```text:実行結果
(&#39;a&#39;,&quot;bc&quot;)
(&quot;ab&quot;,&quot;c&quot;)
(&quot;abc&quot;,&quot;&quot;)
xxx: Main.hs:1:1-24: Non-exhaustive patterns in function anyChar

```

### テスト関数

エラーが出ても続行できるように、テスト用の関数`parseTest`を作成して例外を処理します。

```hs
import Control.Exception           -- 追加

parseTest p s = do                 -- 追加
    print $ fst $ p s              -- タプルの第1要素を表示
    `catch` \(SomeException e) -&gt;
        putStr $ show e

anyChar (x:xs) = (x, xs)

test1 xs0 =
    let (x1, xs1) = anyChar xs0
        (x2, xs2) = anyChar xs1
    in ([x1, x2], xs2)

test2 xs0 =
    let (x1, xs1) = test1   xs0
        (x2, xs2) = anyChar xs1
    in (x1 ++ [x2], xs2)

main = do
    parseTest anyChar &quot;abc&quot;
    parseTest test1   &quot;abc&quot;
    parseTest test2   &quot;abc&quot;
    parseTest test2   &quot;12&quot;         -- エラー
    parseTest test2   &quot;123&quot;        -- 続行
```
```text:実行結果
&#39;a&#39;
&quot;ab&quot;
&quot;abc&quot;
Main.hs:8:1-24: Non-exhaustive patterns in function anyChar
&quot;123&quot;
```

### 条件取得

`anyChar`は無条件で文字を取得していましたが、条件が指定できる`satisfy`を追加します。

```hs
import Control.Exception
import Data.Char                        -- 追加

parseTest p s = do
    print $ fst $ p s
    `catch` \(SomeException e) -&gt;
        putStr $ show e

anyChar   (x:xs)       = (x, xs)
satisfy f (x:xs) | f x = (x, xs)        -- 追加

main = do
    parseTest (satisfy (== &#39;a&#39;)) &quot;abc&quot;  -- OK
    parseTest (satisfy (== &#39;a&#39;)) &quot;123&quot;  -- NG
    parseTest (satisfy isDigit ) &quot;abc&quot;  -- NG
    parseTest (satisfy isDigit ) &quot;123&quot;  -- OK
```
```text:実行結果
&#39;a&#39;
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
&#39;1&#39;
```

今回の機能追加に直接関係ない`test1`と`test2`は削除しました。

### 事前定義

`satisfy`で条件を指定するのは冗長なので、よく使うパターンを事前定義します。

```hs
import Control.Exception
import Data.Char

parseTest p s = do
    print $ fst $ p s
    `catch` \(SomeException e) -&gt;
        putStr $ show e

anyChar   (x:xs)       = (x, xs)
satisfy f (x:xs) | f x = (x, xs)

char c = satisfy (== c)         -- 追加
digit  = satisfy isDigit        -- 追加
letter = satisfy isLetter       -- 追加

main = do
    parseTest (char &#39;a&#39;) &quot;abc&quot;  -- OK
    parseTest (char &#39;a&#39;) &quot;123&quot;  -- NG
    parseTest digit  &quot;abc&quot;      -- NG
    parseTest digit  &quot;123&quot;      -- OK
    parseTest letter &quot;abc&quot;      -- OK
    parseTest letter &quot;123&quot;      -- NG
```
```text:実行結果
&#39;a&#39;
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
&#39;1&#39;
&#39;a&#39;
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
```

### 組み合わせ判定

先ほど追加したパーサを組み合わせて、先頭から「アルファベット」「数字」「数字」という組み合わせを判定するパーサを示します。

```hs
import Control.Exception
import Data.Char

parseTest p s = do
    print $ fst $ p s
    `catch` \(SomeException e) -&gt;
        putStr $ show e

anyChar   (x:xs)       = (x, xs)
satisfy f (x:xs) | f x = (x, xs)

char c = satisfy (== c)
digit  = satisfy isDigit
letter = satisfy isLetter

test3 xs0 =                     -- 追加
    let (x1, xs1) = letter xs0
        (x2, xs2) = digit  xs1
        (x3, xs3) = digit  xs2
    in ([x1, x2, x3], xs3)

main = do
    parseTest test3 &quot;abc&quot;       -- NG
    parseTest test3 &quot;123&quot;       -- NG
    parseTest test3 &quot;a23&quot;       -- OK
    parseTest test3 &quot;a234&quot;      -- OK
```
```text:実行結果
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
&quot;a23&quot;
&quot;a23&quot;
```

### まとめ

ここまでがパーサコンビネータの動作原理を理解するために最低限必要な実装です。登場したテストを1つにまとめます。

```hs
import Control.Exception
import Data.Char

parseTest p s = do
    print $ fst $ p s
    `catch` \(SomeException e) -&gt;
        putStr $ show e

anyChar   (x:xs)       = (x, xs)
satisfy f (x:xs) | f x = (x, xs)

char c = satisfy (== c)
digit  = satisfy isDigit
letter = satisfy isLetter

test1 xs0 =
    let (x1, xs1) = anyChar xs0
        (x2, xs2) = anyChar xs1
    in ([x1, x2], xs2)

test2 xs0 =
    let (x1, xs1) = test1   xs0
        (x2, xs2) = anyChar xs1
    in (x1 ++ [x2], xs2)

test3 xs0 =
    let (x1, xs1) = letter xs0
        (x2, xs2) = digit  xs1
        (x3, xs3) = digit  xs2
    in ([x1, x2, x3], xs3)

main = do
    parseTest anyChar &quot;abc&quot;
    parseTest test1   &quot;abc&quot;
    parseTest test2   &quot;abc&quot;
    parseTest test2   &quot;12&quot;      -- NG
    parseTest test2   &quot;123&quot;
    parseTest (char &#39;a&#39;) &quot;abc&quot;
    parseTest (char &#39;a&#39;) &quot;123&quot;  -- NG
    parseTest digit  &quot;abc&quot;      -- NG
    parseTest digit  &quot;123&quot;
    parseTest letter &quot;abc&quot;
    parseTest letter &quot;123&quot;      -- NG
    parseTest test3  &quot;abc&quot;      -- NG
    parseTest test3  &quot;123&quot;      -- NG
    parseTest test3  &quot;a23&quot;
    parseTest test3  &quot;a234&quot;
```
```text:実行結果
&#39;a&#39;
&quot;ab&quot;
&quot;abc&quot;
Main.hs:9:1-32: Non-exhaustive patterns in function anyChar
&quot;123&quot;
&#39;a&#39;
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
&#39;1&#39;
&#39;a&#39;
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
Main.hs:10:1-32: Non-exhaustive patterns in function satisfy
&quot;a23&quot;
&quot;a23&quot;
```

このコードをモナドで書き換えて、足りない機能を追加します。

## Stateモナド

解析対象の文字列を状態と見なせばStateモナドが使えます。

### 練習

【問1】モナドなしのまとめのコードをStateモナドを使って書き換えてください。

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#state%E3%83%A2%E3%83%8A%E3%83%89)

引数が減ってコードが短くなります。元の`test1`などにあった `xs0` → `xs1` → `xs2` という状態の受け渡しが省略されたことで、変数名の管理も簡単になります。

### sequence

モナド化したことで連続した文字取得は`sequence`を使って簡単に書けます。

競合を避けるためControl.Applicativeは選択的に`import`します。選択する対象全体を括弧で囲みますが、演算子は個別に括弧で囲むため、結果として二重に括弧で囲むことになります。

```hs
import Control.Exception
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))      -- 選択的import
import Control.Monad
import Control.Monad.State
import Data.Char

parseTest p s = do
    print $ evalState p s
    `catch` \(SomeException e) -&gt;
        putStr $ show e

anyChar = state $ anyChar where
    anyChar (x:xs) = (x, xs)

satisfy :: (Char -&gt; Bool) -&gt; State String Char
satisfy f = state $ satisfy where
    satisfy (x:xs) | f x = (x, xs)

char c = satisfy (== c)
digit  = satisfy isDigit
letter = satisfy isLetter

test1 = sequence [anyChar, anyChar]            -- 単純化
test2 = (++) &lt;$&gt; test1 &lt;*&gt; sequence [anyChar]  -- 少しややこしい
test3 = sequence [letter, digit, digit]        -- 単純化

main = do
    parseTest test1 &quot;abc&quot;
    parseTest test2 &quot;abc&quot;
    parseTest test2 &quot;12&quot;                       -- NG
    parseTest test2 &quot;123&quot;
    parseTest test3 &quot;abc&quot;                      -- NG
    parseTest test3 &quot;123&quot;                      -- NG
    parseTest test3 &quot;a23&quot;
    parseTest test3 &quot;a234&quot;
```
```text:実行結果
&quot;ab&quot;
&quot;abc&quot;
Main.hs:13:5-28: Non-exhaustive patterns in function anyChar
&quot;123&quot;
Main.hs:17:5-34: Non-exhaustive patterns in function satisfy
Main.hs:17:5-34: Non-exhaustive patterns in function satisfy
&quot;a23&quot;
&quot;a23&quot;
```

## Maybeモナド

Maybeモナドを使えば例外を使わずに失敗が扱えます。

### 練習

【問2】モナドなしのまとめのコードをMaybeモナドを使って書き換えてください。

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#maybe%E3%83%A2%E3%83%8A%E3%83%89)

## Eitherモナド

Maybeモナドにより例外処理をなくしても、失敗はすべて`Nothing`のため理由がよく分かりません。

Eitherモナドを使って、失敗した理由を`Left`で返します。Either用の`&lt;|&gt;`を独自に定義します。

```hs
import Data.Char

parseTest p s = case p s of
    Right (r, _) -&gt; print r
    Left  e      -&gt; putStrLn $ &quot;[&quot; ++ show s ++ &quot;] &quot; ++ e

anyChar (x:xs) = Right (x, xs)
anyChar _      = Left &quot;too short&quot;

satisfy f (x:xs) | not $ f x = Left $ &quot;: &quot; ++ show x
satisfy f    xs              = anyChar xs

Left a &lt;|&gt; Left b = Left $ b ++ a
Left _ &lt;|&gt; b      = b
a      &lt;|&gt; _      = a

char c xs = satisfy (== c)   xs &lt;|&gt; Left (&quot;not char &quot; ++ show c)
digit  xs = satisfy isDigit  xs &lt;|&gt; Left &quot;not digit&quot;
letter xs = satisfy isLetter xs &lt;|&gt; Left &quot;not letter&quot;

test1 xs0 = do
    (x1, xs1) &lt;- anyChar xs0
    (x2, xs2) &lt;- anyChar xs1
    return ([x1, x2], xs2)

test2 xs0 = do
    (x1, xs1) &lt;- test1   xs0
    (x2, xs2) &lt;- anyChar xs1
    return (x1 ++ [x2], xs2)

test3 xs0 = do
    (x1, xs1) &lt;- letter xs0
    (x2, xs2) &lt;- digit  xs1
    (x3, xs3) &lt;- digit  xs2
    return ([x1, x2, x3], xs3)

main = do
    parseTest anyChar &quot;abc&quot;
    parseTest test1   &quot;abc&quot;
    parseTest test2   &quot;abc&quot;
    parseTest test2   &quot;12&quot;      -- NG
    parseTest test2   &quot;123&quot;
    parseTest (char &#39;a&#39;) &quot;abc&quot;
    parseTest (char &#39;a&#39;) &quot;123&quot;  -- NG
    parseTest digit  &quot;abc&quot;      -- NG
    parseTest digit  &quot;123&quot;
    parseTest letter &quot;abc&quot;
    parseTest letter &quot;123&quot;      -- NG
    parseTest test3  &quot;abc&quot;      -- NG
    parseTest test3  &quot;123&quot;      -- NG
    parseTest test3  &quot;a23&quot;
    parseTest test3  &quot;a234&quot;
```
```text:実行結果
&#39;a&#39;
&quot;ab&quot;
&quot;abc&quot;
[&quot;12&quot;] too short
&quot;123&quot;
&#39;a&#39;
[&quot;123&quot;] not char &#39;a&#39;: &#39;1&#39;
[&quot;abc&quot;] not digit: &#39;a&#39;
&#39;1&#39;
&#39;a&#39;
[&quot;123&quot;] not letter: &#39;1&#39;
[&quot;abc&quot;] not digit: &#39;b&#39;
[&quot;123&quot;] not letter: &#39;1&#39;
&quot;a23&quot;
&quot;a23&quot;
```

エラーメッセージをカスタマイズして分かりやすくなりました。

## モナド変換子で合成

StateTモナド変換子でEitherモナドと合成すれば、StateモナドとEitherモナドの両方の特徴が使えます。

```hs
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Control.Monad
import Control.Monad.State
import Data.Char

parseTest p s = case evalStateT p s of
    Right r -&gt; print r
    Left  e -&gt; putStrLn $ &quot;[&quot; ++ show s ++ &quot;] &quot; ++ e

anyChar = StateT $ anyChar where
    anyChar (x:xs) = Right (x, xs)
    anyChar _      = Left &quot;too short&quot;

satisfy f = StateT $ satisfy where
    satisfy (x:xs) | not $ f x = Left $ &quot;: &quot; ++ show x
    satisfy    xs              = runStateT anyChar xs

(StateT a) &lt;|&gt; (StateT b) = StateT $ \s -&gt;
    (a s)  &lt;|&gt; (b s) where
    Left a &lt;|&gt; Left b = Left $ b ++ a
    Left _ &lt;|&gt; b      = b
    a      &lt;|&gt; _      = a

left = lift . Left

char c = satisfy (== c)   &lt;|&gt; left (&quot;not char &quot; ++ show c)
digit  = satisfy isDigit  &lt;|&gt; left &quot;not digit&quot;
letter = satisfy isLetter &lt;|&gt; left &quot;not letter&quot;

test1 = sequence [anyChar, anyChar]
test2 = (++) &lt;$&gt; test1 &lt;*&gt; sequence [anyChar]
test3 = sequence [letter, digit, digit]

main = do
    parseTest anyChar &quot;abc&quot;
    parseTest test1   &quot;abc&quot;
    parseTest test2   &quot;abc&quot;
    parseTest test2   &quot;12&quot;      -- NG
    parseTest test2   &quot;123&quot;
    parseTest (char &#39;a&#39;) &quot;abc&quot;
    parseTest (char &#39;a&#39;) &quot;123&quot;  -- NG
    parseTest digit  &quot;abc&quot;      -- NG
    parseTest digit  &quot;123&quot;
    parseTest letter &quot;abc&quot;
    parseTest letter &quot;123&quot;      -- NG
    parseTest test3  &quot;abc&quot;      -- NG
    parseTest test3  &quot;123&quot;      -- NG
    parseTest test3  &quot;a23&quot;
    parseTest test3  &quot;a234&quot;
```
```text:実行結果
&#39;a&#39;
&quot;ab&quot;
&quot;abc&quot;
[&quot;12&quot;] too short
&quot;123&quot;
&#39;a&#39;
[&quot;123&quot;] not char &#39;a&#39;: &#39;1&#39;
[&quot;abc&quot;] not digit: &#39;a&#39;
&#39;1&#39;
&#39;a&#39;
[&quot;123&quot;] not letter: &#39;1&#39;
[&quot;abc&quot;] not digit: &#39;b&#39;
[&quot;123&quot;] not letter: &#39;1&#39;
&quot;a23&quot;
&quot;a23&quot;
```

合成による複雑さが`&lt;|&gt;`に集約されています。こういったものは通常はライブラリが用意するので、あまり意識する必要はない部分ではあります。

### 選択

`&lt;|&gt;`を使えば「アルファベットまたは数字」のような選択的なパーサを構築できます。

```hs
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Control.Monad
import Control.Monad.State
import Data.Char

parseTest p s = case evalStateT p s of
    Right r -&gt; print r
    Left  e -&gt; putStrLn $ &quot;[&quot; ++ show s ++ &quot;] &quot; ++ e

anyChar = StateT $ anyChar where
    anyChar (x:xs) = Right (x, xs)
    anyChar _      = Left &quot;too short&quot;

satisfy f = StateT $ satisfy where
    satisfy (x:xs) | not $ f x = Left $ &quot;: &quot; ++ show x
    satisfy    xs              = runStateT anyChar xs

(StateT a) &lt;|&gt; (StateT b) = StateT $ \s -&gt;
    (a s)  &lt;|&gt; (b s) where
    Left a &lt;|&gt; Left b = Left $ b ++ a
    Left _ &lt;|&gt; b      = b
    a      &lt;|&gt; _      = a

left = lift . Left

char c = satisfy (== c)   &lt;|&gt; left (&quot;not char &quot; ++ show c)
digit  = satisfy isDigit  &lt;|&gt; left &quot;not digit&quot;
letter = satisfy isLetter &lt;|&gt; left &quot;not letter&quot;

test4 = letter &lt;|&gt; digit  -- 選択

main = do
    parseTest test4 &quot;a&quot;   -- OK
    parseTest test4 &quot;1&quot;   -- OK
    parseTest test4 &quot;!&quot;   -- NG
```
```text:実行結果
&#39;a&#39;
&#39;1&#39;
[&quot;!&quot;] not digit: &#39;!&#39;not letter: &#39;!&#39;
```

エラーがごちゃごちゃしていますが、動作原理の説明が目的のため気にしないことにします。

### 関数で繰り返し

モナドは関数で繰り返しを表現できます。「先頭がアルファベットで、その後に3桁の数字が続く」というパーサを見てみます。

```hs
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Control.Monad
import Control.Monad.State
import Data.Char

parseTest p s = case evalStateT p s of
    Right r -&gt; print r
    Left  e -&gt; putStrLn $ &quot;[&quot; ++ show s ++ &quot;] &quot; ++ e

anyChar = StateT $ anyChar where
    anyChar (x:xs) = Right (x, xs)
    anyChar _      = Left &quot;too short&quot;

satisfy f = StateT $ satisfy where
    satisfy (x:xs) | not $ f x = Left $ &quot;: &quot; ++ show x
    satisfy    xs              = runStateT anyChar xs

(StateT a) &lt;|&gt; (StateT b) = StateT $ \s -&gt;
    (a s)  &lt;|&gt; (b s) where
    Left a &lt;|&gt; Left b = Left $ b ++ a
    Left _ &lt;|&gt; b      = b
    a      &lt;|&gt; _      = a

left = lift . Left

char c = satisfy (== c)   &lt;|&gt; left (&quot;not char &quot; ++ show c)
digit  = satisfy isDigit  &lt;|&gt; left &quot;not digit&quot;
letter = satisfy isLetter &lt;|&gt; left &quot;not letter&quot;

test5 = sequence [letter, digit, digit, digit]  -- ベタ書き
test6 = sequence $ letter : replicate 3 digit   -- 関数使用

main = do
    parseTest test5 &quot;a123&quot;                      -- OK
    parseTest test5 &quot;ab123&quot;                     -- NG
    parseTest test6 &quot;a123&quot;                      -- OK
    parseTest test6 &quot;ab123&quot;                     -- NG
```
```text:実行結果
&quot;a123&quot;
[&quot;ab123&quot;] not digit: &#39;b&#39;
&quot;a123&quot;
[&quot;ab123&quot;] not digit: &#39;b&#39;
```

文字通り「モナドを部品として組み合わせてパーサを構築」というコードです。工夫すれば色々できそうだと気付けばしめたものです。

## 練習

【問3】指定したパーサを0回以上適用して返すコンビネータ`many`を実装してください。

具体的には次のコードが動くようにしてください。

```hs
test7 = many letter
test8 = many (letter &lt;|&gt; digit)

main = do
    parseTest test7 &quot;abc123&quot;
    parseTest test7 &quot;123abc&quot;
    parseTest test8 &quot;abc123&quot;
    parseTest test8 &quot;123abc&quot;
```
```text:実行結果
&quot;abc&quot;
&quot;&quot;
&quot;abc123&quot;
&quot;123abc&quot;
```

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#many)

# Parsec

ここまで実装して来たパーサはすべてParsecというライブラリで提供されています。Parsecと関数名を合わせたため、今までのテストがそのまま実行できます。

依存パッケージ: [parsec](https://hackage.haskell.org/package/parsec)

```hs
import Text.Parsec
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

test1 = sequence [anyChar, anyChar]
test2 = (++) &lt;$&gt; test1 &lt;*&gt; sequence [anyChar]
test3 = sequence [letter, digit, digit]
test4 = letter &lt;|&gt; digit
test5 = sequence [letter, digit, digit, digit]
test6 = sequence $ letter : replicate 3 digit
test7 = many letter
test8 = many (letter &lt;|&gt; digit)

main = do
    parseTest anyChar &quot;abc&quot;
    parseTest test1   &quot;abc&quot;
    parseTest test2   &quot;abc&quot;
    parseTest test2   &quot;12&quot;      -- NG
    parseTest test2   &quot;123&quot;
    parseTest (char &#39;a&#39;) &quot;abc&quot;
    parseTest (char &#39;a&#39;) &quot;123&quot;  -- NG
    parseTest digit  &quot;abc&quot;      -- NG
    parseTest digit  &quot;123&quot;
    parseTest letter &quot;abc&quot;
    parseTest letter &quot;123&quot;      -- NG
    parseTest test3  &quot;abc&quot;      -- NG
    parseTest test3  &quot;123&quot;      -- NG
    parseTest test3  &quot;a23&quot;
    parseTest test3  &quot;a234&quot;
    parseTest test4  &quot;a&quot;
    parseTest test4  &quot;1&quot;
    parseTest test4  &quot;!&quot;        -- NG
    parseTest test5  &quot;a123&quot;
    parseTest test5  &quot;ab123&quot;    -- NG
    parseTest test6  &quot;a123&quot;
    parseTest test6  &quot;ab123&quot;    -- NG
    parseTest test7  &quot;abc123&quot;
    parseTest test7  &quot;123abc&quot;
    parseTest test8  &quot;abc123&quot;
    parseTest test8  &quot;123abc&quot;
```
```text:実行結果
&#39;a&#39;
&quot;ab&quot;
&quot;abc&quot;
parse error at (line 1, column 3):
unexpected end of input
&quot;123&quot;
&#39;a&#39;
parse error at (line 1, column 1):
unexpected &quot;1&quot;
expecting &quot;a&quot;
parse error at (line 1, column 1):
unexpected &quot;a&quot;
expecting digit
&#39;1&#39;
&#39;a&#39;
parse error at (line 1, column 1):
unexpected &quot;1&quot;
expecting letter
parse error at (line 1, column 2):
unexpected &quot;b&quot;
expecting digit
parse error at (line 1, column 1):
unexpected &quot;1&quot;
expecting letter
&quot;a23&quot;
&quot;a23&quot;
&#39;a&#39;
&#39;1&#39;
parse error at (line 1, column 1):
unexpected &quot;!&quot;
expecting letter or digit
&quot;a123&quot;
parse error at (line 1, column 2):
unexpected &quot;b&quot;
expecting digit
&quot;a123&quot;
parse error at (line 1, column 2):
unexpected &quot;b&quot;
expecting digit
&quot;abc&quot;
&quot;&quot;
&quot;abc123&quot;
&quot;123abc&quot;
```

エラーメッセージが詳細です。

## エラーチェック

Parsecでは`&lt;|&gt;`でエラーが細かくチェックされます。

`左 &lt;|&gt; 右`として、左のパーサが内部で複数のパーサから構成されるとき、そのうち1つでも成功してその後で失敗したなら、右のパーサは処理されずにエラーとなります。

```hs
import Text.Parsec

test9 = sequence [char &#39;a&#39;, char &#39;b&#39;]  -- &#39;a&#39;が成功して&#39;b&#39;で失敗したらエラー
    &lt;|&gt; sequence [char &#39;a&#39;, char &#39;c&#39;]

main = do
    parseTest test9 &quot;ab&quot;
    parseTest test9 &quot;ac&quot;
```
```text:実行結果
&quot;ab&quot;
parse error at (line 1, column 2):
unexpected &quot;c&quot;
expecting &quot;b&quot;
```

この挙動を把握しておかないとハマります。

### 練習

【問4】問3の解答の自前実装では失敗時に返される`Left`に状態が含まれず、1つでも成功していたかが判断できません。`left`を次のように修正することで状態を返して、Parsecと同じようにエラーをチェックしてください。

```hs
left e = StateT $ \s -&gt; Left (e, s)
```

具体的には次のコードで2番目のテストが失敗するようにしてください。

```hs
test9 = sequence [char &#39;a&#39;, char &#39;b&#39;]
    &lt;|&gt; sequence [char &#39;a&#39;, char &#39;c&#39;]

main = do
    parseTest test9 &quot;ab&quot;
    parseTest test9 &quot;ac&quot;
```
```text:実行結果
&quot;ab&quot;
[&quot;ac&quot;] not char &#39;b&#39;: &#39;c&#39;
```

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF)

## バックトラック

パースに失敗したとき、状態を巻き戻して別の方法でパースをやり直すことを**バックトラック**と呼びます。

### try

バックトラックするには対象となるパーサを`try`で囲みます。失敗すると元の状態に戻って`&lt;|&gt;`の右のパーサが処理されます。

※ 例外処理の`try`と同名ですが、別の関数です。

エラーチェックで登場した`test9`と挙動を比較します。

```hs
import Text.Parsec

test9 = sequence [char &#39;a&#39;, char &#39;b&#39;]
    &lt;|&gt; sequence [char &#39;a&#39;, char &#39;c&#39;]
test10 = try (sequence [char &#39;a&#39;, char &#39;b&#39;])
         &lt;|&gt;  sequence [char &#39;a&#39;, char &#39;c&#39;]

main = do
    parseTest test9  &quot;ab&quot;
    parseTest test9  &quot;ac&quot;
    parseTest test10 &quot;ab&quot;
    parseTest test10 &quot;ac&quot;
```
```text:実行結果
&quot;ab&quot;
parse error at (line 1, column 2):
unexpected &quot;c&quot;
expecting &quot;b&quot;
&quot;ab&quot;
&quot;ac&quot;
```

### string

1文字ずつ`char`でパースしなくても、文字列で指定できる`string`があります。ただし内部では1文字ずつ処理されているため、途中の失敗をバックトラックするには`try`が必要です。

挙動の違いを比較します。

```hs
import Text.Parsec

test11 =      string &quot;ab&quot;  &lt;|&gt; string &quot;ac&quot;
test12 = try (string &quot;ab&quot;) &lt;|&gt; string &quot;ac&quot;

main = do
    parseTest test11 &quot;ab&quot;
    parseTest test11 &quot;ac&quot;
    parseTest test12 &quot;ab&quot;
    parseTest test12 &quot;ac&quot;
```
```text:実行結果
&quot;ab&quot;
parse error at (line 1, column 1):
unexpected &quot;c&quot;
expecting &quot;ab&quot;
&quot;ab&quot;
&quot;ac&quot;
```

デフォルトのトランザクションの範囲は`char`で、`string`**ではない**と解釈できます。`try`によってトランザクションの範囲を広げることになります。

### LL(1)

バックトラックなしで処理できる文法をLL(1)文法と呼びます。

* [LL法 - Wikipedia](https://ja.wikipedia.org/wiki/LL%E6%B3%95)

以下の記事にParsecはLL(1)で最高の性能を発揮するとあります。

* [@kazu_yamamoto](https://twitter.com/kazu_yamamoto): [とりとめのないパーサー談義 - あどけない話](http://d.hatena.ne.jp/kazu-yamamoto/20081201/1228115457) 2008.12.1

先ほどの`test10`は、重複する`char &#39;a&#39;`をまとめることでバックトラックのないLL(1)となります。両者を比較します。

```hs
import Text.Parsec

test10 = try (sequence [char &#39;a&#39;, char &#39;b&#39;])
         &lt;|&gt;  sequence [char &#39;a&#39;, char &#39;c&#39;]
test13 = sequence [char &#39;a&#39;, char &#39;b&#39; &lt;|&gt; char &#39;c&#39;]

main = do
    parseTest test10 &quot;ab&quot;
    parseTest test10 &quot;ac&quot;
    parseTest test13 &quot;ab&quot;
    parseTest test13 &quot;ac&quot;
```
```text:実行結果
&quot;ab&quot;
&quot;ac&quot;
&quot;ab&quot;
&quot;ac&quot;
```

この例によりLL(1)が高速な理由が直感的に伝わるでしょうか？

`test10`から`test13`への変形は数式の因数分解に似ています。コードでの`&lt;|&gt;`を足し算、`,`を掛け算に見立てます。簡単のため`sequence`を省略して比較します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;コード&lt;/th&gt;&lt;th&gt;数式&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;[char &#39;a&#39;, char &#39;b&#39;] &amp;lt;|&gt; [char &#39;a&#39;, char &#39;c&#39;]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;$ab + ac$&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;[char &#39;a&#39;, char &#39;b&#39; &amp;lt;|&gt; char &#39;c&#39;]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;$a(b + c)$&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

### 練習

【問5】問4の解答の自前実装に`try`と`string`を実装してください。

具体的には次のコードが動くようにしてください。

```hs
test10 = try (sequence [char &#39;a&#39;, char &#39;b&#39;])
         &lt;|&gt;  sequence [char &#39;a&#39;, char &#39;c&#39;]
test11 =      string &quot;ab&quot;  &lt;|&gt; string &quot;ac&quot;
test12 = try (string &quot;ab&quot;) &lt;|&gt; string &quot;ac&quot;

main = do
    parseTest test10 &quot;ab&quot;
    parseTest test10 &quot;ac&quot;
    parseTest test11 &quot;ab&quot;
    parseTest test11 &quot;ac&quot;
    parseTest test12 &quot;ab&quot;
    parseTest test12 &quot;ac&quot;
```
```text:実行結果
&quot;ab&quot;
&quot;ac&quot;
&quot;ab&quot;
[&quot;ac&quot;] not char &#39;b&#39;: &#39;c&#39;
&quot;ab&quot;
&quot;ac&quot;
```

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF)

# 四則演算器

Parsecの練習として、簡単な四則演算器を作ります。文字列で式を与えると計算して答えを返します。

例: `&quot;1+2*3&quot;` → `7`

ここから先の内容から構文解析に関係する部分を省いて計算だけに特化した記事があります。`many`がないため作り方が少し違います。

* [Stateモナドによる中置記法の処理](http://qiita.com/7shi/items/ee5afe4f088f0a1fc8c2)

## 数字

数字を読み込むパーサを実装します。最低でも1文字は必要なため`many`（0回以上の繰り返し）ではなく`many1`（1回以上の繰り返し）を使います。

```hs
import Text.Parsec

number = many1 digit

main = do
    parseTest number &quot;123&quot;
```
```text:実行結果
&quot;123&quot;
```

### 数値

結果を数値で返すように修正します。

```hs
import Text.Parsec

number = do
    x &lt;- many1 digit
    return (read x :: Int)  -- 変換

main = do
    parseTest number &quot;123&quot;
```
```text:実行結果
123
```

## 足し算

足し算を計算するパーサを実装します。

`&#39;+&#39;`で区切って項を個別に取り出します。

```hs
import Text.Parsec

expr = do                   -- 追加
    x &lt;- number
    char &#39;+&#39;
    y &lt;- number
    return [x, y]

number = do
    x &lt;- many1 digit
    return (read x :: Int)

main = do
    parseTest number &quot;123&quot;
    parseTest expr   &quot;1+2&quot;  -- 追加
```
```text:実行結果
123
[1,2]
```

### many

`+数値`を`many`により0回以上の繰り返しとして扱います。

```hs
import Text.Parsec

expr = do
    x  &lt;- number
    xs &lt;- many $ do           -- 繰り返し
        char &#39;+&#39;
        number
    return $ x:xs             -- 連結

number = do
    x &lt;- many1 digit
    return (read x :: Int)

main = do
    parseTest number &quot;123&quot;
    parseTest expr   &quot;1+2&quot;    -- &#39;+&#39;が1個
    parseTest expr   &quot;123&quot;    -- &#39;+&#39;が0個
    parseTest expr   &quot;1+2+3&quot;  -- &#39;+&#39;が2個
```
```text:実行結果
123
[1,2]
[123]
[1,2,3]
```

### sum

リストを合計すれば計算できます。

```hs
import Text.Parsec

expr = do
    x  &lt;- number
    xs &lt;- many $ do
        char &#39;+&#39;
        number
    return $ sum $ x:xs       -- 合計

number = do
    x &lt;- many1 digit
    return (read x :: Int)

main = do
    parseTest number &quot;123&quot;
    parseTest expr   &quot;1+2&quot;    -- OK
    parseTest expr   &quot;123&quot;    -- OK
    parseTest expr   &quot;1+2+3&quot;  -- OK
```
```text:実行結果
123
3
123
6
```

構文解析と計算を分離せずに同時に処理しているのがポイントです。

## 引き算

マイナスの項を足すとして処理します。

```hs
import Text.Parsec

expr = do
    x  &lt;- number
    xs &lt;- many $ do
            char &#39;+&#39;
            number
        &lt;|&gt; do                -- 追加
            char &#39;-&#39;
            y &lt;- number
            return $ -y       -- マイナスの項
    return $ sum $ x:xs

number = do
    x &lt;- many1 digit
    return (read x :: Int)

main = do
    parseTest number &quot;123&quot;
    parseTest expr   &quot;1+2&quot;
    parseTest expr   &quot;123&quot;
    parseTest expr   &quot;1+2+3&quot;
    parseTest expr   &quot;1-2-3&quot;  -- OK
    parseTest expr   &quot;1-2+3&quot;  -- OK
```
```text:実行結果
123
3
123
6
-4
2
```

## 四則演算

掛け算や割り算は`sum`では処理できないため、`many`で関数のリストを返して`foldl`で畳み込みます。

引き算でセクションを作ろうとすると単項演算子扱いされてしまうため、代用関数`subtract`を使います。

```hs
import Text.Parsec

expr = do
    x  &lt;- number
    fs &lt;- many $ do
            char &#39;+&#39;
            y &lt;- number
            return (+ y)               -- セクション
        &lt;|&gt; do
            char &#39;-&#39;
            y &lt;- number
            return $ subtract y        -- 部分適用
        &lt;|&gt; do                         -- 追加：ここから
            char &#39;*&#39;
            y &lt;- number
            return (* y)
        &lt;|&gt; do
            char &#39;/&#39;
            y &lt;- number
            return (`div` y)           -- 追加：ここまで
    return $ foldl (\x f -&gt; f x) x fs

number = do
    x &lt;- many1 digit
    return (read x :: Int)

main = do
    parseTest number &quot;123&quot;
    parseTest expr   &quot;1+2&quot;
    parseTest expr   &quot;123&quot;
    parseTest expr   &quot;1+2+3&quot;
    parseTest expr   &quot;1-2-3&quot;
    parseTest expr   &quot;1-2+3&quot;
    parseTest expr   &quot;2*3+4&quot;           -- OK
    parseTest expr   &quot;2+3*4&quot;           -- NG
    parseTest expr   &quot;100/10/2&quot;        -- OK
```
```text:実行結果
123
3
123
6
-4
2
10
20
5
```

演算子の優先順位が処理できていません。

### 演算子の優先順位

足し算から見ると、1つの数字と掛け算のブロックは項（term）として対等です。数式で例えると $2x+1$ において $2x$ と $1$ が項という単位として $+$ から並列に扱われていることに相当します。

項単位で計算するように分離すれば演算子の優先順位が表現できます。

```hs
import Text.Parsec

expr = do
    x  &lt;- term                         -- 項を取得
    fs &lt;- many $ do
            char &#39;+&#39;
            y &lt;- term                  -- 項を取得
            return (+ y)
        &lt;|&gt; do
            char &#39;-&#39;
            y &lt;- term                  -- 項を取得
            return $ subtract y
    return $ foldl (\x f -&gt; f x) x fs

term = do                              -- exprと同じ構造
    x  &lt;- number
    fs &lt;- many $ do
            char &#39;*&#39;
            y &lt;- number
            return (* y)
        &lt;|&gt; do
            char &#39;/&#39;
            y &lt;- number
            return (`div` y)
    return $ foldl (\x f -&gt; f x) x fs

number = do
    x &lt;- many1 digit
    return (read x :: Int)

main = do
    parseTest number &quot;123&quot;
    parseTest expr   &quot;1+2&quot;
    parseTest expr   &quot;123&quot;
    parseTest expr   &quot;1+2+3&quot;
    parseTest expr   &quot;1-2-3&quot;
    parseTest expr   &quot;1-2+3&quot;
    parseTest expr   &quot;2*3+4&quot;
    parseTest expr   &quot;2+3*4&quot;           -- OK
    parseTest expr   &quot;100/10/2&quot;
```
```text:実行結果
123
3
123
6
-4
2
10
14
5
```

## 演算子

パースに便利な演算子`&lt;*`を紹介します。Applicativeスタイルの一種です。

`左 &lt;* 右`は右の値を捨てて、左の値を返します。`=&lt;&lt;`と違って評価の流れを記号化したわけではなく、左から右に評価されます。

一時変数を避けるのに使えます。同じ結果になるのを確認してください。

```hs
import Text.Parsec
import Control.Applicative ((&lt;*))

test1 = do
    x &lt;- letter          -- 一時変数に結果を束縛
    digit                -- 文字は確認するが結果は捨てる
    return x             -- 一時変数を返す

test2 = letter &lt;* digit  -- test1と同じ処理

main = do
    parseTest test1 &quot;a1&quot;
    parseTest test2 &quot;a1&quot;
```
```text:実行結果
&#39;a&#39;
&#39;a&#39;
```

逆を指す`*&gt;`もありますが`&gt;&gt;`と同じです。`&lt;*`と`*&gt;`は残す値を指示していると見立てます。

```hs
import Text.Parsec
import Control.Applicative ((&lt;*), (*&gt;))

main = do
    parseTest (sequence [letter,    digit, letter]) &quot;a1c&quot;
    parseTest (sequence [letter &lt;*  digit, letter]) &quot;a1c&quot;
    parseTest (sequence [letter  *&gt; digit, letter]) &quot;a1c&quot;
    parseTest (sequence [letter  &gt;&gt; digit, letter]) &quot;a1c&quot;
```
```text:実行結果
&quot;a1c&quot;
&quot;ac&quot;
&quot;1c&quot;
&quot;1c&quot;
```

## 整理

共通する処理を関数化して、Applicativeスタイルでコードを整理します。処理の流れは同じです。

```hs
import Text.Parsec
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;), (*&gt;))

eval m fs = foldl (\x f -&gt; f x) &lt;$&gt; m &lt;*&gt; fs
apply f m = flip f &lt;$&gt; m

expr = eval term $ many $
        char &#39;+&#39; *&gt; apply (+) term
    &lt;|&gt; char &#39;-&#39; *&gt; apply (-) term

term = eval number $ many $
        char &#39;*&#39; *&gt; apply (*) number
    &lt;|&gt; char &#39;/&#39; *&gt; apply div number

number = read &lt;$&gt; many1 digit

main = do
    parseTest number &quot;123&quot;
    parseTest expr   &quot;1+2&quot;
    parseTest expr   &quot;123&quot;
    parseTest expr   &quot;1+2+3&quot;
    parseTest expr   &quot;1-2-3&quot;
    parseTest expr   &quot;1-2+3&quot;
    parseTest expr   &quot;2*3+4&quot;
    parseTest expr   &quot;2+3*4&quot;
    parseTest expr   &quot;100/10/2&quot;
```
```text:実行結果
123
3
123
6
-4
2
10
14
5
```

簡潔で形式的な記述になりました。いきなりこのコードを見ても形式的過ぎて理解しにくいかもしれませんが、コードの変形過程を追ってみてください。

## BNF

ここまで実装したような処理はBNF（[バッカス・ナウア記法](https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95)）と呼ばれる形式言語で記述できます。

拡張版の[EBNF](https://ja.wikipedia.org/wiki/EBNF)で示します。

```text:EBNF
expr = term  , {&quot;+&quot;|&quot;-&quot;, term  }
term = number, {&quot;*&quot;|&quot;/&quot;, number}
```

### 変形

今回のコードに合わせてEBNFを変形します。

演算子それぞれに処理を記述します。

```text:EBNF
expr = term  , {(&quot;+&quot;, term  ) | (&quot;-&quot;, term  )}
term = number, {(&quot;*&quot;, number) | (&quot;/&quot;, number)}
```

この変形は数式の展開に似ています。EBNFの`|`を足し算、`,`を掛け算に見立てます。コードでは`&lt;|&gt;`と`*&gt;`に相当します。`*&gt;`は`*`が掛け算っぽいです。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;種類&lt;/th&gt;&lt;th&gt;展開前&lt;/th&gt;&lt;th&gt;展開後&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数式&lt;/td&gt;&lt;td&gt;$(p + m)t$&lt;/td&gt;&lt;td&gt;$pt + mt$&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;EBNF&lt;/td&gt;&lt;td&gt;&lt;code&gt;&quot;+&quot;|&quot;-&quot;, term&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;(&quot;+&quot;, term) | (&quot;-&quot;, term)&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;コード&lt;/td&gt;&lt;td&gt;&lt;code&gt;(char &#39;+&#39; &amp;lt;|&gt; char &#39;-&#39;) *&gt; term&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;char &#39;+&#39; *&gt; term &amp;lt;|&gt; char &#39;-&#39; *&gt; term&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ `*&gt;`の実体は`&gt;&gt;`と同じで`&gt;&gt;=`に行きつくため（`a &gt;&gt; b = a &gt;&gt;= \_ -&gt; b`）、`&gt;&gt;=`も掛け算だと見立てられることになります。今回の範囲を超えるため詳細は省略します。

### 比較

コードにコメントとして追記するので比較してください。慣れて来れば、先にBNFで定義してからコードを書いた方が効率的だと感じるでしょう。

```hs:比較
-- expr = term, {(&quot;+&quot;, term) | (&quot;-&quot;, term)}
expr = eval term $ many $
        char &#39;+&#39; *&gt; apply (+) term
    &lt;|&gt; char &#39;-&#39; *&gt; apply (-) term

-- term = number, {(&quot;*&quot;, number) | (&quot;/&quot;, number)}
term = eval number $ many $
        char &#39;*&#39; *&gt; apply (*) number
    &lt;|&gt; char &#39;/&#39; *&gt; apply div number
```

このコードはなるべくBNFに近付けるよう意識しています。このような使い方は[ドメイン固有言語](https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%9B%BA%E6%9C%89%E8%A8%80%E8%AA%9E)（DSL）に見立てられます。

&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;ja&quot;&gt;&lt;p lang=&quot;ja&quot; dir=&quot;ltr&quot;&gt;Haskellのモナドは、言語内DSLを定義するための型クラスです。モナドのインスタンスは、何か用のDSLなんだと思えばいいです。それ以上、難しく考える必要はありません。&lt;/p&gt;&amp;mdash; 山本和彦 (@kazu_yamamoto) &lt;a href=&quot;https://twitter.com/kazu_yamamoto/status/555195571724492800&quot;&gt;2015, 1月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;ja&quot;&gt;&lt;p lang=&quot;ja&quot; dir=&quot;ltr&quot;&gt;モナドって文字を見たら、言語内DSLに変換して下さい。たとえば、Parser モナドは、Parser 用の DSL です。&lt;/p&gt;&amp;mdash; 山本和彦 (@kazu_yamamoto) &lt;a href=&quot;https://twitter.com/kazu_yamamoto/status/406047095708082176&quot;&gt;2013, 11月 28&lt;/a&gt;&lt;/blockquote&gt;

## 練習

【問6】項の下位に因子（factor）という層を追加して、括弧をサポートしてください。`&lt;*`を使ってください。

具体的には次のコードが動くようにしてください。

```hs
main = do
    parseTest expr &quot;(2+3)*4&quot;
```
```text:実行結果
20
```

ヒント: `factor = (&quot;(&quot;, expr, &quot;)&quot;) | number`

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E6%8B%AC%E5%BC%A7)

【問7】スペースを無視してください。

具体的には次のコードが動くようにしてください。

```hs
main = do
    parseTest expr &quot;1 + 2&quot;
    parseTest expr &quot;123&quot;
    parseTest expr &quot;1 + 2 + 3&quot;
    parseTest expr &quot;1 - 2 - 3&quot;
    parseTest expr &quot;1 - 2 + 3&quot;
    parseTest expr &quot;2 * 3 + 4&quot;
    parseTest expr &quot;2 + 3 * 4&quot;
    parseTest expr &quot;100 / 10 / 2&quot;
    parseTest expr &quot;( 2 + 3 ) * 4&quot;
```
```text:実行結果
3
123
6
-4
2
10
14
5
20
```

ヒント: [spaces](https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Char.html#v:spaces)

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E3%82%B9%E3%83%9A%E3%83%BC%E3%82%B9)

【問8】問7の解答を、Parsecを使わずに問5の解答の自前実装に足りない関数を補って動かしてください。ただし次のように演算子の優先順位を指定する必要があります。

```hs:演算子の優先順位
infixr 1 &lt;|&gt;
```

ヒント: `spaces = skipMany space`

⇒ [解答例](http://qiita.com/7shi/items/f65814b1e91d48ec8d12#%E8%87%AA%E5%89%8D%E5%AE%9F%E8%A3%85)

# リファレンス

ここまで自前実装すればもう十分でしょう。この先はParsecを使いこなすことに集中する段階です。必要に応じてリファレンスを参照してください。

* [parsec](http://hackage.haskell.org/package/parsec-3.1.9)

よく使うのは以下のモジュールです。

* [Text.Parsec](http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html)
* [Text.Parsec.Char](http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Char.html)

# 実装解説

Parsecのソースは今回の自前実装よりもかなり複雑です。興味があれば@hirataraさんの記事を参照してください。

* 2013.02.14 [Parsecのソースちら見](http://qiita.com/hiratara/items/b10ea9fa5d4e8e471a7c)
* 2013.02.15 [Parsecのソースちら見(2)](http://qiita.com/hiratara/items/755cd0e7f4b4cecf60da)
* 2013.02.15 [Parsecのソースちら見(3)](http://qiita.com/hiratara/items/a451b04fb19bfcc7ff08)

# 謝辞

パーサについては[@kazu_yamamoto](https://twitter.com/kazu_yamamoto)先生よりご教示いただきました。

&lt;blockquote lang=&quot;ja&quot;&gt;&lt;p lang=&quot;ja&quot; dir=&quot;ltr&quot;&gt;&amp;lt;|&amp;gt; は Alternative 型クラスのメソッドです。import Control.Applicative すれば、Maybe でも &amp;lt;|&amp;gt; は使えます。&lt;/p&gt;&amp;mdash; 山本和彦 (@kazu_yamamoto) &lt;a href=&quot;https://twitter.com/kazu_yamamoto/status/519030642428747776&quot;&gt;2014, 10月 6&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote data-conversation=&quot;none&quot; lang=&quot;ja&quot;&gt;&lt;p lang=&quot;ja&quot; dir=&quot;ltr&quot;&gt;Alternative は制限の緩い MonadPlus です。Monad が掛け算、MonadPlus が足し算の系を表します。MonadPlus はもう古いので、忘れて Alternative を使って下さい。&lt;/p&gt;&amp;mdash; 山本和彦 (@kazu_yamamoto) &lt;a href=&quot;https://twitter.com/kazu_yamamoto/status/519031028040474624&quot;&gt;2014, 10月 6&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote data-conversation=&quot;none&quot; lang=&quot;ja&quot;&gt;&lt;p lang=&quot;ja&quot; dir=&quot;ltr&quot;&gt;ちなみに Parsec の &amp;lt;|&amp;gt; は、Alternative ではなく、独自実装だったと思います。&lt;/p&gt;&amp;mdash; 山本和彦 (@kazu_yamamoto) &lt;a href=&quot;https://twitter.com/kazu_yamamoto/status/519031170822975488&quot;&gt;2014, 10月 6&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote data-conversation=&quot;none&quot; lang=&quot;ja&quot;&gt;&lt;p lang=&quot;ja&quot; dir=&quot;ltr&quot;&gt;Alternative に関しては、このスライドを見ると、頭なの中がすっきりするかもしれません。 &lt;a href=&quot;http://t.co/v5MH4a6eP5&quot;&gt;http://t.co/v5MH4a6eP5&lt;/a&gt;&lt;/p&gt;&amp;mdash; 山本和彦 (@kazu_yamamoto) &lt;a href=&quot;https://twitter.com/kazu_yamamoto/status/519035278321651712&quot;&gt;2014, 10月 6&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote data-conversation=&quot;none&quot; lang=&quot;ja&quot;&gt;&lt;p lang=&quot;ja&quot; dir=&quot;ltr&quot;&gt;パーサに関しては、Hutton さんのページに、ちゃんと動くコードがあるので、それを写経するといいかもしれません。僕がパーサの修行に実装したパーサは、これです。 &lt;a href=&quot;http://t.co/1zxNHojuJ2&quot;&gt;http://t.co/1zxNHojuJ2&lt;/a&gt;&lt;/p&gt;&amp;mdash; 山本和彦 (@kazu_yamamoto) &lt;a href=&quot;https://twitter.com/kazu_yamamoto/status/519035854237356032&quot;&gt;2014, 10月 6&lt;/a&gt;&lt;/blockquote&gt;

# おわりに

個人的にはParsecの挙動を理解することがHaskellを勉強し始めた動機でした。当初はモナドの扱いに慣れていなかったことと相まって、Parsecが内部でどのような処理を行っているかがまったく想像できずに、ブラックボックスとして使うことすら困難を覚えました。

Haskellの勉強を進めるうちに、パーサがStateモナドとMaybeモナドの合成で表現できることに気付いたのが突破口となりました。

* [Parsecをモナド変換子で模倣](http://qiita.com/7shi/items/201f379443079736e18e) 2015.4.28

今回は昔の自分のような困難を感じている人を想定して、Parsecを使う前に動作原理を説明しました。超入門シリーズは今回の構文解析が1つの山場となっているため、Maybeモナド以降は構文解析に関係するサンプルを入れて、今回の内容につながるよう構成しています。

自前実装により動作原理が把握できれば、Parsecを使うときにも何となく動きが推測できるようになるでしょう。そうすれば勘が働いて応用も思い付きやすくなります。
</textarea><input type="submit" name="commit" value="Save changes" data-disable-with="Save changes" /></form></div></section></div><div class="col-sm-3"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="Haskell 構文解析 超入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="Haskell 構文解析 超入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div><section class="itemsShowAuthorInfo" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><a href="/7shi"><img alt="" class="itemsShowAuthorInfo_userIcon" itemprop="image" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" /></a><div class="itemsShowAuthorInfo_profileStats"><strong class="itemsShowAuthorInfo_userName" itemprop="name"><a itemprop="url" href="/7shi">7shi</a></strong><div class="itemsShowAuthorInfo_contribution"><span class="itemsShowAuthorInfo_count">2522</span><span class="itemsShowAuthorInfo_unit">Contribution</span></div><div data-react-class="T.UserFollowButton" data-react-props="{&quot;url_name&quot;:&quot;7shi&quot;,&quot;initial_followed_by&quot;:false,&quot;size&quot;:&quot;btn-xs&quot;,&quot;position&quot;:&quot;author-info&quot;}"></div></div><section class="itemsShowAuthorPopularItems"><h5 class="itemsShowAuthorPopularItems_sectionTitle">Popular Posts</h5><ul class="itemsShowAuthorPopularItems_posts list-unstyled"><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/145f1234f8ec2af923ef">Haskell 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/547b6137d7a3c482fe68">モナド則がちょっと分かった？</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/cac7b3e9b90bf91b00cc">文字列で学ぶC++入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/85afd7bbd5d6c4115ad6">Haskell アクション 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/d1e5a0c22be6cf61d286">Haskell IDE Leksah 入門</a></li></ul></section></section><div class="scroll-chaser"><div class="google-adsense"><style>.test-text-responsible { width: 200px; height: 200px; }@media(min-width: 1200px) {  .test-text-responsible { width: 250px; height: 250px; }}@media(max-width: 979px) and (min-width: 768px) {  .test-text-responsible { width: 120px; height: 240px; }}@media(max-width: 767px) {  .test-text-responsible { width: 320px; height: 50px; }}</style><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle test-text-responsible" data-ad-client="ca-pub-8127218772604357" data-ad-slot="3880091879" style="display:inline-block"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div><div data-react-class="T.Toc" data-react-props="{&quot;body&quot;:&quot;\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%8B%95%E4%BD%9C%E5%8E%9F%E7%90%86\&quot;\u003e動作原理\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%A2%E3%83%8A%E3%83%89%E3%81%AA%E3%81%97\&quot;\u003eモナドなし\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#1%E6%96%87%E5%AD%97%E5%8F%96%E5%BE%97\&quot;\u003e1文字取得\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%80%A3%E7%B6%9A%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97\&quot;\u003e連続呼び出し\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%90%E6%9E%9C%E3%81%AE%E5%88%86%E9%9B%A2\&quot;\u003e結果の分離\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0%E5%8C%96\&quot;\u003e関数化\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B\&quot;\u003e組み合わせ\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%A8%E3%83%A9%E3%83%BC\&quot;\u003eエラー\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%86%E3%82%B9%E3%83%88%E9%96%A2%E6%95%B0\&quot;\u003eテスト関数\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%9D%A1%E4%BB%B6%E5%8F%96%E5%BE%97\&quot;\u003e条件取得\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BA%8B%E5%89%8D%E5%AE%9A%E7%BE%A9\&quot;\u003e事前定義\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E5%88%A4%E5%AE%9A\&quot;\u003e組み合わせ判定\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%BE%E3%81%A8%E3%82%81\&quot;\u003eまとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#state%E3%83%A2%E3%83%8A%E3%83%89\&quot;\u003eStateモナド\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#sequence\&quot;\u003esequence\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#maybe%E3%83%A2%E3%83%8A%E3%83%89\&quot;\u003eMaybeモナド\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-1\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#either%E3%83%A2%E3%83%8A%E3%83%89\&quot;\u003eEitherモナド\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%A2%E3%83%8A%E3%83%89%E5%A4%89%E6%8F%9B%E5%AD%90%E3%81%A7%E5%90%88%E6%88%90\&quot;\u003eモナド変換子で合成\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%81%B8%E6%8A%9E\&quot;\u003e選択\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0%E3%81%A7%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97\&quot;\u003e関数で繰り返し\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-2\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#parsec\&quot;\u003eParsec\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF\&quot;\u003eエラーチェック\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-3\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF\&quot;\u003eバックトラック\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#try\&quot;\u003etry\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#string\&quot;\u003estring\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#ll1\&quot;\u003eLL(1)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-4\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97%E5%99%A8\&quot;\u003e四則演算器\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%95%B0%E5%AD%97\&quot;\u003e数字\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%95%B0%E5%80%A4\&quot;\u003e数値\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%B6%B3%E3%81%97%E7%AE%97\&quot;\u003e足し算\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#many\&quot;\u003emany\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#sum\&quot;\u003esum\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%BC%95%E3%81%8D%E7%AE%97\&quot;\u003e引き算\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97\&quot;\u003e四則演算\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%84%AA%E5%85%88%E9%A0%86%E4%BD%8D\&quot;\u003e演算子の優先順位\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%BC%94%E7%AE%97%E5%AD%90\&quot;\u003e演算子\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%95%B4%E7%90%86\&quot;\u003e整理\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#bnf\&quot;\u003eBNF\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A4%89%E5%BD%A2\&quot;\u003e変形\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%AF%94%E8%BC%83\&quot;\u003e比較\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-5\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9\&quot;\u003eリファレンス\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%AE%9F%E8%A3%85%E8%A7%A3%E8%AA%AC\&quot;\u003e実装解説\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%AC%9D%E8%BE%9E\&quot;\u003e謝辞\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB\&quot;\u003eおわりに\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n&quot;,&quot;wrapper&quot;:&quot;#article-body-wrapper&quot;}"></div></div></div><div class="row"><div class="col-sm-9"><div class="ArticleFooter__menu"><div class="s-flex-align-center"><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:37,&quot;show_count&quot;:true,&quot;uuid&quot;:&quot;b8c741e78a96ea2c10fe&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-footer&quot;}"></div><div class="ArticleFooter__userList"><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="cotrpepe"><a itemprop="url" href="/cotrpepe"><img alt="cotrpepe" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/46434/profile-images/1473690647" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="nagai_akinari"><a itemprop="url" href="/nagai_akinari"><img alt="nagai_akinari" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/53556/profile-images/1475478164" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="tapioga"><a itemprop="url" href="/tapioga"><img alt="tapioga" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38349/profile-images/1473687732" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="bells17"><a itemprop="url" href="/bells17"><img alt="bells17" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/13148/profile-images/1473682696" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="junnpit"><a itemprop="url" href="/junnpit"><img alt="junnpit" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/37177/profile-images/1473687332" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="lesguillemets"><a itemprop="url" href="/lesguillemets"><img alt="lesguillemets" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/63937/profile-images/1473696424" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="takehiroman"><a itemprop="url" href="/takehiroman"><img alt="takehiroman" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/37030/profile-images/1473687285" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="HiromiKai_Green"><a itemprop="url" href="/HiromiKai_Green"><img alt="HiromiKai_Green" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/12864/profile-images/1473682573" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="wadahiro"><a itemprop="url" href="/wadahiro"><img alt="wadahiro" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/35233/profile-images/1473686651" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="ksoda"><a itemprop="url" href="/ksoda"><img alt="ksoda" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/42409/profile-images/1473689147" /></a></div></div><div class="ArticleFooter__user"><a href="/7shi/items/b8c741e78a96ea2c10fe/likers"><span class="fa fa-ellipsis-h"></span></a></div></div></div><div class="u-flex u-align-center"><div class="ArticleFooter__stock"><div class="js-stockbutton" data-position="footer_menu" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="ArticleFooter__editRequest"><a class="u-link-no-underline" data-toggle="tooltip" title="You can propose improvements about the article to the author 💪" href="/drafts/b8c741e78a96ea2c10fe/edit"><span class="fa fa-send-o fa-lg"></span> <span>Edit request</span></a></div><div class="dropdown ArticleFooter__dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h"></span></a><ul class="dropdown-menu dropdown-menu-right"><li><a href="/7shi/items/b8c741e78a96ea2c10fe.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><i class="fa fa-fw fa-flag"></i> Report article</a></li></ul></div></div></div><ul class="references js-referencesView"><li class="references_header"><i class="fa fa-fw fa-link"></i> Linked from these articles</li><a class="references_toggleOldReferences js-toggleOldReferences" href="#"><i class="fa fa-expand js-toggleOldReferencesIcon"></i><span class="js-toggleOldReferencesText">Show old 15 links</span></a><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/f65814b1e91d48ec8d12#_reference-c0209167ed2dbb17ae94"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />【解答例】Haskell 構文解析 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:48:22+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/145f1234f8ec2af923ef#_reference-8eedff44cd2808559cf6"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:53:22+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/1ce76bde464b4a55c143#_reference-dc832a7546c6907194b8"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell 代数的データ型 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:53:59+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/85afd7bbd5d6c4115ad6#_reference-9bfa2bc3015e264ade35"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell アクション 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:54:23+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/1345bf32003faff435cb#_reference-2e1fb51a7a1982ef44db"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell ラムダ 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:54:40+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/4a8a2807bb5186576c61#_reference-9f8f1596eb500cf72bba"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell アクションとラムダ 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:55:19+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/d3d3492ddd90d47160f2#_reference-eaab07e8583d58807005"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell IOモナド 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:55:44+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/deb19c4cba933590ffbf#_reference-936d87c4b956b95bea37"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell リストモナド 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:57:02+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/c7d7eec066af0fe0688d#_reference-9de6000efea00a0dab12"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell Maybeモナド 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:57:37+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/2e9bff5d88302de1a9e9#_reference-611c0b3441dcfa1a4ca5"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell 状態系モナド 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:57:58+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/4408b76624067c17e933#_reference-18343460d60b60d45847"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell モナド変換子 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:58:23+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/73e534c47bbebc71b37e#_reference-6c82177657b7c6d08136"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell 例外処理 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-07-31T06:59:07+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/ee5afe4f088f0a1fc8c2#_reference-a956542cb87d4edc4b13"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Stateモナドによる中置記法の処理</a><time class="references_datetime js-dateTimeView" datetime="2015-08-03T02:05:08+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/201f379443079736e18e#_reference-c3c94864a4fcf2074a24"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Parsecをモナド変換子で模倣</a><time class="references_datetime js-dateTimeView" datetime="2015-09-03T11:06:36+00:00">over 1 year ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/6a12160276a8db358e34#_reference-cab19670931aa7c8b0fa"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />C++11 パーサコンビネータ 超入門</a><time class="references_datetime js-dateTimeView" datetime="2015-11-27T14:38:39+00:00">over 1 year ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/f86f2f7ad68cfff1b399#_reference-8c443d52c4e2208115f5"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />C++11 パーサコンビネータ 超入門 2</a><time class="references_datetime js-dateTimeView" datetime="2015-11-30T09:20:02+00:00">over 1 year ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/lesguillemets/items/b58e684a773fb4b5e4aa#_reference-89b23ea8fd959056abcd"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/63937/profile-images/1473696424" />Haste + Parsec でブラウザ上で動く電卓をつくる</a><time class="references_datetime js-dateTimeView" datetime="2015-12-19T14:38:02+00:00">about 1 year ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/68228e19552c271bea81#_reference-ef4d36436f6b8e2b21f8"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Java パーサコンビネータ 超入門</a><time class="references_datetime js-dateTimeView" datetime="2016-05-12T05:23:39+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/39a9ddffcc5bdf2c0142#_reference-128b4085c98224769d4a"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Java パーサコンビネータ 超入門 2</a><time class="references_datetime js-dateTimeView" datetime="2016-05-13T16:54:03+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/04c2991239894687ef2f#_reference-2af297d76406bc381078"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />JSONパーサーを作る</a><time class="references_datetime js-dateTimeView" datetime="2016-12-26T13:38:03+00:00">2 months ago</time></li></ul><div class="itemsShowBody_articleColumnFooter"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="Haskell 構文解析 超入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="Haskell 構文解析 超入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div></div><div class="itemsShowComment_wrapper" id="comments"><div data-react-class="T.CommentListContainer" data-react-props="{&quot;currentUser&quot;:null,&quot;initialComments&quot;:[],&quot;monthly_public_image_uploadable_size_limit&quot;:null,&quot;total_uploaded_public_image_size_in_current_month&quot;:null,&quot;item&quot;:{&quot;id&quot;:319410,&quot;uuid&quot;:&quot;b8c741e78a96ea2c10fe&quot;,&quot;suspended&quot;:false,&quot;secret&quot;:false},&quot;owner&quot;:{&quot;url_name&quot;:&quot;7shi&quot;},&quot;is_team&quot;:false,&quot;is_project&quot;:false,&quot;logged_in&quot;:false,&quot;polling&quot;:false,&quot;mention_candidates&quot;:[{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}]}">Comments Loading...</div></div></div></div></div></article><div class="js-report-form modal fade reportForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Report article</h4></div><div class="modal-body"><form action="/reports" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="PIDKESNm2DRGpKBiloZtpi1/H2ZkxVARinZAaYUTGlxSAlFJuEjhf7l3FX7mc9P/TTg71fMBCua2qEmSZB0Umg==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/b8c741e78a96ea2c10fe" /><input type="hidden" name="item_uuid" id="item_uuid" value="b8c741e78a96ea2c10fe" /><p>Help us understand the problem. What is going on with this item?</p><br /><div class="form-group"><ul class="list-unstyled"><li><label><input type="radio" name="report_type" id="report_type_spam" value="spam" required="required" /> It&#39;s spam </label></li><li><label><input type="radio" name="report_type" id="report_type_harassment" value="harassment" required="required" /> It&#39;s abusive or harmful </label></li><li><label><input type="radio" name="report_type" id="report_type_inappropriate_content" value="inappropriate_content" required="required" /> It contains inappropriate content </label></li></ul></div><div class="reportForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary reportForm_submitButton"><i class="fa fa-send"></i> Submit</button></div></form></div></div></div></div><script id="js-item" type="application/json">{ "url": "http://qiita.com/7shi/items/b8c741e78a96ea2c10fe", "id": 319410, "uuid": "b8c741e78a96ea2c10fe" }</script><script class="js-user" type="application/json">{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}</script><script language="JavaScript" src="//cdn.bigmining.com/private/js/qiita_bigmining.js" type="text/javascript"></script></div><footer class="footer"><div class="footer_inner"><div class="footer_container"><ul class="footer_links-left"><li class="footer_link"><a class="footer_copyright" href="http://increments.co.jp">© 2011-2017 Increments Inc.</a></li><li class="footer_link"><a href="http://qiita.com/terms">Terms</a></li><li class="footer_link"><a href="http://qiita.com/privacy">Privacy</a></li><li class="footer_link"><a href="http://help.qiita.com">Help</a></li><li class="footer_link"><a href="https://increments.zendesk.com/anonymous_requests/new">Contact</a></li></ul><ul class="footer_links-right"><li class="footer_link"><a href="http://qiita.com/about">About</a></li><li class="footer_link"><a href="/users">Users</a></li><li class="footer_link"><a href="/tags">Tags</a></li><li class="footer_link"><a href="http://blog.qiita.com">Blog</a></li><li class="footer_link"><a href="http://qiita.com/api/v2/docs">API</a></li><li class="footer_link"><a href="https://teams.qiita.com/">Team</a></li><li class="footer_link"><a href="http://kobito.qiita.com">Kobito</a></li><li class="footer_link"><a class="js-public-form-feedback-link" data-target=".js-feedback-form" data-toggle="modal" href=""><i class="fa fa-heart"></i> Feedback <i class="fa fa-caret-down"></i></a></li></ul></div></div></footer><div class="js-feedback-form modal fade feedbackForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Feedback</h4></div><div class="modal-body"><form class="js-feedback-form-form" action="/feedbacks" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="NIa7meBLJMit9jPYGLZ+RxJ4EmQT8/wqjhxjC32AARxaBCDBe2Udg1IlhsRoQ8Aecj8214Q3pt2ywmrwnI4P2g==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/b8c741e78a96ea2c10fe" /><div class="form-group"><textarea name="feedback[message]" id="feedback_message" class="form-control js-feedback-form-text-area" placeholder="Please give us any feedback about Qiita." required="required" rows="5">
</textarea></div><div class="feedbackForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary feedbackForm_submitButton"><i class="fa fa-send"></i> Submit</button><p class="feedbackForm_note">We don&#39;t reply to any feedback.<br />If you need help with Qiita, please send a support request from <a href="https://increments.zendesk.com/anonymous_requests/new">here</a>.</p></div><div style="position:fixed;top:-99999px;opacity:0.0001;"><input name="feedback[name]" type="text" /></div></form></div></div></div></div><script>// if (window.mixpanel instanceof Element) {
//   window.mixpanel = [];
// }
// (function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
// for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);</script><script src="http://cdn.qiita.com/assets/public-8c6201a66dc6db6f64a9017391c319bf.min.js"></script><script>
  (function () {
    var script = document.getElementsByTagName('script')[0];
    var load = function (src, id) {
      var el = document.createElement('script');
      el.async = true;
      el.src = src;
      el.id = id;
      script.parentNode.insertBefore(el, script);
    };
      // Optimizely
      load('//cdn.optimizely.com/js/52738645.js', 'optimizely-jssdk');
      // Google Analytics
      window._gaq = window._gaq || [];
      var isCareer = location.hostname.split('.')[0] == 'career';
      if (isCareer) {
        window._gaq.push(['_setAccount', 'UA-24675221-11']);
        window._gaq.push(['_setDomainName', 'qiita.com']);
      } else {
        window._gaq.push(['_setAccount', 'UA-24675221-1']);
      }
      window._gaq.push(['_setCustomVar', 1, 'logged_in', 'false', 2]);
      window._gaq.push(['_trackPageview']);
      var src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      load(src, 'google-analytics-jssdk');
    // Google Analytics - Universal Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-24675221-12', {
          
        });
        ga('set', 'dimension1', 'false');
        ga('set', 'dimension3', 'false');
      ga('require', 'displayfeatures');
      ga('set', 'forceSSL', true);
      ga('send', 'pageview');
    // Google Tag Manager
      (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-TBQWPN');
  })();
</script>
</body></html>