<!DOCTYPE html><html xmlns:og="http://ogp.me/ns#"><head><meta charset="UTF-8" /><title>Java パーサコンビネータ 超入門 - Qiita</title><meta content="width=device-width,initial-scale=1" name="viewport" /><meta content="構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。

この記事は再帰下降構文解析の知識を前提とします。詳細は次の記事を参照してください。



Java 再帰下降構文解析 超入門 2016.05.16


Javaには既存のパーサコンビネータがありますが、この記事では使用しません。


jparsec
ParsecJ


この記事で..." name="description" /><meta content="summary" name="twitter:card" /><meta content="@Qiita" name="twitter:site" /><meta content="7shi" name="twitter:creator" /><meta content="Java パーサコンビネータ 超入門 - Qiita" property="og:title" /><meta content="article" property="og:type" /><meta content="http://qiita.com/7shi/items/68228e19552c271bea81" property="og:url" /><meta content="http://cdn.qiita.com/assets/qiita-fb-2887e7b4aad86fd8c25cea84846f2236.png" property="og:image" /><meta content="構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。

この記事は再帰下降構文解析の知識を前提と..." property="og:description" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><link rel="shortcut icon" type="image/x-icon" href="http://cdn.qiita.com/assets/favicons/public/production-4ff10c1e1e2b5fcb353ff9cafdd56c70.ico" /><link rel="apple-touch-icon" type="image/png" href="http://cdn.qiita.com/assets/favicons/public/apple-touch-icon-f9a6afad761ec2306e10db2736187c8b.png" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link rel="stylesheet" media="all" href="http://cdn.qiita.com/assets/public-e8d29e8ff1879118096f0f5877946857.min.css" /><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="xKU7dClP1xuu8NTr9/e0mrLfmZWn4cjzwimbsq/RDKWqJ6AssmHuUFEjYfeHAgrD0pi9JjAlkgT+95JJTt8CYw==" /></head><body class="without-js" id=""><noscript><iframe height="0" src="//www.googletagmanager.com/ns.html?id=GTM-TBQWPN" style="display:none;visibility:hidden" width="0"></iframe></noscript><script>
  document.body.className = document.body.className.replace('without-js', '') + ' with-js';
  window.Qiita = {"asset_host":"cdn.qiita.com","TLD":"com","controller_path":"public/items","controller_action":"public/items#show","controller":"items","action":"show","env":"production","flash":{},"is_landing_page":false,"is_team_page":false,"root_domain":"qiita.com","variant":null,"config":{"mixpanel":{"career":"dd35af27e959781713d63fd7ca898a8d","per_team":"c0a2116368b33b44b5029ebd2cc9b094","public":"be87616606b0e26a87689099aab2c4e5","team":"b7c0342acba2dbc8742484d98788efb3"},"default_locale":"ja","locale":"en"},"team":null,"user":null,"GIT_BRANCH":null,"DEBUG":false};

</script>
<div class="headerContainer headerContainer-public" role="navigation"><div data-react-class="T.HeaderContainer" data-react-props="{&quot;user&quot;:null,&quot;team&quot;:null,&quot;news&quot;:{&quot;type&quot;:&quot;Hot&quot;,&quot;content&quot;:&quot;Markdownによる情報共有サービス、Qiita:Team&quot;,&quot;url&quot;:&quot;https://teams.qiita.com?utm_source=qiita\u0026utm_medium=header_news&quot;},&quot;initial_unread_count&quot;:null,&quot;siteid_image&quot;:&quot;http://cdn.qiita.com/siteid-reverse.png&quot;,&quot;is_team_page&quot;:false,&quot;on_team_setting&quot;:false,&quot;show_post_menu&quot;:true,&quot;show_search_menu&quot;:true,&quot;is_fluid&quot;:false,&quot;locale&quot;:&quot;en&quot;}"></div></div><div id="main"><ol class="itemBreadcrumbs" itemscope="" itemtype="http://schema.org/BreadcrumbList"><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/"><span itemprop="name">Qiita</span></a><meta content="1" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/items"><span itemprop="name">Items</span></a><meta content="2" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/tags/Java"><span itemprop="name">Java</span></a><meta content="3" itemprop="position" /></li></ol><article itemscope="" itemtype="http://schema.org/Article"><div class="ArticleMainHeader "><div class="container"></div><div class="container"><div class="row s-flex-align-center"><div class="col-sm-9"><h1 class="ArticleMainHeader__title">Java パーサコンビネータ 超入門</h1><ul class="TagList"><li class="TagList__item" data-count="6289"><a class="u-link-unstyled TagList__label" href="/tags/Java"><img alt="Java" class="TagList__icon" src="https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/1bfaf60121121d7dec866c83d4c4453347ec93e2/medium.jpg?1436171387" /><span>Java</span></a></li></ul></div><div class="col-sm-3"><div class="itemsShowHeaderStock"><ul class="list-unstyled itemsShowHeaderStock_statusList"><li><div class="itemsShowHeaderStock_count stock"><span class="fa fa-thumbs-up"></span><span class="js-likecount">50</span></div><div class="itemsShowHeaderStock_countText">Like</div></li><li><div class="itemsShowHeaderStock_count" content="0 UserComments" itemprop="interactionCount"><span class="fa fa-comment"></span>0</div><div class="itemsShowHeaderStock_countText">Comment</div></li></ul></div><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:50,&quot;uuid&quot;:&quot;68228e19552c271bea81&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-header&quot;}"></div><ul class="list-inline ArticleMainHeader__users"><li class="js-hovercard" data-hovercard-target-name="knok"><a itemprop="url" href="/knok"><img alt="knok" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/31714/profile-images/1473685754" /></a></li><li class="js-hovercard" data-hovercard-target-name="komlow"><a itemprop="url" href="/komlow"><img alt="komlow" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/7697/profile-images/1473680675" /></a></li><li class="js-hovercard" data-hovercard-target-name="pogin503"><a itemprop="url" href="/pogin503"><img alt="pogin503" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/288/profile-images/1473683566" /></a></li><li class="js-hovercard" data-hovercard-target-name="y_q1m"><a itemprop="url" href="/y_q1m"><img alt="y_q1m" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/102004/profile-images/1473708557" /></a></li><li class="js-hovercard" data-hovercard-target-name="tomoki1207"><a itemprop="url" href="/tomoki1207"><img alt="tomoki1207" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/111100/profile-images/1473711451" /></a></li><li class="js-hovercard" data-hovercard-target-name="hamu502"><a itemprop="url" href="/hamu502"><img alt="hamu502" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38910/profile-images/1473687923" /></a></li><li class="js-hovercard" data-hovercard-target-name="koher"><a itemprop="url" href="/koher"><img alt="koher" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/47085/profile-images/1473690868" /></a></li><li class="js-hovercard" data-hovercard-target-name="hiroyukim"><a itemprop="url" href="/hiroyukim"><img alt="hiroyukim" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/31388/profile-images/1473685683" /></a></li><li class="js-hovercard" data-hovercard-target-name="kimuraya"><a itemprop="url" href="/kimuraya"><img alt="kimuraya" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/18533/profile-images/1473682460" /></a></li><li class="js-hovercard" data-hovercard-target-name="giantneco"><a itemprop="url" href="/giantneco"><img alt="giantneco" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/1655/profile-images/1473683754" /></a></li><li><a href="/7shi/items/68228e19552c271bea81/likers"><span class="fa fa-ellipsis-h"></span></a></li></ul></div></div></div></div><div class="ArticleAsideHeader"><div class="container"><div class="u-flex u-space-between"><div class="u-flex u-flex-wrap"><div class="u-flex u-align-center s-pdv-5 u-flex-wrap"><div class="ArticleAsideHeader__author"><a href="/7shi"><img class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" alt="1473685823" /></a> <a class="u-link-unstyled" href="/7shi">7shi</a> </div><div class="ArticleAsideHeader__date"><span data-toggle="tooltip" title="posted at 2016-05-12">Edited at <time datetime="2016-12-27T02:32:55+09:00" itemprop="dateModified">2016-12-27</time></span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"><div class="ArticleAsideHeader__revision"> <a data-toggle="tooltip" title="Revisions" href="/7shi/items/68228e19552c271bea81/revisions"><span class="fa fa-history"></span></a><span class="ArticleAsideHeader__revisionCount">16</span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"></div></div><div class="u-flex u-align-center s-flex-justiry-between s-pdv-5 u-shrink-0"><div class="ArticleAsideHeader__stock"><div class="js-stockbutton" data-position="top" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h fa-lg"></span></a><ul class="dropdown-menu dropdown-menu-right"><li class="dropdown__item--mobile"><a href="/7shi/items/68228e19552c271bea81/revisions"><span class="fa fa-fw fa-history"></span> Revisions<span>(16)</span></a></li><li><a href="/7shi/items/68228e19552c271bea81.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><span class="fa fa-fw fa-flag"></span> Report article</a></li></ul></div></div></div></div></div><div class="container"><div class="row" id="article-body-wrapper"><div class="col-sm-9"><section class="markdownContent markdownContent-headingEnabled js-task-list-container clearfix position-relative" id="item-68228e19552c271bea81" itemprop="articleBody"><p>構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。</p>

<p>この記事は再帰下降構文解析の知識を前提とします。詳細は次の記事を参照してください。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/64261a67081d49f941e3" id="reference-867b6e79cf4d51a534a2">Java 再帰下降構文解析 超入門</a> 2016.05.16</li>
</ul>

<p>Javaには既存のパーサコンビネータがありますが、この記事では使用しません。</p>

<ul>
<li><a href="https://github.com/jparsec/jparsec" rel="nofollow noopener" target="_blank">jparsec</a></li>
<li><a href="https://github.com/jon-hanson/parsecj" rel="nofollow noopener" target="_blank">ParsecJ</a></li>
</ul>

<p>この記事ではHaskellのParsecを参考にしています。もちろんHaskellやモナドの知識は前提としません。それと断らずにモナドに由来する何かは出て来ますが、それが見抜けなくても問題ありません。興味があれば以下の記事を参照してください。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/b8c741e78a96ea2c10fe" id="reference-ef4d36436f6b8e2b21f8">Haskell 構文解析 超入門</a> 2015.07.31</li>
</ul>

<p>今回はラムダ式を多用するためJava 8以降を対象とします。ラムダ式なしで実装するとあまりにも冗長になり過ぎて、便利さよりも煩雑さが勝ってしまうためです。</p>

<p>この記事には続編があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142" id="reference-94326b9b1f8408d2ab67">Java パーサコンビネータ 超入門 2</a> 2016.05.14</li>
</ul>

<p>この記事にはC++版があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/6a12160276a8db358e34" id="reference-21cd06d3fac30fc2b771">C++11 パーサコンビネータ 超入門</a> 2015.11.27</li>
<li>
<a href="http://qiita.com/7shi/items/f86f2f7ad68cfff1b399" id="reference-a31ecad02606e35247ef">C++11 パーサコンビネータ 超入門 2</a> 2015.11.30</li>
</ul>

<p>この記事には関連記事があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/04c2991239894687ef2f" id="reference-a696e9c462d4629e145b">JSONパーサーを作る</a> 2016.12.26</li>
</ul>

<p>この記事を書くための実験用リポジトリです。記事化に際してコードに手を加えたため一部異なる場合があります。</p>

<ul>
<li><a href="https://bitbucket.org/7shi/jmyparsec" class="autolink" rel="nofollow noopener" target="_blank">https://bitbucket.org/7shi/jmyparsec</a></li>
</ul>

<h1>
<span id="コンセプト" class="fragment"></span><a href="#%E3%82%B3%E3%83%B3%E3%82%BB%E3%83%97%E3%83%88"><i class="fa fa-link"></i></a>コンセプト</h1>

<p>パーサコンビネータは、単純な部品（パーサ）の組み合わせ（コンビネーション）で構文を解析します。</p>

<p>文字列からアルファベットと数字を分離する例です。使用している<code>jmyparsec</code>パッケージはこの記事で1から作ります。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc123"</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s1a</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s1b</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">digit</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1a</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">s1b</span><span class="o">);</span>

        <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abcde9"</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s2a</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s2b</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">digit</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2a</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">s2b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc,123
abcde,9
</pre></div>
</div>

<p>このコードの読み方を説明します。</p>

<ol>
<li>処理対象の文字列<code>"abc123"</code>を<code>s1</code>に代入</li>
<li>
<code>s1</code>から、連続（<code>many</code>）するアルファベット（<code>alpha</code>）を取り出して<code>s1a</code>に代入</li>
<li>
<code>s1</code>の後続の文字列から、連続（<code>many</code>）する数字（<code>digit</code>）を取り出して<code>s1b</code>に代入</li>
<li>
<code>s1a</code>と<code>s1b</code>の中身を確認</li>
<li>別の文字列を同様に処理</li>
</ol>

<p><code>alpha</code>や<code>digit</code>は1文字だけを読み込むパーサです。それらを<code>many</code>というコンビネータと組み合わせることで、複数文字を処理する<code>many(alpha)</code>や<code>many(digit)</code>というパーサを作ります。</p>

<p>正規表現と似たようなものをコードで表現したとイメージすれば良いかもしれません。たとえば<code>many(digit)</code>は正規表現の<code>[0-9]*</code>に相当します。</p>

<table>
<thead>
<tr>
<th>コード</th>
<th>対応する正規表現</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>digit</code></td>
<td><code>[0-9]</code></td>
</tr>
<tr>
<td><code>many</code></td>
<td><code>*</code></td>
</tr>
<tr>
<td><code>many(digit)</code></td>
<td><code>[0-9]*</code></td>
</tr>
</tbody>
</table>

<p>これだけ見ると正規表現の方が簡潔ですが、コードで表現することで複雑なパターンにも対応しやすいという強みがあります。</p>

<p><code>s1</code>や<code>s2</code>は処理するたびに文字を読み進めます。現在位置に関して変更（副作用）があります。</p>

<p>※ この辺の設計は副作用を排除したHaskellのParsecとは異なりますが、Javaで実装しやすくするためのアレンジです。Haskellと完全に同じものをJavaで実装したわけではありません。</p>

<h1>
<span id="基礎編" class="fragment"></span><a href="#%E5%9F%BA%E7%A4%8E%E7%B7%A8"><i class="fa fa-link"></i></a>基礎編</h1>

<p>簡単な所から少しずつパーサコンビネータを作り始めます。</p>

<h2>
<span id="1文字取得" class="fragment"></span><a href="#1%E6%96%87%E5%AD%97%E5%8F%96%E5%BE%97"><i class="fa fa-link"></i></a>1文字取得</h2>

<p>指定した文字列から先頭の1文字を取得します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">char</span> <span class="nf">anyChar</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyChar</span><span class="o">(</span><span class="s">"abc"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
</pre></div>
</div>

<p><code>anyChar</code>が最初のパーサです。</p>

<h3>
<span id="連続呼び出し" class="fragment"></span><a href="#%E9%80%A3%E7%B6%9A%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97"><i class="fa fa-link"></i></a>連続呼び出し</h3>

<p><code>anyChar</code>を連続呼び出しすることで複数文字を取得できるように拡張します。</p>

<p>現在位置を管理して読み取り後に1文字進めれば、次の呼び出しで次の文字が取得できます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">char</span> <span class="nf">anyChar</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pos</span><span class="o">);</span>
        <span class="o">++</span><span class="n">pos</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
b
</pre></div>
</div>

<p><code>anyChar</code>を2回繰り返すことで、先頭から2文字取得しています。</p>

<h2>
<span id="クラス化" class="fragment"></span><a href="#%E3%82%AF%E3%83%A9%E3%82%B9%E5%8C%96"><i class="fa fa-link"></i></a>クラス化</h2>

<p>文字と位置をペアで管理するため、クラス化します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Source.java</span></div>
<div class="highlight"><pre>
<span class="kn">package</span> <span class="n">jmyparsec</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Source</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Source</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">char</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pos</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">++</span><span class="n">pos</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p><code>Source</code>を使って書き直します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">char</span> <span class="nf">anyChar</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
b
</pre></div>
</div>

<p><code>anyChar</code>を<code>Source</code>のインスタンスメソッドにすれば良いと思われたかもしれません。詳細は後で見て行きますが、パーサコンビネータでは利用者が目的に特化したパーサをその都度定義するスタイルのため、<code>Source</code>の外で定義しておいた方が都合が良いのです。</p>

<h2>
<span id="メソッド化" class="fragment"></span><a href="#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%8C%96"><i class="fa fa-link"></i></a>メソッド化</h2>

<p>2文字取得する部分をメソッド化します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">char</span> <span class="nf">anyChar</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="n">String</span> <span class="nf">test1</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// メソッド化</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">});</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test1</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
bc
</pre></div>
</div>

<p><code>test1</code>は<code>anyChar</code>を組み合わせて作られていますが、利用側からは<code>anyChar</code>と<code>test1</code>が同じように扱えるのがポイントです。ただし戻り値の型が異なるのには注意が必要です。</p>

<h3>
<span id="組み合わせ" class="fragment"></span><a href="#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B"><i class="fa fa-link"></i></a>組み合わせ</h3>

<p><code>test1</code>は、別の箇所で<code>anyChar</code>と組み合わせて利用できます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">char</span> <span class="nf">anyChar</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="n">String</span> <span class="nf">test1</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">});</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="n">String</span> <span class="nf">test2</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 追加</span>
        <span class="n">String</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyChar</span><span class="o">(</span><span class="n">s1</span><span class="o">));</span>
        <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test1</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>
        <span class="n">Source</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test2</span><span class="o">(</span><span class="n">s3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
</pre></div>
</div>

<p><code>test1</code>は<code>anyChar</code>を2つ組み合わせて作ったパーサです。<code>test2</code>は<code>test1</code>と<code>anyChar</code>を組み合わせて作ったパーサです。このように簡単なパーサを組み合わせて複雑なパーサを作っていくのが、パーサコンビネータの基本的な考え方です。</p>

<p><code>main</code>の中で<code>anyChar</code>と<code>test1</code>と<code>test2</code>が同列に並んでいますが、どれもパーサとして同じような位置付けだと見立ててください。</p>

<h2>
<span id="テストメソッド" class="fragment"></span><a href="#%E3%83%86%E3%82%B9%E3%83%88%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89"><i class="fa fa-link"></i></a>テストメソッド</h2>

<p><code>main()</code>でのテストが煩雑になって来たので、テスト用のメソッド<code>parseTest</code>を作成します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">parseTest</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Source</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="n">String</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 追加</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">char</span> <span class="nf">anyChar</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="n">String</span> <span class="nf">test1</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">});</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="n">String</span> <span class="nf">test2</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">anyChar</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">test1</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">test2</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
</pre></div>
</div>

<p><code>parseTest</code>にはパーサのメソッド（<code>anyChar</code>など）を渡しますが、異なる戻り値を受け付けるようにジェネリクスを用いています。メソッドを引数として渡すには<code>Test::</code>が必要です。</p>

<h3>
<span id="関数型インターフェース" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E5%9E%8B%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9"><i class="fa fa-link"></i></a>関数型インターフェース</h3>

<p><code>Function&lt;Source, T&gt;</code>の<code>Source</code>は共通で、省略するため専用の関数型インターフェースを定義します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parser.java</span></div>
<div class="highlight"><pre>
<span class="kn">package</span> <span class="n">jmyparsec</span><span class="o">;</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="n">T</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parseTest</span><span class="o">(</span><span class="n">Parser</span> <span class="n">p</span><span class="o">,</span> <span class="n">String</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 使用箇所</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">char</span> <span class="nf">anyChar</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="n">String</span> <span class="nf">test1</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">});</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="n">String</span> <span class="nf">test2</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">anyChar</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">test1</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">test2</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
</pre></div>
</div>

<h3>
<span id="ラムダ式化" class="fragment"></span><a href="#%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F%E5%8C%96"><i class="fa fa-link"></i></a>ラムダ式化</h3>

<p><code>Test::</code>が冗長です。これを省略可能にするためパーサをラムダ式化します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parseTest</span><span class="o">(</span><span class="n">Parser</span> <span class="n">p</span><span class="o">,</span> <span class="n">String</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>  <span class="c1">// ラムダ式化</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">};</span>                                               <span class="c1">// セミコロン</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>       <span class="c1">// ラムダ式化</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>                  <span class="c1">// .parse</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>                  <span class="c1">// .parse</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">});</span>
    <span class="o">};</span>                                               <span class="c1">// セミコロン</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>       <span class="c1">// ラムダ式化</span>
        <span class="n">String</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>                  <span class="c1">// .parse</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>                  <span class="c1">// .parse</span>
        <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">;</span>
    <span class="o">};</span>                                               <span class="c1">// セミコロン</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">anyChar</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// 単純化</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test1</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>    <span class="c1">// 単純化</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test2</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>    <span class="c1">// 単純化</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
</pre></div>
</div>

<p>今度はパーサーの使用箇所で<code>.parse</code>が必要になりましたが、これは後で対策します。</p>

<h2>
<span id="例外" class="fragment"></span><a href="#%E4%BE%8B%E5%A4%96"><i class="fa fa-link"></i></a>例外</h2>

<p>文字列の末尾に達すると例外が発生します。理由を返すようにします。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Source.java</span></div>
<div class="highlight"><pre>
<span class="kn">package</span> <span class="n">jmyparsec</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Source</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Source</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">char</span> <span class="nf">peek</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>  <span class="c1">// 例外対応</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"too short"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pos</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">++</span><span class="n">pos</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parser.java</span></div>
<div class="highlight"><pre>
<span class="kn">package</span> <span class="n">jmyparsec</span><span class="o">;</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="n">T</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Source</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>  <span class="c1">// 例外対応</span>
<span class="o">}</span>
</pre></div>
</div>

<p><code>parseTest</code>で例外を処理します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parseTest</span><span class="o">(</span><span class="n">Parser</span> <span class="n">p</span><span class="o">,</span> <span class="n">String</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 例外処理</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">};</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">});</span>
    <span class="o">};</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">anyChar</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">;</span>
    <span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test2</span><span class="o">,</span> <span class="s">"12"</span><span class="o">);</span>  <span class="c1">// 文字数不足</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test2</span><span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
too short
123
</pre></div>
</div>

<h2>
<span id="条件取得" class="fragment"></span><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%96%E5%BE%97"><i class="fa fa-link"></i></a>条件取得</h2>

<p><code>anyChar</code>は無条件で文字を取得していましたが、条件が指定できる<code>satisfy</code>を追加します。引数で渡されたメソッドをキャプチャしたクロージャを返します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parseTest</span><span class="o">(</span><span class="n">Parser</span> <span class="n">p</span><span class="o">,</span> <span class="n">String</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">};</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="nf">satisfy</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 追加</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"not satisfy"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">ch</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">satisfy</span><span class="o">(</span><span class="nl">Character:</span><span class="o">:</span><span class="n">isDigit</span><span class="o">),</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">satisfy</span><span class="o">(</span><span class="nl">Character:</span><span class="o">:</span><span class="n">isDigit</span><span class="o">),</span> <span class="s">"123"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
1
</pre></div>
</div>

<p>今回の機能追加に直接関係ない<code>test1</code>と<code>test2</code>は削除しました。</p>

<h3>
<span id="共通化" class="fragment"></span><a href="#%E5%85%B1%E9%80%9A%E5%8C%96"><i class="fa fa-link"></i></a>共通化</h3>

<p><code>anyChar</code>と<code>satisfy</code>で処理が重複しています。<code>anyChar</code>は無条件の<code>satisfy</code>として定義することで共通化を図ります。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parseTest</span><span class="o">(</span><span class="n">Parser</span> <span class="n">p</span><span class="o">,</span> <span class="n">String</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kc">true</span><span class="o">);</span>  <span class="c1">// 変更</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="nf">satisfy</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"not satisfy"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">ch</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">anyChar</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
</pre></div>
</div>

<p><code>anyChar</code>はラムダ式で定義したため1行で済んでいるのがポイントです。</p>

<h2>
<span id="ファイル分割" class="fragment"></span><a href="#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2"><i class="fa fa-link"></i></a>ファイル分割</h2>

<p>コードが長くなって来たため、汎用部分を別ファイルに分離します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java</span></div>
<div class="highlight"><pre>
<span class="kn">package</span> <span class="n">jmyparsec</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parsers</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parseTest</span><span class="o">(</span><span class="n">Parser</span> <span class="n">p</span><span class="o">,</span> <span class="n">String</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">anyChar</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kc">true</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="nf">satisfy</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"not satisfy"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">ch</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>簡単のため<code>import static</code>して使います。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">anyChar</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
</pre></div>
</div>

<h2>
<span id="文字判定" class="fragment"></span><a href="#%E6%96%87%E5%AD%97%E5%88%A4%E5%AE%9A"><i class="fa fa-link"></i></a>文字判定</h2>

<p>文字を指定して判定するパーサを実装します。Parsecでは<code>char</code>ですが、型と被るため<code>char1</code>に名前を変更します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="nf">char1</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">satisfy</span><span class="o">(</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">==</span> <span class="n">ch</span><span class="o">);</span>
    <span class="o">}</span>
</pre></div>
</div>

<p><code>char1</code>は引数<code>ch</code>をキャプチャしたクロージャを返しているのがポイントです。今後このようなパターンがよく出て来ます。</p>

<p>動作を確認します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">),</span> <span class="s">"abc"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">),</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
not satisfy
</pre></div>
</div>

<h2>
<span id="事前定義" class="fragment"></span><a href="#%E4%BA%8B%E5%89%8D%E5%AE%9A%E7%BE%A9"><i class="fa fa-link"></i></a>事前定義</h2>

<p><code>satisfy</code>で条件を指定するのは冗長なので、よく使うパターンを事前定義します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isAlphaNum</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Character</span><span class="o">.</span><span class="na">isAlphabetic</span><span class="o">(</span><span class="n">ch</span><span class="o">)</span> <span class="o">||</span> <span class="n">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">digit</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="nl">Character:</span><span class="o">:</span><span class="n">isDigit</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="nl">Character:</span><span class="o">:</span><span class="n">isUpperCase</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="nl">Character:</span><span class="o">:</span><span class="n">isLowerCase</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="nl">Character:</span><span class="o">:</span><span class="n">isAlphabetic</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">alphaNum</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="nl">Parsers:</span><span class="o">:</span><span class="n">isAlphaNum</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">letter</span> <span class="o">=</span> <span class="n">satisfy</span><span class="o">(</span><span class="nl">Character:</span><span class="o">:</span><span class="n">isLetter</span><span class="o">);</span>
</pre></div>
</div>

<p>動作を確認します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">digit</span> <span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">digit</span> <span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
1
a
not satisfy
</pre></div>
</div>

<h2>
<span id="組み合わせ判定" class="fragment"></span><a href="#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E5%88%A4%E5%AE%9A"><i class="fa fa-link"></i></a>組み合わせ判定</h2>

<p>先ほど追加したパーサを組み合わせて、先頭から「アルファベット」「数字」「数字」という組み合わせを判定するパーサを作ります。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">letter</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">digit</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">x3</span> <span class="o">=</span> <span class="n">digit</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">,</span> <span class="n">x3</span><span class="o">});</span>
    <span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"a23"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"a234"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
not satisfy
a23
a23
</pre></div>
</div>

<p><code>main()</code>から見ると、同じクラスに定義されているパーサ（<code>anyChar</code>など）と<code>jmyparsec.Parsers</code>に定義されているパーサ（<code>test3</code>）が、クラス名修飾なしに同列に使えています。これが<code>anyChar</code>を<code>Source</code>のインスタンスメソッドにしなかった理由です。</p>

<h2>
<span id="コンビネータの定義" class="fragment"></span><a href="#%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%AE%E5%AE%9A%E7%BE%A9"><i class="fa fa-link"></i></a>コンビネータの定義</h2>

<p>パーサ同士を組み合わせて新しいパーサを作り出すメソッドを<strong>コンビネータ</strong>と呼びます。</p>

<p>いくつか便利なコンビネータを定義します。</p>

<h3>
<span id="結合" class="fragment"></span><a href="#%E7%B5%90%E5%90%88"><i class="fa fa-link"></i></a>結合</h3>

<p>パーサを結合するコンビネータ<code>sequence</code>を定義してParsers.javaに追加します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">sequence</span><span class="o">(</span><span class="n">Parser</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Parser</span> <span class="n">arg</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arg</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">};</span>
    <span class="o">}</span>
</pre></div>
</div>

<p><code>test3</code>がとても簡単になります。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">digit</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"a23"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"a234"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
not satisfy
a23
a23
</pre></div>
</div>

<p>処理が関数を定義しなくても組み合わせで表現されています。この感覚がつかめれば、パーサコンビネータが見えて来ます。</p>

<p>※ 前の方で述べた<code>.parse</code>を回避するための対策がこれです。</p>

<h3>
<span id="繰り返し" class="fragment"></span><a href="#%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97"><i class="fa fa-link"></i></a>繰り返し</h3>

<p>同じパーサを指定回数繰り返すコンビネータ<code>replicate</code>を定義します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">replicate</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Parser</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">};</span>
    <span class="o">}</span>
</pre></div>
</div>

<p><code>test3</code>で使ってみます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">replicate</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">digit</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"a23"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span><span class="o">,</span> <span class="s">"a234"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
not satisfy
not satisfy
a23
a23
</pre></div>
</div>

<p>2回の繰り返しではあまり嬉しくありませんが、回数が増えれば楽になります。</p>

<h2>
<span id="many" class="fragment"></span><a href="#many"><i class="fa fa-link"></i></a>many</h2>

<p>繰り返しに関連して、最初のコンセプトで出て来た<code>many</code>を実装してみます。</p>

<p><code>many</code>は指定したパーサを0回以上適用して返すコンビネータです。エラーになるまで読み進めれば実装できます。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">many</span><span class="o">(</span><span class="n">Parser</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">};</span>
    <span class="o">}</span>
</pre></div>
</div>

<p>先頭からアルファベットだけを抜き出してみます。1文字も一致しなくても、エラーにはならずに空文字列が返ります。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test4</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test4</span><span class="o">,</span> <span class="s">"abc123"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test4</span><span class="o">,</span> <span class="s">"123abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc
     ← 空行
</pre></div>
</div>

<p>最初に出て来たサンプルも動きます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc123"</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s1a</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s1b</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">digit</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1a</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">s1b</span><span class="o">);</span>

        <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abcde9"</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s2a</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s2b</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">digit</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2a</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">s2b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc,123
abcde,9
</pre></div>
</div>

<h2>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h2>

<p>ここまでがパーサコンビネータの動作原理を理解するために最低限必要な実装です。</p>

<p>このセクションで登場したテストを1つにまとめます。</p>

<ul>
<li><a href="https://bitbucket.org/7shi/jmyparsec/src/0388bbfbf90b0215f640430e6bc48833d3e2c24f/src/jmyparsec/?at=default" rel="nofollow noopener" target="_blank">ここまでの jmyparsec</a></li>
</ul>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">anyChar</span><span class="o">,</span> <span class="n">anyChar</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">test1</span><span class="o">,</span> <span class="n">anyChar</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">replicate</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">digit</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test4</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">anyChar</span>   <span class="o">,</span> <span class="s">"abc"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test1</span>     <span class="o">,</span> <span class="s">"abc"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test2</span>     <span class="o">,</span> <span class="s">"abc"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test2</span>     <span class="o">,</span> <span class="s">"12"</span>    <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test2</span>     <span class="o">,</span> <span class="s">"123"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">),</span> <span class="s">"abc"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">),</span> <span class="s">"123"</span>   <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">digit</span>     <span class="o">,</span> <span class="s">"abc"</span>   <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">digit</span>     <span class="o">,</span> <span class="s">"123"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">letter</span>    <span class="o">,</span> <span class="s">"abc"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">letter</span>    <span class="o">,</span> <span class="s">"123"</span>   <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span>     <span class="o">,</span> <span class="s">"abc"</span>   <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span>     <span class="o">,</span> <span class="s">"123"</span>   <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span>     <span class="o">,</span> <span class="s">"a23"</span>   <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span>     <span class="o">,</span> <span class="s">"a234"</span>  <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test4</span>     <span class="o">,</span> <span class="s">"abc123"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test4</span>     <span class="o">,</span> <span class="s">"123abc"</span><span class="o">);</span>

        <span class="n">Source</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abc123"</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s1a</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s1b</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">digit</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1a</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">s1b</span><span class="o">);</span>

        <span class="n">Source</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="s">"abcde9"</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s2a</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">alpha</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s2b</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">digit</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2a</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">s2b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
ab
abc
too short
123
a
not satisfy
not satisfy
1
a
not satisfy
not satisfy
not satisfy
a23
a23
abc

abc,123
abcde,9
</pre></div>
</div>

<p>最初にコンセプトで提示したコードを見たときはモヤっとしていた部分も、少しはすっきりしたでしょうか。</p>

<h1>
<span id="選択" class="fragment"></span><a href="#%E9%81%B8%E6%8A%9E"><i class="fa fa-link"></i></a>選択</h1>

<p>非常によく使うのが選択のコンビネータです。</p>

<p>便利なだけでなく、色々と悩ましい問題があるのを見ていきます。</p>

<h2>
<span id="単純な実装" class="fragment"></span><a href="#%E5%8D%98%E7%B4%94%E3%81%AA%E5%AE%9F%E8%A3%85"><i class="fa fa-link"></i></a>単純な実装</h2>

<p>「または」を表現するコンビネータ<code>or</code>を実装します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">or</span><span class="o">(</span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">T</span> <span class="n">ret</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>
</pre></div>
</div>

<p><code>or</code>を使えば「アルファベットまたは数字」のような選択的なパーサが構築できます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">test5</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test5</span><span class="o">,</span> <span class="s">"a"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test5</span><span class="o">,</span> <span class="s">"1"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test5</span><span class="o">,</span> <span class="s">"!"</span><span class="o">);</span>  <span class="c1">// NG</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
1
not satisfy
</pre></div>
</div>

<h3>
<span id="manyとの組み合わせ" class="fragment"></span><a href="#many%E3%81%A8%E3%81%AE%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B"><i class="fa fa-link"></i></a>manyとの組み合わせ</h3>

<p>選択的パーサを<code>many</code>で繰り返すこともできます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test6</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">or</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">digit</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test6</span><span class="o">,</span> <span class="s">"abc123"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test6</span><span class="o">,</span> <span class="s">"123abc"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
abc123
123abc
</pre></div>
</div>

<h2>
<span id="結合と選択" class="fragment"></span><a href="#%E7%B5%90%E5%90%88%E3%81%A8%E9%81%B8%E6%8A%9E"><i class="fa fa-link"></i></a>結合と選択</h2>

<p><code>or</code>を少し使ってみると、直感に反した動きに気付きます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test7</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span><span class="o">,</span> <span class="s">"cb"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span><span class="o">,</span> <span class="s">"acb"</span><span class="o">);</span>  <span class="c1">// ???</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
cb
cb
</pre></div>
</div>

<p><code>test7</code>を素直に見ると「<code>"ab"</code>または<code>"cb"</code>」となり、確かにその両方にマッチします。しかし<code>"acb"</code>にもマッチしてしまいます。これは<code>or</code>に達する前に<code>'a'</code>だけは読み進めてしまったため、<code>or</code>の後のパターンにマッチしてしまうためです。</p>

<h2>
<span id="エラー化" class="fragment"></span><a href="#%E3%82%A8%E3%83%A9%E3%83%BC%E5%8C%96"><i class="fa fa-link"></i></a>エラー化</h2>

<p>このようなケースはParsecではエラーになります。</p>

<p><code>or(左, 右)</code>として、左のパーサが内部で複数のパーサから構成されるとき、そのうち1つでも成功してその後で失敗したなら、右のパーサは処理されずにエラーになるという仕様です。</p>

<p>これを実装するため、パーサの状態を保持・比較できるように修正します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Source.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Source</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Source</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">ret</span><span class="o">.</span><span class="na">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="n">Source</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">Source</span> <span class="n">src</span> <span class="o">=</span> <span class="o">(</span><span class="n">Source</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">src</span><span class="o">.</span><span class="na">s</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">src</span><span class="o">.</span><span class="na">pos</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
</div>

<p>最初の状態を保持しておいて、<code>or</code>の前で読み進めていれば例外を再送します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（修正）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">or</span><span class="o">(</span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">T</span> <span class="n">ret</span><span class="o">;</span>
            <span class="n">Source</span> <span class="n">bak</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>    <span class="c1">// 追加</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">bak</span><span class="o">))</span> <span class="o">{</span>  <span class="c1">// 追加</span>
                    <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>
</pre></div>
</div>

<p>先ほどと同じコードを試すと、最後がエラーになります。Parsecと同じで意図した動きです。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test7</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span><span class="o">,</span> <span class="s">"cb"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span><span class="o">,</span> <span class="s">"acb"</span><span class="o">);</span>  <span class="c1">// ???</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
cb
not satisfy
</pre></div>
</div>

<h2>
<span id="共通部分" class="fragment"></span><a href="#%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86"><i class="fa fa-link"></i></a>共通部分</h2>

<p>選択肢の先頭に共通部分があった場合、意図せずエラーになることがあります。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span><span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>  <span class="c1">// NG</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
</pre></div>
</div>

<p>このようなケースでは、共通部分を括り出すことで対処できます。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test9</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">or</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span><span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test9</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test9</span><span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
ab
ac
</pre></div>
</div>

<p>別の方法として状態を巻き戻す方法もあります。</p>

<h2>
<span id="バックトラック" class="fragment"></span><a href="#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>バックトラック</h2>

<p>パースに失敗したとき、状態を巻き戻して別の方法でパースをやり直すことを<strong>バックトラック</strong>と呼びます。</p>

<h3>
<span id="tryp" class="fragment"></span><a href="#tryp"><i class="fa fa-link"></i></a>tryp</h3>

<p>Parsecでバックトラックするには対象となるパーサを<code>try</code>で囲みます。例外処理の<code>try</code>と名前が被るため、ここでは<code>tryp</code>に名前を変更します。（<code>p</code>はParserの頭文字です）</p>

<p><code>Source</code>の状態を元に戻せるようにします。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Source.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">revert</span><span class="o">(</span><span class="n">Source</span> <span class="n">src</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">src</span><span class="o">.</span><span class="na">s</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"can not revert"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="na">pos</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
</div>

<p><code>tryp</code>の中で失敗すれば元の状態に戻してから例外を再送します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">tryp</span><span class="o">(</span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">T</span> <span class="n">ret</span><span class="o">;</span>
            <span class="n">Source</span> <span class="n">bak</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">s</span><span class="o">.</span><span class="na">revert</span><span class="o">(</span><span class="n">bak</span><span class="o">);</span>
                <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>
</pre></div>
</div>

<p><code>or</code>の左側を<code>tryp</code>で囲めば、失敗してもバックトラックしてから右側が処理されます。</p>

<p>先ほどの<code>test8</code>と<code>test9</code>と挙動を比較します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test9</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">or</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test10</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">tryp</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span> <span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span> <span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test9</span> <span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test9</span> <span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test10</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test10</span><span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
ab
ac
ab
ac
</pre></div>
</div>

<p><code>test9</code>と<code>test10</code>は同じ動きです。</p>

<h2>
<span id="string" class="fragment"></span><a href="#string"><i class="fa fa-link"></i></a>string</h2>

<p>1文字ずつ<code>char1</code>でパースすると面倒なため、文字列で指定できる<code>string</code>を実装します。</p>

<div class="code-frame" data-lang="java">
<div class="code-lang"><span class="bold">jmyparsec/Parsers.java（追加）</span></div>
<div class="highlight"><pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">string</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">char1</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)).</span><span class="na">parse</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>
</pre></div>
</div>

<p>内部では1文字ずつ処理されているため、途中の失敗をバックトラックするには<code>tryp</code>が必要です。</p>

<p>挙動を確認します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test11</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">string</span><span class="o">(</span><span class="s">"ab"</span><span class="o">),</span> <span class="n">string</span><span class="o">(</span><span class="s">"ac"</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test12</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">tryp</span><span class="o">(</span><span class="n">string</span><span class="o">(</span><span class="s">"ab"</span><span class="o">)),</span> <span class="n">string</span><span class="o">(</span><span class="s">"ac"</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test11</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test11</span><span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test12</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test12</span><span class="o">,</span> <span class="s">"ac"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
ab
not satisfy
ab
ac
</pre></div>
</div>

<h2>
<span id="まとめ-1" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81-1"><i class="fa fa-link"></i></a>まとめ</h2>

<p>このセクションで登場したテストを1つにまとめます。</p>

<ul>
<li><a href="https://bitbucket.org/7shi/jmyparsec/src/454a73cd1cc091adc37ae7212ce71a7e97b42733/src/jmyparsec/?at=default" rel="nofollow noopener" target="_blank">ここまでの jmyparsec</a></li>
</ul>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">test5</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test6</span> <span class="o">=</span> <span class="n">many</span><span class="o">(</span><span class="n">or</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">digit</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test7</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test9</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">or</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test10</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">tryp</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test11</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">string</span><span class="o">(</span><span class="s">"ab"</span><span class="o">),</span> <span class="n">string</span><span class="o">(</span><span class="s">"ac"</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test12</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">tryp</span><span class="o">(</span><span class="n">string</span><span class="o">(</span><span class="s">"ab"</span><span class="o">)),</span> <span class="n">string</span><span class="o">(</span><span class="s">"ac"</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test5</span> <span class="o">,</span> <span class="s">"a"</span>     <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test5</span> <span class="o">,</span> <span class="s">"1"</span>     <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test5</span> <span class="o">,</span> <span class="s">"!"</span>     <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test6</span> <span class="o">,</span> <span class="s">"abc123"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test6</span> <span class="o">,</span> <span class="s">"123abc"</span><span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span> <span class="o">,</span> <span class="s">"ab"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span> <span class="o">,</span> <span class="s">"cb"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span> <span class="o">,</span> <span class="s">"acb"</span>   <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span> <span class="o">,</span> <span class="s">"ab"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span> <span class="o">,</span> <span class="s">"ac"</span>    <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test9</span> <span class="o">,</span> <span class="s">"ab"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test9</span> <span class="o">,</span> <span class="s">"ac"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test10</span><span class="o">,</span> <span class="s">"ab"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test10</span><span class="o">,</span> <span class="s">"ac"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test11</span><span class="o">,</span> <span class="s">"ab"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test11</span><span class="o">,</span> <span class="s">"ac"</span>    <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test12</span><span class="o">,</span> <span class="s">"ab"</span>    <span class="o">);</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test12</span><span class="o">,</span> <span class="s">"ac"</span>    <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
a
1
not satisfy
abc123
123abc
ab
cb
not satisfy
ab
not satisfy
ab
ac
ab
ac
ab
not satisfy
ab
ac
</pre></div>
</div>

<h1>
<span id="エラー表示" class="fragment"></span><a href="#%E3%82%A8%E3%83%A9%E3%83%BC%E8%A1%A8%E7%A4%BA"><i class="fa fa-link"></i></a>エラー表示</h1>

<p>エラーが<code>too short</code>や<code>not satisfy</code>では分かりにくいので改善します。</p>

<p>このセクションは修正箇所が多いため差分と全体の両方を示します。</p>

<h2>
<span id="確認" class="fragment"></span><a href="#%E7%A2%BA%E8%AA%8D"><i class="fa fa-link"></i></a>確認</h2>

<p>エラーが出るものだけ抽出して確認します。</p>

<div class="code-frame" data-lang="java"><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">jmyparsec.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jmyparsec</span><span class="o">.</span><span class="na">Parsers</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">char1</span><span class="o">(</span><span class="sc">'c'</span><span class="o">);</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">anyChar</span><span class="o">,</span> <span class="n">anyChar</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">test1</span><span class="o">,</span> <span class="n">anyChar</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test3</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">replicate</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">digit</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">test5</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">letter</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test7</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">sequence</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">test11</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">string</span><span class="o">(</span><span class="s">"ab"</span><span class="o">),</span> <span class="n">string</span><span class="o">(</span><span class="s">"ac"</span><span class="o">));</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test2</span>     <span class="o">,</span> <span class="s">"12"</span> <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">char1</span><span class="o">(</span><span class="sc">'a'</span><span class="o">),</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">digit</span>     <span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">letter</span>    <span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span>     <span class="o">,</span> <span class="s">"abc"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test3</span>     <span class="o">,</span> <span class="s">"123"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test5</span>     <span class="o">,</span> <span class="s">"!"</span>  <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test7</span>     <span class="o">,</span> <span class="s">"acb"</span><span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test8</span>     <span class="o">,</span> <span class="s">"ac"</span> <span class="o">);</span>  <span class="c1">// NG</span>
        <span class="n">parseTest</span><span class="o">(</span><span class="n">test11</span>    <span class="o">,</span> <span class="s">"ac"</span> <span class="o">);</span>  <span class="c1">// NG</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
too short
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
</pre></div>
</div>

<h2>
<span id="位置" class="fragment"></span><a href="#%E4%BD%8D%E7%BD%AE"><i class="fa fa-link"></i></a>位置</h2>

<p><code>Source</code>に位置（行と桁）を保持してエラーメッセージに含めます。</p>

<p>差分を示します。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- jmyparsec/Source.java</span>
<span class="gi">+++ jmyparsec/Source.java</span>
<span class="gu">@@ -3,10 +3,11 @@</span>
 public class Source {

     private final String s;
<span class="gd">-    private int pos;</span>
<span class="gi">+    private int pos, line, col;</span>

     public Source(String s) {
         this.s = s;
<span class="gi">+        line = col = 1;</span>
     }

     @Override
<span class="gu">@@ -27,19 +28,29 @@</span>

     public final char peek() throws Exception {
         if (pos &gt;= s.length()) {
<span class="gd">-            throw new Exception("too short");</span>
<span class="gi">+            throw new Exception(ex("too short"));</span>
         }
         return s.charAt(pos);
     }

<span class="gd">-    public final void next() {</span>
<span class="gi">+    public final void next() throws Exception {</span>
<span class="gi">+        char ch = peek();</span>
<span class="gi">+        if (ch == '\n') {</span>
<span class="gi">+            ++line;</span>
<span class="gi">+            col = 0;</span>
<span class="gi">+        }</span>
         ++pos;
<span class="gi">+        ++col;</span>
     }

     public final void revert(Source src) throws Exception {
         if (!s.equals(src.s)) {
<span class="gd">-            throw new Exception("can not revert");</span>
<span class="gi">+            throw new Exception(ex("can not revert"));</span>
         }
         pos = src.pos;
     }
<span class="gi">+</span>
<span class="gi">+    public final String ex(String e) {</span>
<span class="gi">+        return "[line " + line + ",col " + col + "] " + e;</span>
<span class="gi">+    }</span>
 }
</pre></div></div>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- jmyparsec/Parsers.java</span>
<span class="gi">+++ jmyparsec/Parsers.java</span>
<span class="gu">@@ -19,7 +19,7 @@</span>
         return s -&gt; {
             char ch = s.peek();
             if (!f.apply(ch)) {
<span class="gd">-                throw new Exception("not satisfy");</span>
<span class="gi">+                throw new Exception(s.ex("not satisfy"));</span>
             }
             s.next();
             return ch;
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/7shi/jmyparsec/src/6dc1b2bab6fed81d3399729c4e11f112b9a468f5/src/jmyparsec/?at=default" rel="nofollow noopener" target="_blank">修正後の jmyparsec</a></li>
</ul>

<p>先ほどと同じコードをテストして、エラーの変化を確認します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[line 1, col 3] too short
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
</pre></div>
</div>

<p>どこでエラーが発生したか分かるようになりました。</p>

<h2>
<span id="対象の文字" class="fragment"></span><a href="#%E5%AF%BE%E8%B1%A1%E3%81%AE%E6%96%87%E5%AD%97"><i class="fa fa-link"></i></a>対象の文字</h2>

<p>どの文字でエラーになったかをエラーメッセージに含めます。</p>

<p>差分を示します。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- jmyparsec/Source.java</span>
<span class="gi">+++ jmyparsec/Source.java</span>
<span class="gu">@@ -51,6 +51,10 @@</span>
     }

     public final String ex(String e) {
<span class="gd">-        return "[line " + line + ",col " + col + "] " + e;</span>
<span class="gi">+        String ret = "[line " + line + ",col " + col + "] " + e;</span>
<span class="gi">+        if (s != null &amp;&amp; 0 &lt;= pos &amp;&amp; pos &lt; s.length()) {</span>
<span class="gi">+            ret += ": '" + s.charAt(pos) + "'";</span>
<span class="gi">+        }</span>
<span class="gi">+        return ret;</span>
     }
 }
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/7shi/jmyparsec/src/b2c76cef6965c5110998726d2c953d161bce2ab5/src/jmyparsec/?at=default" rel="nofollow noopener" target="_blank">修正後の jmyparsec</a></li>
</ul>

<p>先ほどと同じコードをテストして、エラーの変化を確認します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[line 1, col 3] too short
[line 1, col 1] not satisfy: '1'
[line 1, col 1] not satisfy: 'a'
[line 1, col 1] not satisfy: '1'
[line 1, col 2] not satisfy: 'b'
[line 1, col 1] not satisfy: '1'
[line 1, col 1] not satisfy: '!'
[line 1, col 2] not satisfy: 'c'
[line 1, col 2] not satisfy: 'c'
[line 1, col 2] not satisfy: 'c'
</pre></div>
</div>

<p>どの文字でエラーになったのかが分かるようになりました。</p>

<h2>
<span id="失敗の確定" class="fragment"></span><a href="#%E5%A4%B1%E6%95%97%E3%81%AE%E7%A2%BA%E5%AE%9A"><i class="fa fa-link"></i></a>失敗の確定</h2>

<p>失敗を確定させて指定したメッセージで例外を発生させる<code>left</code>を実装します。</p>

<p>※ 英語でrightは「右」の他に「正しい」という意味がありますが、その反対を意図して<code>left</code>と命名されました。ある種の言葉遊びで、英語としての単語に「誤り」という意味があるわけではありません。</p>

<p><code>or</code>と<code>left</code>を組み合わせれば、エラーメッセージがカスタマイズできます。</p>

<p>差分を示します。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- jmyparsec/Parsers.java</span>
<span class="gi">+++ jmyparsec/Parsers.java</span>
<span class="gu">@@ -27,19 +27,19 @@</span>
     }

     public static final Parser&lt;Character&gt; char1(char ch) {
<span class="gd">-        return satisfy(c -&gt; c == ch);</span>
<span class="gi">+        return or(satisfy(c -&gt; c == ch), left("not char '" + ch + "'"));</span>
     }

     public static final boolean isAlphaNum(char ch) {
         return Character.isAlphabetic(ch) || Character.isDigit(ch);
     }

<span class="gd">-    public static final Parser&lt;Character&gt; digit = satisfy(Character::isDigit);</span>
<span class="gd">-    public static final Parser&lt;Character&gt; upper = satisfy(Character::isUpperCase);</span>
<span class="gd">-    public static final Parser&lt;Character&gt; lower = satisfy(Character::isLowerCase);</span>
<span class="gd">-    public static final Parser&lt;Character&gt; alpha = satisfy(Character::isAlphabetic);</span>
<span class="gd">-    public static final Parser&lt;Character&gt; alphaNum = satisfy(Parsers::isAlphaNum);</span>
<span class="gd">-    public static final Parser&lt;Character&gt; letter = satisfy(Character::isLetter);</span>
<span class="gi">+    public static final Parser&lt;Character&gt; digit    = or(satisfy(Character::isDigit)     , left("not digit"   ));</span>
<span class="gi">+    public static final Parser&lt;Character&gt; upper    = or(satisfy(Character::isUpperCase) , left("not upper"   ));</span>
<span class="gi">+    public static final Parser&lt;Character&gt; lower    = or(satisfy(Character::isLowerCase) , left("not lower"   ));</span>
<span class="gi">+    public static final Parser&lt;Character&gt; alpha    = or(satisfy(Character::isAlphabetic), left("not alpha"   ));</span>
<span class="gi">+    public static final Parser&lt;Character&gt; alphaNum = or(satisfy(Parsers  ::isAlphaNum)  , left("not alphaNum"));</span>
<span class="gi">+    public static final Parser&lt;Character&gt; letter   = or(satisfy(Character::isLetter)    , left("not letter"  ));</span>

     public static final Parser&lt;String&gt; sequence(Parser... args) {
         return s -&gt; {
<span class="gu">@@ -107,9 +107,15 @@</span>
     public static final Parser&lt;String&gt; string(String str) {
         return s -&gt; {
             for (int i = 0; i &lt; str.length(); ++i) {
<span class="gd">-                char1(str.charAt(i)).parse(s);</span>
<span class="gi">+                or(char1(str.charAt(i)), left("not string \"" + str + "\"")).parse(s);</span>
             }
             return str;
         };
     }
<span class="gi">+</span>
<span class="gi">+    public static final &lt;T&gt; Parser&lt;T&gt; left(String e) {</span>
<span class="gi">+        return s -&gt; {</span>
<span class="gi">+            throw new Exception(s.ex(e));</span>
<span class="gi">+        };</span>
<span class="gi">+    }</span>
 }
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/7shi/jmyparsec/src/5bb3e7d82f40f0c6389741d9927548c569a193f4/src/jmyparsec/?at=default" rel="nofollow noopener" target="_blank">修正後の jmyparsec</a></li>
</ul>

<p>先ほどと同じコードをテストして、エラーの変化を確認します。</p>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[line 1, col 3] too short
[line 1, col 1] not char 'a': '1'
[line 1, col 1] not digit: 'a'
[line 1, col 1] not letter: '1'
[line 1, col 2] not digit: 'b'
[line 1, col 1] not letter: '1'
[line 1, col 1] not digit: '!'
[line 1, col 2] not char 'b': 'c'
[line 1, col 2] not char 'b': 'c'
[line 1, col 2] not string "ab": 'c'
</pre></div>
</div>

<p>エラーの種類が分かるようになりました。説明用にはこれくらいで十分でしょう。</p>

<h2>
<span id="メソッドチェイン" class="fragment"></span><a href="#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%83%81%E3%82%A7%E3%82%A4%E3%83%B3"><i class="fa fa-link"></i></a>メソッドチェイン</h2>

<p><code>or</code>や<code>left</code>はよく使うので、<code>Parser</code>のデフォルトメソッドにします。こうすればメソッドチェインで書けるようになります。</p>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- jmyparsec/Parser.java</span>
<span class="gi">+++ jmyparsec/Parser.java</span>
<span class="gu">@@ -4,4 +4,26 @@</span>
 public interface Parser&lt;T&gt; {

     T parse(Source s) throws Exception;
<span class="gi">+</span>
<span class="gi">+    default Parser&lt;T&gt; or(Parser&lt;T&gt; p) {</span>
<span class="gi">+        return s -&gt; {</span>
<span class="gi">+            T ret;</span>
<span class="gi">+            Source bak = s.clone();</span>
<span class="gi">+            try {</span>
<span class="gi">+                ret = parse(s);</span>
<span class="gi">+            } catch (Exception e) {</span>
<span class="gi">+                if (!s.equals(bak)) {</span>
<span class="gi">+                    throw e;</span>
<span class="gi">+                }</span>
<span class="gi">+                ret = p.parse(s);</span>
<span class="gi">+            }</span>
<span class="gi">+            return ret;</span>
<span class="gi">+        };</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    default Parser&lt;T&gt; left(String e) {</span>
<span class="gi">+        return or(s -&gt; {</span>
<span class="gi">+            throw new Exception(s.ex(e));</span>
<span class="gi">+        });</span>
<span class="gi">+    }</span>
 }
</pre></div></div>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- jmyparsec/Parsers.java</span>
<span class="gi">+++ jmyparsec/Parsers.java</span>
<span class="gu">@@ -27,19 +27,19 @@</span>
     }

     public static final Parser&lt;Character&gt; char1(char ch) {
<span class="gd">-        return or(satisfy(c -&gt; c == ch), left("not char '" + ch + "'"));</span>
<span class="gi">+        return satisfy(c -&gt; c == ch).left("not char '" + ch + "'");</span>
     }

     public static final boolean isAlphaNum(char ch) {
         return Character.isAlphabetic(ch) || Character.isDigit(ch);
     }

<span class="gd">-    public static final Parser&lt;Character&gt; digit    = or(satisfy(Character::isDigit)     , left("not digit"   ));</span>
<span class="gd">-    public static final Parser&lt;Character&gt; upper    = or(satisfy(Character::isUpperCase) , left("not upper"   ));</span>
<span class="gd">-    public static final Parser&lt;Character&gt; lower    = or(satisfy(Character::isLowerCase) , left("not lower"   ));</span>
<span class="gd">-    public static final Parser&lt;Character&gt; alpha    = or(satisfy(Character::isAlphabetic), left("not alpha"   ));</span>
<span class="gd">-    public static final Parser&lt;Character&gt; alphaNum = or(satisfy(Parsers  ::isAlphaNum)  , left("not alphaNum"));</span>
<span class="gd">-    public static final Parser&lt;Character&gt; letter   = or(satisfy(Character::isLetter)    , left("not letter"  ));</span>
<span class="gi">+    public static final Parser&lt;Character&gt; digit    = satisfy(Character::isDigit     ).left("not digit"   );</span>
<span class="gi">+    public static final Parser&lt;Character&gt; upper    = satisfy(Character::isUpperCase ).left("not upper"   );</span>
<span class="gi">+    public static final Parser&lt;Character&gt; lower    = satisfy(Character::isLowerCase ).left("not lower"   );</span>
<span class="gi">+    public static final Parser&lt;Character&gt; alpha    = satisfy(Character::isAlphabetic).left("not alpha"   );</span>
<span class="gi">+    public static final Parser&lt;Character&gt; alphaNum = satisfy(Parsers  ::isAlphaNum  ).left("not alphaNum");</span>
<span class="gi">+    public static final Parser&lt;Character&gt; letter   = satisfy(Character::isLetter    ).left("not letter"  );</span>

     public static final Parser&lt;String&gt; sequence(Parser... args) {
         return s -&gt; {
<span class="gu">@@ -75,19 +75,7 @@</span>
     }

     public static final &lt;T&gt; Parser&lt;T&gt; or(Parser&lt;T&gt; p1, Parser&lt;T&gt; p2) {
<span class="gd">-        return s -&gt; {</span>
<span class="gd">-            T ret;</span>
<span class="gd">-            Source bak = s.clone();</span>
<span class="gd">-            try {</span>
<span class="gd">-                ret = p1.parse(s);</span>
<span class="gd">-            } catch (Exception e) {</span>
<span class="gd">-                if (!s.equals(bak)) {</span>
<span class="gd">-                    throw e;</span>
<span class="gd">-                }</span>
<span class="gd">-                ret = p2.parse(s);</span>
<span class="gd">-            }</span>
<span class="gd">-            return ret;</span>
<span class="gd">-        };</span>
<span class="gi">+        return p1.or(p2);</span>
     }

     public static final &lt;T&gt; Parser&lt;T&gt; tryp(Parser&lt;T&gt; p) {
<span class="gu">@@ -107,7 +95,7 @@</span>
     public static final Parser&lt;String&gt; string(String str) {
         return s -&gt; {
             for (int i = 0; i &lt; str.length(); ++i) {
<span class="gd">-                or(char1(str.charAt(i)), left("not string \"" + str + "\"")).parse(s);</span>
<span class="gi">+                char1(str.charAt(i)).left("not string \"" + str + "\"").parse(s);</span>
             }
             return str;
         };
</pre></div></div>

<div class="code-frame" data-lang="diff"><div class="highlight"><pre>
<span class="gd">--- Test.java</span>
<span class="gi">+++ Test.java</span>
<span class="gu">@@ -11,10 +11,10 @@</span>
     static final Parser&lt;String&gt; test1 = sequence(anyChar, anyChar);
     static final Parser&lt;String&gt; test2 = sequence(test1, anyChar);
     static final Parser&lt;String&gt; test3 = sequence(letter, replicate(2, digit));
<span class="gd">-    static final Parser&lt;Character&gt; test5 = or(letter, digit);</span>
<span class="gd">-    static final Parser&lt;String&gt; test7 = or(sequence(a, b), sequence(c, b));</span>
<span class="gd">-    static final Parser&lt;String&gt; test8 = or(sequence(a, b), sequence(a, c));</span>
<span class="gd">-    static final Parser&lt;String&gt; test11 = or(string("ab"), string("ac"));</span>
<span class="gi">+    static final Parser&lt;Character&gt; test5 = letter.or(digit);</span>
<span class="gi">+    static final Parser&lt;String&gt; test7 = sequence(a, b).or(sequence(c, b));</span>
<span class="gi">+    static final Parser&lt;String&gt; test8 = sequence(a, b).or(sequence(a, c));</span>
<span class="gi">+    static final Parser&lt;String&gt; test11 = string("ab").or(string("ac"));</span>

     public static void main(String[] args) {
         parseTest(test2     , "12" );  // NG
</pre></div></div>

<ul>
<li><a href="https://bitbucket.org/7shi/jmyparsec/src/e106ff602890e230ff5e002e06e3da7dcb87c862/src/jmyparsec/?at=default" rel="nofollow noopener" target="_blank">修正後の jmyparsec</a></li>
</ul>

<p>実行結果は同じなので省略します。</p>

<p>メソッドチェインを使うかどうかは好みにもよりますが、考え方を示しておきます。</p>

<ul>
<li>
<code>or(a, b)</code> より  <code>a.or(b)</code> の方が <code>a || b</code> の並べ方に近い。</li>
<li>
<code>a</code> に条件 <code>b</code> を付け足すとき、<code>or(a, b)</code>で全体を囲むより <code>a.or(b)</code> として付け足す方が書きやすい。</li>
</ul>

<h1>
<span id="おわりに" class="fragment"></span><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB"><i class="fa fa-link"></i></a>おわりに</h1>

<p>パーサコンビネータの動作イメージがつかめたでしょうか。</p>

<p>今回のようにテストだけではどう応用して良いのか分からないかもしれません。続編で四則演算器を作っているので、そちらも参考にしてください。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142">Java パーサコンビネータ 超入門 2</a> 2016.05.14</li>
</ul>
<div class="hidden"><form class="js-task-list-update" action="/7shi/items/68228e19552c271bea81" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="_method" value="patch" /><input type="hidden" name="authenticity_token" value="8IYHqZVnxCT1+sxpMLaLpiy5cCI0TdyVBQiBfvSgdumeBJzxDkn9bwopeXVAQzX/TP5UkaOJhmI51oiFFa54Lw==" /><input type="hidden" name="updated_at_confirmation_in_unixtime" id="updated_at_confirmation_in_unixtime" value="1482773575" class="js-task-list-updated-at" /><textarea name="raw_body" id="raw_body" class="js-task-list-field">
構文を解析するプログラムをパーサと呼びます。実装方法にはいくつか種類がありますが、今回はパーサコンビネータという方式を取り上げます。既存の実装を使うのではなく、1から実装しながら説明します。

この記事は再帰下降構文解析の知識を前提とします。詳細は次の記事を参照してください。

* [Java 再帰下降構文解析 超入門](http://qiita.com/7shi/items/64261a67081d49f941e3) 2016.05.16

Javaには既存のパーサコンビネータがありますが、この記事では使用しません。

* [jparsec](https://github.com/jparsec/jparsec)
* [ParsecJ](https://github.com/jon-hanson/parsecj)

この記事ではHaskellのParsecを参考にしています。もちろんHaskellやモナドの知識は前提としません。それと断らずにモナドに由来する何かは出て来ますが、それが見抜けなくても問題ありません。興味があれば以下の記事を参照してください。

* [Haskell 構文解析 超入門](http://qiita.com/7shi/items/b8c741e78a96ea2c10fe) 2015.07.31

今回はラムダ式を多用するためJava 8以降を対象とします。ラムダ式なしで実装するとあまりにも冗長になり過ぎて、便利さよりも煩雑さが勝ってしまうためです。

この記事には続編があります。

* [Java パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142) 2016.05.14

この記事にはC++版があります。

* [C++11 パーサコンビネータ 超入門](http://qiita.com/7shi/items/6a12160276a8db358e34) 2015.11.27
* [C++11 パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/f86f2f7ad68cfff1b399) 2015.11.30

この記事には関連記事があります。

* [JSONパーサーを作る](http://qiita.com/7shi/items/04c2991239894687ef2f) 2016.12.26

この記事を書くための実験用リポジトリです。記事化に際してコードに手を加えたため一部異なる場合があります。

* https://bitbucket.org/7shi/jmyparsec

# コンセプト

パーサコンビネータは、単純な部品（パーサ）の組み合わせ（コンビネーション）で構文を解析します。

文字列からアルファベットと数字を分離する例です。使用している`jmyparsec`パッケージはこの記事で1から作ります。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    public static void main(String[] args) throws Exception {
        Source s1 = new Source(&quot;abc123&quot;);
        String s1a = many(alpha).parse(s1);
        String s1b = many(digit).parse(s1);
        System.out.println(s1a + &quot;,&quot; + s1b);

        Source s2 = new Source(&quot;abcde9&quot;);
        String s2a = many(alpha).parse(s2);
        String s2b = many(digit).parse(s2);
        System.out.println(s2a + &quot;,&quot; + s2b);
    }
}
```
```text:実行結果
abc,123
abcde,9
```

このコードの読み方を説明します。

1. 処理対象の文字列`&quot;abc123&quot;`を`s1`に代入
2. `s1`から、連続（`many`）するアルファベット（`alpha`）を取り出して`s1a`に代入
3. `s1`の後続の文字列から、連続（`many`）する数字（`digit`）を取り出して`s1b`に代入
4. `s1a`と`s1b`の中身を確認
5. 別の文字列を同様に処理

`alpha`や`digit`は1文字だけを読み込むパーサです。それらを`many`というコンビネータと組み合わせることで、複数文字を処理する`many(alpha)`や`many(digit)`というパーサを作ります。

正規表現と似たようなものをコードで表現したとイメージすれば良いかもしれません。たとえば`many(digit)`は正規表現の`[0-9]*`に相当します。

コード       |対応する正規表現
-------------|----------------
`digit`      |`[0-9]`
`many`       |`*`
`many(digit)`|`[0-9]*`

これだけ見ると正規表現の方が簡潔ですが、コードで表現することで複雑なパターンにも対応しやすいという強みがあります。

`s1`や`s2`は処理するたびに文字を読み進めます。現在位置に関して変更（副作用）があります。

※ この辺の設計は副作用を排除したHaskellのParsecとは異なりますが、Javaで実装しやすくするためのアレンジです。Haskellと完全に同じものをJavaで実装したわけではありません。

# 基礎編

簡単な所から少しずつパーサコンビネータを作り始めます。

## 1文字取得

指定した文字列から先頭の1文字を取得します。

```java
public class Test {

    static char anyChar(String s) {
        return s.charAt(0);
    }

    public static void main(String[] args) {
        System.out.println(anyChar(&quot;abc&quot;));
    }
}
```
```text:実行結果
a
```

`anyChar`が最初のパーサです。

### 連続呼び出し

`anyChar`を連続呼び出しすることで複数文字を取得できるように拡張します。

現在位置を管理して読み取り後に1文字進めれば、次の呼び出しで次の文字が取得できます。

```java
public class Test {

    static int pos;

    static char anyChar(String s) {
        char ret = s.charAt(pos);
        ++pos;
        return ret;
    }

    public static void main(String[] args) {
        String s = &quot;abc&quot;;
        System.out.println(anyChar(s));
        System.out.println(anyChar(s));
    }
}
```
```text:実行結果
a
b
```

`anyChar`を2回繰り返すことで、先頭から2文字取得しています。

## クラス化

文字と位置をペアで管理するため、クラス化します。

```jmyparsec/Source.java
package jmyparsec;

public class Source {

    private final String s;
    private int pos;

    public Source(String s) {
        this.s = s;
    }

    public final char peek() {
        return s.charAt(pos);
    }

    public final void next() {
        ++pos;
    }
}
```

`Source`を使って書き直します。

```java
import jmyparsec.*;

public class Test {

    static char anyChar(Source s) {
        char ret = s.peek();
        s.next();
        return ret;
    }

    public static void main(String[] args) {
        Source s = new Source(&quot;abc&quot;);
        System.out.println(anyChar(s));
        System.out.println(anyChar(s));
    }
}
```
```text:実行結果
a
b
```

`anyChar`を`Source`のインスタンスメソッドにすれば良いと思われたかもしれません。詳細は後で見て行きますが、パーサコンビネータでは利用者が目的に特化したパーサをその都度定義するスタイルのため、`Source`の外で定義しておいた方が都合が良いのです。

## メソッド化

2文字取得する部分をメソッド化します。

```java
import jmyparsec.*;

public class Test {

    static char anyChar(Source s) {
        char ret = s.peek();
        s.next();
        return ret;
    }

    static String test1(Source s) {  // メソッド化
        char x1 = anyChar(s);
        char x2 = anyChar(s);
        return new String(new char[]{x1, x2});
    }

    public static void main(String[] args) {
        Source s = new Source(&quot;abc&quot;);
        System.out.println(anyChar(s));
        System.out.println(test1(s));
    }
}
```
```text:実行結果
a
bc
```

`test1`は`anyChar`を組み合わせて作られていますが、利用側からは`anyChar`と`test1`が同じように扱えるのがポイントです。ただし戻り値の型が異なるのには注意が必要です。

### 組み合わせ

`test1`は、別の箇所で`anyChar`と組み合わせて利用できます。

```java
import jmyparsec.*;

public class Test {

    static char anyChar(Source s) {
        char ret = s.peek();
        s.next();
        return ret;
    }

    static String test1(Source s) {
        char x1 = anyChar(s);
        char x2 = anyChar(s);
        return new String(new char[]{x1, x2});
    }

    static String test2(Source s) {  // 追加
        String x1 = test1(s);
        char x2 = anyChar(s);
        return x1 + x2;
    }

    public static void main(String[] args) {
        Source s1 = new Source(&quot;abc&quot;);
        System.out.println(anyChar(s1));
        Source s2 = new Source(&quot;abc&quot;);
        System.out.println(test1(s2));
        Source s3 = new Source(&quot;abc&quot;);
        System.out.println(test2(s3));
    }
}
```
```text:実行結果
a
ab
abc
```

`test1`は`anyChar`を2つ組み合わせて作ったパーサです。`test2`は`test1`と`anyChar`を組み合わせて作ったパーサです。このように簡単なパーサを組み合わせて複雑なパーサを作っていくのが、パーサコンビネータの基本的な考え方です。

`main`の中で`anyChar`と`test1`と`test2`が同列に並んでいますが、どれもパーサとして同じような位置付けだと見立ててください。

## テストメソッド

`main()`でのテストが煩雑になって来たので、テスト用のメソッド`parseTest`を作成します。

```java
import jmyparsec.*;
import java.util.function.Function;

public class Test {

    static &lt;T&gt; void parseTest(Function&lt;Source, T&gt; p, String src) {  // 追加
        Source s = new Source(src);
        System.out.println(p.apply(s));
    }

    static char anyChar(Source s) {
        char ret = s.peek();
        s.next();
        return ret;
    }

    static String test1(Source s) {
        char x1 = anyChar(s);
        char x2 = anyChar(s);
        return new String(new char[]{x1, x2});
    }

    static String test2(Source s) {
        String x1 = test1(s);
        char x2 = anyChar(s);
        return x1 + x2;
    }

    public static void main(String[] args) {
        parseTest(Test::anyChar, &quot;abc&quot;);
        parseTest(Test::test1, &quot;abc&quot;);
        parseTest(Test::test2, &quot;abc&quot;);
    }
}
```
```text:実行結果
a
ab
abc
```

`parseTest`にはパーサのメソッド（`anyChar`など）を渡しますが、異なる戻り値を受け付けるようにジェネリクスを用いています。メソッドを引数として渡すには`Test::`が必要です。

### 関数型インターフェース

`Function&lt;Source, T&gt;`の`Source`は共通で、省略するため専用の関数型インターフェースを定義します。

```jmyparsec/Parser.java
package jmyparsec;

@FunctionalInterface
public interface Parser&lt;T&gt; {

    T parse(Source s);
}
```

```java
import jmyparsec.*;

public class Test {

    static void parseTest(Parser p, String src) {  // 使用箇所
        Source s = new Source(src);
        System.out.println(p.parse(s));
    }

    static char anyChar(Source s) {
        char ret = s.peek();
        s.next();
        return ret;
    }

    static String test1(Source s) {
        char x1 = anyChar(s);
        char x2 = anyChar(s);
        return new String(new char[]{x1, x2});
    }

    static String test2(Source s) {
        String x1 = test1(s);
        char x2 = anyChar(s);
        return x1 + x2;
    }

    public static void main(String[] args) {
        parseTest(Test::anyChar, &quot;abc&quot;);
        parseTest(Test::test1, &quot;abc&quot;);
        parseTest(Test::test2, &quot;abc&quot;);
    }
}
```
```text:実行結果
a
ab
abc
```

### ラムダ式化

`Test::`が冗長です。これを省略可能にするためパーサをラムダ式化します。

```java
import jmyparsec.*;

public class Test {

    static void parseTest(Parser p, String src) {
        Source s = new Source(src);
        System.out.println(p.parse(s));
    }

    static final Parser&lt;Character&gt; anyChar = s -&gt; {  // ラムダ式化
        char ret = s.peek();
        s.next();
        return ret;
    };                                               // セミコロン

    static final Parser&lt;String&gt; test1 = s -&gt; {       // ラムダ式化
        char x1 = anyChar.parse(s);                  // .parse
        char x2 = anyChar.parse(s);                  // .parse
        return new String(new char[]{x1, x2});
    };                                               // セミコロン

    static final Parser&lt;String&gt; test2 = s -&gt; {       // ラムダ式化
        String x1 = test1.parse(s);                  // .parse
        char x2 = anyChar.parse(s);                  // .parse
        return x1 + x2;
    };                                               // セミコロン

    public static void main(String[] args) {
        parseTest(anyChar, &quot;abc&quot;);  // 単純化
        parseTest(test1, &quot;abc&quot;);    // 単純化
        parseTest(test2, &quot;abc&quot;);    // 単純化
    }
}
```
```text:実行結果
a
ab
abc
```

今度はパーサーの使用箇所で`.parse`が必要になりましたが、これは後で対策します。

## 例外

文字列の末尾に達すると例外が発生します。理由を返すようにします。

```jmyparsec/Source.java
package jmyparsec;

public class Source {

    private final String s;
    private int pos;

    public Source(String s) {
        this.s = s;
    }

    public final char peek() throws Exception {  // 例外対応
        if (pos &gt;= s.length()) {
            throw new Exception(&quot;too short&quot;);
        }
        return s.charAt(pos);
    }

    public final void next() {
        ++pos;
    }
}
```

```jmyparsec/Parser.java
package jmyparsec;

@FunctionalInterface
public interface Parser&lt;T&gt; {

    T parse(Source s) throws Exception;  // 例外対応
}
```

`parseTest`で例外を処理します。

```java
import jmyparsec.*;

public class Test {

    static void parseTest(Parser p, String src) {
        Source s = new Source(src);
        try {
            System.out.println(p.parse(s));
        } catch (Exception e) {  // 例外処理
            System.out.println(e.getMessage());
        }
    }

    static final Parser&lt;Character&gt; anyChar = s -&gt; {
        char ret = s.peek();
        s.next();
        return ret;
    };

    static final Parser&lt;String&gt; test1 = s -&gt; {
        char x1 = anyChar.parse(s);
        char x2 = anyChar.parse(s);
        return new String(new char[]{x1, x2});
    };

    static final Parser&lt;String&gt; test2 = s -&gt; {
        String x1 = test1.parse(s);
        char x2 = anyChar.parse(s);
        return x1 + x2;
    };

    public static void main(String[] args) {
        parseTest(test2, &quot;12&quot;);  // 文字数不足
        parseTest(test2, &quot;123&quot;);
    }
}
```
```text:実行結果
too short
123
```

## 条件取得

`anyChar`は無条件で文字を取得していましたが、条件が指定できる`satisfy`を追加します。引数で渡されたメソッドをキャプチャしたクロージャを返します。

```java
import jmyparsec.*;
import java.util.function.Function;

public class Test {

    static void parseTest(Parser p, String src) {
        Source s = new Source(src);
        try {
            System.out.println(p.parse(s));
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    static final Parser&lt;Character&gt; anyChar = s -&gt; {
        char ret = s.peek();
        s.next();
        return ret;
    };

    static final Parser&lt;Character&gt; satisfy(Function&lt;Character, Boolean&gt; f) {  // 追加
        return s -&gt; {
            char ch = s.peek();
            if (!f.apply(ch)) {
                throw new Exception(&quot;not satisfy&quot;);
            }
            s.next();
            return ch;
        };
    }

    public static void main(String[] args) {
        parseTest(satisfy(Character::isDigit), &quot;abc&quot;);  // NG
        parseTest(satisfy(Character::isDigit), &quot;123&quot;);
    }
}
```
```text:実行結果
not satisfy
1
```

今回の機能追加に直接関係ない`test1`と`test2`は削除しました。

### 共通化

`anyChar`と`satisfy`で処理が重複しています。`anyChar`は無条件の`satisfy`として定義することで共通化を図ります。

```java
import jmyparsec.*;
import java.util.function.Function;

public class Test {

    static void parseTest(Parser p, String src) {
        Source s = new Source(src);
        try {
            System.out.println(p.parse(s));
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    static final Parser&lt;Character&gt; anyChar = satisfy(s -&gt; true);  // 変更

    static final Parser&lt;Character&gt; satisfy(Function&lt;Character, Boolean&gt; f) {
        return s -&gt; {
            char ch = s.peek();
            if (!f.apply(ch)) {
                throw new Exception(&quot;not satisfy&quot;);
            }
            s.next();
            return ch;
        };
    }

    public static void main(String[] args) {
        parseTest(anyChar, &quot;abc&quot;);
    }
}
```
```text:実行結果
a
```

`anyChar`はラムダ式で定義したため1行で済んでいるのがポイントです。

## ファイル分割

コードが長くなって来たため、汎用部分を別ファイルに分離します。

```jmyparsec/Parsers.java
package jmyparsec;

import java.util.function.Function;

public class Parsers {

    public static void parseTest(Parser p, String src) {
        Source s = new Source(src);
        try {
            System.out.println(p.parse(s));
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    public static final Parser&lt;Character&gt; anyChar = satisfy(s -&gt; true);

    public static final Parser&lt;Character&gt; satisfy(Function&lt;Character, Boolean&gt; f) {
        return s -&gt; {
            char ch = s.peek();
            if (!f.apply(ch)) {
                throw new Exception(&quot;not satisfy&quot;);
            }
            s.next();
            return ch;
        };
    }
}
```

簡単のため`import static`して使います。

```java
import static jmyparsec.Parsers.*;

public class Test {

    public static void main(String[] args) {
        parseTest(anyChar, &quot;abc&quot;);
    }
}
```
```text:実行結果
a
```

## 文字判定

文字を指定して判定するパーサを実装します。Parsecでは`char`ですが、型と被るため`char1`に名前を変更します。

```java:jmyparsec/Parsers.java（追加）
    public static final Parser&lt;Character&gt; char1(char ch) {
        return satisfy(c -&gt; c == ch);
    }
```

`char1`は引数`ch`をキャプチャしたクロージャを返しているのがポイントです。今後このようなパターンがよく出て来ます。

動作を確認します。

```java
import static jmyparsec.Parsers.*;

public class Test {

    public static void main(String[] args) {
        parseTest(char1(&#39;a&#39;), &quot;abc&quot;);
        parseTest(char1(&#39;a&#39;), &quot;123&quot;);  // NG
    }
}
```
```text:実行結果
a
not satisfy
```

## 事前定義

`satisfy`で条件を指定するのは冗長なので、よく使うパターンを事前定義します。

```java:jmyparsec/Parsers.java（追加）
    public static final boolean isAlphaNum(char ch) {
        return Character.isAlphabetic(ch) || Character.isDigit(ch);
    }

    public static final Parser&lt;Character&gt; digit = satisfy(Character::isDigit);
    public static final Parser&lt;Character&gt; upper = satisfy(Character::isUpperCase);
    public static final Parser&lt;Character&gt; lower = satisfy(Character::isLowerCase);
    public static final Parser&lt;Character&gt; alpha = satisfy(Character::isAlphabetic);
    public static final Parser&lt;Character&gt; alphaNum = satisfy(Parsers::isAlphaNum);
    public static final Parser&lt;Character&gt; letter = satisfy(Character::isLetter);
```

動作を確認します。

```java
import static jmyparsec.Parsers.*;

public class Test {

    public static void main(String[] args) {
        parseTest(digit , &quot;abc&quot;);  // NG
        parseTest(digit , &quot;123&quot;);
        parseTest(letter, &quot;abc&quot;);
        parseTest(letter, &quot;123&quot;);  // NG
    }
}
```
```text:実行結果
not satisfy
1
a
not satisfy
```

## 組み合わせ判定

先ほど追加したパーサを組み合わせて、先頭から「アルファベット」「数字」「数字」という組み合わせを判定するパーサを作ります。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;String&gt; test3 = s -&gt; {
        char x1 = letter.parse(s);
        char x2 = digit.parse(s);
        char x3 = digit.parse(s);
        return new String(new char[]{x1, x2, x3});
    };

    public static void main(String[] args) {
        parseTest(test3, &quot;abc&quot;);  // NG
        parseTest(test3, &quot;123&quot;);  // NG
        parseTest(test3, &quot;a23&quot;);
        parseTest(test3, &quot;a234&quot;);
    }
}
```
```text:実行結果
not satisfy
not satisfy
a23
a23
```

`main()`から見ると、同じクラスに定義されているパーサ（`anyChar`など）と`jmyparsec.Parsers`に定義されているパーサ（`test3`）が、クラス名修飾なしに同列に使えています。これが`anyChar`を`Source`のインスタンスメソッドにしなかった理由です。

## コンビネータの定義

パーサ同士を組み合わせて新しいパーサを作り出すメソッドを**コンビネータ**と呼びます。

いくつか便利なコンビネータを定義します。

### 結合

パーサを結合するコンビネータ`sequence`を定義してParsers.javaに追加します。

```java:jmyparsec/Parsers.java（追加）
    public static final Parser&lt;String&gt; sequence(Parser... args) {
        return s -&gt; {
            StringBuilder sb = new StringBuilder();
            for (Parser arg : args) {
                sb.append(arg.parse(s));
            }
            return sb.toString();
        };
    }
```

`test3`がとても簡単になります。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;String&gt; test3 = sequence(letter, digit, digit);

    public static void main(String[] args) {
        parseTest(test3, &quot;abc&quot;);  // NG
        parseTest(test3, &quot;123&quot;);  // NG
        parseTest(test3, &quot;a23&quot;);
        parseTest(test3, &quot;a234&quot;);
    }
}
```
```text:実行結果
not satisfy
not satisfy
a23
a23
```

処理が関数を定義しなくても組み合わせで表現されています。この感覚がつかめれば、パーサコンビネータが見えて来ます。

※ 前の方で述べた`.parse`を回避するための対策がこれです。

### 繰り返し

同じパーサを指定回数繰り返すコンビネータ`replicate`を定義します。

```java:jmyparsec/Parsers.java（追加）
    public static final Parser&lt;String&gt; replicate(int n, Parser p) {
        return s -&gt; {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &lt; n; ++i) {
                sb.append(p.parse(s));
            }
            return sb.toString();
        };
    }
```

`test3`で使ってみます。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;String&gt; test3 = sequence(letter, replicate(2, digit));

    public static void main(String[] args) {
        parseTest(test3, &quot;abc&quot;);  // NG
        parseTest(test3, &quot;123&quot;);  // NG
        parseTest(test3, &quot;a23&quot;);
        parseTest(test3, &quot;a234&quot;);
    }
}
```
```text:実行結果
not satisfy
not satisfy
a23
a23
```

2回の繰り返しではあまり嬉しくありませんが、回数が増えれば楽になります。

## many

繰り返しに関連して、最初のコンセプトで出て来た`many`を実装してみます。

`many`は指定したパーサを0回以上適用して返すコンビネータです。エラーになるまで読み進めれば実装できます。

```java:jmyparsec/Parsers.java（追加）
    public static final Parser&lt;String&gt; many(Parser p) {
        return s -&gt; {
            StringBuilder sb = new StringBuilder();
            try {
                for (;;) {
                    sb.append(p.parse(s));
                }
            } catch (Exception e) {
            }
            return sb.toString();
        };
    }
```

先頭からアルファベットだけを抜き出してみます。1文字も一致しなくても、エラーにはならずに空文字列が返ります。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;String&gt; test4 = many(alpha);

    public static void main(String[] args) {
        parseTest(test4, &quot;abc123&quot;);
        parseTest(test4, &quot;123abc&quot;);
    }
}
```
```text:実行結果
abc
     ← 空行
```

最初に出て来たサンプルも動きます。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    public static void main(String[] args) throws Exception {
        Source s1 = new Source(&quot;abc123&quot;);
        String s1a = many(alpha).parse(s1);
        String s1b = many(digit).parse(s1);
        System.out.println(s1a + &quot;,&quot; + s1b);

        Source s2 = new Source(&quot;abcde9&quot;);
        String s2a = many(alpha).parse(s2);
        String s2b = many(digit).parse(s2);
        System.out.println(s2a + &quot;,&quot; + s2b);
    }
}
```
```text:実行結果
abc,123
abcde,9
```

## まとめ

ここまでがパーサコンビネータの動作原理を理解するために最低限必要な実装です。

このセクションで登場したテストを1つにまとめます。

* [ここまでの jmyparsec](https://bitbucket.org/7shi/jmyparsec/src/0388bbfbf90b0215f640430e6bc48833d3e2c24f/src/jmyparsec/?at=default)

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;String&gt; test1 = sequence(anyChar, anyChar);
    static final Parser&lt;String&gt; test2 = sequence(test1, anyChar);
    static final Parser&lt;String&gt; test3 = sequence(letter, replicate(2, digit));
    static final Parser&lt;String&gt; test4 = many(alpha);

    public static void main(String[] args) throws Exception {
        parseTest(anyChar   , &quot;abc&quot;   );
        parseTest(test1     , &quot;abc&quot;   );
        parseTest(test2     , &quot;abc&quot;   );
        parseTest(test2     , &quot;12&quot;    );  // NG
        parseTest(test2     , &quot;123&quot;   );
        parseTest(char1(&#39;a&#39;), &quot;abc&quot;   );
        parseTest(char1(&#39;a&#39;), &quot;123&quot;   );  // NG
        parseTest(digit     , &quot;abc&quot;   );  // NG
        parseTest(digit     , &quot;123&quot;   );
        parseTest(letter    , &quot;abc&quot;   );
        parseTest(letter    , &quot;123&quot;   );  // NG
        parseTest(test3     , &quot;abc&quot;   );  // NG
        parseTest(test3     , &quot;123&quot;   );  // NG
        parseTest(test3     , &quot;a23&quot;   );
        parseTest(test3     , &quot;a234&quot;  );
        parseTest(test4     , &quot;abc123&quot;);
        parseTest(test4     , &quot;123abc&quot;);

        Source s1 = new Source(&quot;abc123&quot;);
        String s1a = many(alpha).parse(s1);
        String s1b = many(digit).parse(s1);
        System.out.println(s1a + &quot;,&quot; + s1b);

        Source s2 = new Source(&quot;abcde9&quot;);
        String s2a = many(alpha).parse(s2);
        String s2b = many(digit).parse(s2);
        System.out.println(s2a + &quot;,&quot; + s2b);
    }
}
```
```text:実行結果
a
ab
abc
too short
123
a
not satisfy
not satisfy
1
a
not satisfy
not satisfy
not satisfy
a23
a23
abc

abc,123
abcde,9
```

最初にコンセプトで提示したコードを見たときはモヤっとしていた部分も、少しはすっきりしたでしょうか。

# 選択

非常によく使うのが選択のコンビネータです。

便利なだけでなく、色々と悩ましい問題があるのを見ていきます。

## 単純な実装

「または」を表現するコンビネータ`or`を実装します。

```java:jmyparsec/Parsers.java（追加）
    public static final &lt;T&gt; Parser&lt;T&gt; or(Parser&lt;T&gt; p1, Parser&lt;T&gt; p2) {
        return s -&gt; {
            T ret;
            try {
                ret = p1.parse(s);
            } catch (Exception e) {
                ret = p2.parse(s);
            }
            return ret;
        };
    }
```

`or`を使えば「アルファベットまたは数字」のような選択的なパーサが構築できます。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; test5 = or(letter, digit);

    public static void main(String[] args) {
        parseTest(test5, &quot;a&quot;);
        parseTest(test5, &quot;1&quot;);
        parseTest(test5, &quot;!&quot;);  // NG
    }
}
```
```text:実行結果
a
1
not satisfy
```

### manyとの組み合わせ

選択的パーサを`many`で繰り返すこともできます。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;String&gt; test6 = many(or(letter, digit));

    public static void main(String[] args) {
        parseTest(test6, &quot;abc123&quot;);
        parseTest(test6, &quot;123abc&quot;);
    }
}
```
```text:実行結果
abc123
123abc
```

## 結合と選択

`or`を少し使ってみると、直感に反した動きに気付きます。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; a = char1(&#39;a&#39;);
    static final Parser&lt;Character&gt; b = char1(&#39;b&#39;);
    static final Parser&lt;Character&gt; c = char1(&#39;c&#39;);

    static final Parser&lt;String&gt; test7 = or(sequence(a, b), sequence(c, b));

    public static void main(String[] args) {
        parseTest(test7, &quot;ab&quot;);
        parseTest(test7, &quot;cb&quot;);
        parseTest(test7, &quot;acb&quot;);  // ???
    }
}
```
```text:実行結果
ab
cb
cb
```

`test7`を素直に見ると「`&quot;ab&quot;`または`&quot;cb&quot;`」となり、確かにその両方にマッチします。しかし`&quot;acb&quot;`にもマッチしてしまいます。これは`or`に達する前に`&#39;a&#39;`だけは読み進めてしまったため、`or`の後のパターンにマッチしてしまうためです。

## エラー化

このようなケースはParsecではエラーになります。

`or(左, 右)`として、左のパーサが内部で複数のパーサから構成されるとき、そのうち1つでも成功してその後で失敗したなら、右のパーサは処理されずにエラーになるという仕様です。

これを実装するため、パーサの状態を保持・比較できるように修正します。

```java:jmyparsec/Source.java（追加）
    @Override
    public Source clone() {
        Source ret = new Source(s);
        ret.pos = pos;
        return ret;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Source)) {
            return false;
        }
        Source src = (Source) obj;
        return s.equals(src.s) &amp;&amp; pos == src.pos;
    }
```

最初の状態を保持しておいて、`or`の前で読み進めていれば例外を再送します。

```java:jmyparsec/Parsers.java（修正）
    public static final &lt;T&gt; Parser&lt;T&gt; or(Parser&lt;T&gt; p1, Parser&lt;T&gt; p2) {
        return s -&gt; {
            T ret;
            Source bak = s.clone();    // 追加
            try {
                ret = p1.parse(s);
            } catch (Exception e) {
                if (!s.equals(bak)) {  // 追加
                    throw e;
                }
                ret = p2.parse(s);
            }
            return ret;
        };
    }
```

先ほどと同じコードを試すと、最後がエラーになります。Parsecと同じで意図した動きです。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; a = char1(&#39;a&#39;);
    static final Parser&lt;Character&gt; b = char1(&#39;b&#39;);
    static final Parser&lt;Character&gt; c = char1(&#39;c&#39;);

    static final Parser&lt;String&gt; test7 = or(sequence(a, b), sequence(c, b));

    public static void main(String[] args) {
        parseTest(test7, &quot;ab&quot;);
        parseTest(test7, &quot;cb&quot;);
        parseTest(test7, &quot;acb&quot;);  // ???
    }
}
```
```text:実行結果
ab
cb
not satisfy
```

## 共通部分

選択肢の先頭に共通部分があった場合、意図せずエラーになることがあります。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; a = char1(&#39;a&#39;);
    static final Parser&lt;Character&gt; b = char1(&#39;b&#39;);
    static final Parser&lt;Character&gt; c = char1(&#39;c&#39;);

    static final Parser&lt;String&gt; test8 = or(sequence(a, b), sequence(a, c));

    public static void main(String[] args) {
        parseTest(test8, &quot;ab&quot;);
        parseTest(test8, &quot;ac&quot;);  // NG
    }
}
```
```text:実行結果
ab
not satisfy
```

このようなケースでは、共通部分を括り出すことで対処できます。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; a = char1(&#39;a&#39;);
    static final Parser&lt;Character&gt; b = char1(&#39;b&#39;);
    static final Parser&lt;Character&gt; c = char1(&#39;c&#39;);

    static final Parser&lt;String&gt; test8 = or(sequence(a, b), sequence(a, c));
    static final Parser&lt;String&gt; test9 = sequence(a, or(b, c));

    public static void main(String[] args) {
        parseTest(test8, &quot;ab&quot;);
        parseTest(test8, &quot;ac&quot;);  // NG
        parseTest(test9, &quot;ab&quot;);
        parseTest(test9, &quot;ac&quot;);
    }
}
```
```text:実行結果
ab
not satisfy
ab
ac
```

別の方法として状態を巻き戻す方法もあります。

## バックトラック

パースに失敗したとき、状態を巻き戻して別の方法でパースをやり直すことを**バックトラック**と呼びます。

### tryp

Parsecでバックトラックするには対象となるパーサを`try`で囲みます。例外処理の`try`と名前が被るため、ここでは`tryp`に名前を変更します。（`p`はParserの頭文字です）

`Source`の状態を元に戻せるようにします。

```java:jmyparsec/Source.java（追加）
    public final void revert(Source src) throws Exception {
        if (!s.equals(src.s)) {
            throw new Exception(&quot;can not revert&quot;);
        }
        pos = src.pos;
    }
```

`tryp`の中で失敗すれば元の状態に戻してから例外を再送します。

```java:jmyparsec/Parsers.java（追加）
    public static final &lt;T&gt; Parser&lt;T&gt; tryp(Parser&lt;T&gt; p) {
        return s -&gt; {
            T ret;
            Source bak = s.clone();
            try {
                ret = p.parse(s);
            } catch (Exception e) {
                s.revert(bak);
                throw e;
            }
            return ret;
        };
    }
```

`or`の左側を`tryp`で囲めば、失敗してもバックトラックしてから右側が処理されます。

先ほどの`test8`と`test9`と挙動を比較します。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; a = char1(&#39;a&#39;);
    static final Parser&lt;Character&gt; b = char1(&#39;b&#39;);
    static final Parser&lt;Character&gt; c = char1(&#39;c&#39;);

    static final Parser&lt;String&gt; test8 = or(sequence(a, b), sequence(a, c));
    static final Parser&lt;String&gt; test9 = sequence(a, or(b, c));
    static final Parser&lt;String&gt; test10 = or(tryp(sequence(a, b)), sequence(a, c));

    public static void main(String[] args) {
        parseTest(test8 , &quot;ab&quot;);
        parseTest(test8 , &quot;ac&quot;);  // NG
        parseTest(test9 , &quot;ab&quot;);
        parseTest(test9 , &quot;ac&quot;);
        parseTest(test10, &quot;ab&quot;);
        parseTest(test10, &quot;ac&quot;);
    }
}
```
```text:実行結果
ab
not satisfy
ab
ac
ab
ac
```

`test9`と`test10`は同じ動きです。

## string

1文字ずつ`char1`でパースすると面倒なため、文字列で指定できる`string`を実装します。

```java:jmyparsec/Parsers.java（追加）
    public static final Parser&lt;String&gt; string(String str) {
        return s -&gt; {
            for (int i = 0; i &lt; str.length(); ++i) {
                char1(str.charAt(i)).parse(s);
            }
            return str;
        };
    }
```

内部では1文字ずつ処理されているため、途中の失敗をバックトラックするには`tryp`が必要です。

挙動を確認します。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;String&gt; test11 = or(string(&quot;ab&quot;), string(&quot;ac&quot;));
    static final Parser&lt;String&gt; test12 = or(tryp(string(&quot;ab&quot;)), string(&quot;ac&quot;));

    public static void main(String[] args) {
        parseTest(test11, &quot;ab&quot;);
        parseTest(test11, &quot;ac&quot;);  // NG
        parseTest(test12, &quot;ab&quot;);
        parseTest(test12, &quot;ac&quot;);
    }
}
```
```text:実行結果
ab
not satisfy
ab
ac
```

## まとめ

このセクションで登場したテストを1つにまとめます。

* [ここまでの jmyparsec](https://bitbucket.org/7shi/jmyparsec/src/454a73cd1cc091adc37ae7212ce71a7e97b42733/src/jmyparsec/?at=default)

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; a = char1(&#39;a&#39;);
    static final Parser&lt;Character&gt; b = char1(&#39;b&#39;);
    static final Parser&lt;Character&gt; c = char1(&#39;c&#39;);

    static final Parser&lt;Character&gt; test5 = or(letter, digit);
    static final Parser&lt;String&gt; test6 = many(or(letter, digit));
    static final Parser&lt;String&gt; test7 = or(sequence(a, b), sequence(c, b));
    static final Parser&lt;String&gt; test8 = or(sequence(a, b), sequence(a, c));
    static final Parser&lt;String&gt; test9 = sequence(a, or(b, c));
    static final Parser&lt;String&gt; test10 = or(tryp(sequence(a, b)), sequence(a, c));
    static final Parser&lt;String&gt; test11 = or(string(&quot;ab&quot;), string(&quot;ac&quot;));
    static final Parser&lt;String&gt; test12 = or(tryp(string(&quot;ab&quot;)), string(&quot;ac&quot;));

    public static void main(String[] args) {
        parseTest(test5 , &quot;a&quot;     );
        parseTest(test5 , &quot;1&quot;     );
        parseTest(test5 , &quot;!&quot;     );  // NG
        parseTest(test6 , &quot;abc123&quot;);
        parseTest(test6 , &quot;123abc&quot;);
        parseTest(test7 , &quot;ab&quot;    );
        parseTest(test7 , &quot;cb&quot;    );
        parseTest(test7 , &quot;acb&quot;   );  // NG
        parseTest(test8 , &quot;ab&quot;    );
        parseTest(test8 , &quot;ac&quot;    );  // NG
        parseTest(test9 , &quot;ab&quot;    );
        parseTest(test9 , &quot;ac&quot;    );
        parseTest(test10, &quot;ab&quot;    );
        parseTest(test10, &quot;ac&quot;    );
        parseTest(test11, &quot;ab&quot;    );
        parseTest(test11, &quot;ac&quot;    );  // NG
        parseTest(test12, &quot;ab&quot;    );
        parseTest(test12, &quot;ac&quot;    );
    }
}
```
```text:実行結果
a
1
not satisfy
abc123
123abc
ab
cb
not satisfy
ab
not satisfy
ab
ac
ab
ac
ab
not satisfy
ab
ac
```

# エラー表示

エラーが`too short`や`not satisfy`では分かりにくいので改善します。

このセクションは修正箇所が多いため差分と全体の両方を示します。

## 確認

エラーが出るものだけ抽出して確認します。

```java
import jmyparsec.*;
import static jmyparsec.Parsers.*;

public class Test {

    static final Parser&lt;Character&gt; a = char1(&#39;a&#39;);
    static final Parser&lt;Character&gt; b = char1(&#39;b&#39;);
    static final Parser&lt;Character&gt; c = char1(&#39;c&#39;);

    static final Parser&lt;String&gt; test1 = sequence(anyChar, anyChar);
    static final Parser&lt;String&gt; test2 = sequence(test1, anyChar);
    static final Parser&lt;String&gt; test3 = sequence(letter, replicate(2, digit));
    static final Parser&lt;Character&gt; test5 = or(letter, digit);
    static final Parser&lt;String&gt; test7 = or(sequence(a, b), sequence(c, b));
    static final Parser&lt;String&gt; test8 = or(sequence(a, b), sequence(a, c));
    static final Parser&lt;String&gt; test11 = or(string(&quot;ab&quot;), string(&quot;ac&quot;));

    public static void main(String[] args) {
        parseTest(test2     , &quot;12&quot; );  // NG
        parseTest(char1(&#39;a&#39;), &quot;123&quot;);  // NG
        parseTest(digit     , &quot;abc&quot;);  // NG
        parseTest(letter    , &quot;123&quot;);  // NG
        parseTest(test3     , &quot;abc&quot;);  // NG
        parseTest(test3     , &quot;123&quot;);  // NG
        parseTest(test5     , &quot;!&quot;  );  // NG
        parseTest(test7     , &quot;acb&quot;);  // NG
        parseTest(test8     , &quot;ac&quot; );  // NG
        parseTest(test11    , &quot;ac&quot; );  // NG
    }
}
```
```text:実行結果
too short
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
not satisfy
```

## 位置

`Source`に位置（行と桁）を保持してエラーメッセージに含めます。

差分を示します。

```diff
--- jmyparsec/Source.java
+++ jmyparsec/Source.java
@@ -3,10 +3,11 @@
 public class Source {
 
     private final String s;
-    private int pos;
+    private int pos, line, col;
 
     public Source(String s) {
         this.s = s;
+        line = col = 1;
     }
 
     @Override
@@ -27,19 +28,29 @@
 
     public final char peek() throws Exception {
         if (pos &gt;= s.length()) {
-            throw new Exception(&quot;too short&quot;);
+            throw new Exception(ex(&quot;too short&quot;));
         }
         return s.charAt(pos);
     }
 
-    public final void next() {
+    public final void next() throws Exception {
+        char ch = peek();
+        if (ch == &#39;\n&#39;) {
+            ++line;
+            col = 0;
+        }
         ++pos;
+        ++col;
     }
 
     public final void revert(Source src) throws Exception {
         if (!s.equals(src.s)) {
-            throw new Exception(&quot;can not revert&quot;);
+            throw new Exception(ex(&quot;can not revert&quot;));
         }
         pos = src.pos;
     }
+
+    public final String ex(String e) {
+        return &quot;[line &quot; + line + &quot;,col &quot; + col + &quot;] &quot; + e;
+    }
 }
```
```diff
--- jmyparsec/Parsers.java
+++ jmyparsec/Parsers.java
@@ -19,7 +19,7 @@
         return s -&gt; {
             char ch = s.peek();
             if (!f.apply(ch)) {
-                throw new Exception(&quot;not satisfy&quot;);
+                throw new Exception(s.ex(&quot;not satisfy&quot;));
             }
             s.next();
             return ch;
```

* [修正後の jmyparsec](https://bitbucket.org/7shi/jmyparsec/src/6dc1b2bab6fed81d3399729c4e11f112b9a468f5/src/jmyparsec/?at=default)

先ほどと同じコードをテストして、エラーの変化を確認します。

```text:実行結果
[line 1, col 3] too short
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 1] not satisfy
[line 1, col 1] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
[line 1, col 2] not satisfy
```

どこでエラーが発生したか分かるようになりました。

## 対象の文字

どの文字でエラーになったかをエラーメッセージに含めます。

差分を示します。

```diff
--- jmyparsec/Source.java
+++ jmyparsec/Source.java
@@ -51,6 +51,10 @@
     }
 
     public final String ex(String e) {
-        return &quot;[line &quot; + line + &quot;,col &quot; + col + &quot;] &quot; + e;
+        String ret = &quot;[line &quot; + line + &quot;,col &quot; + col + &quot;] &quot; + e;
+        if (s != null &amp;&amp; 0 &lt;= pos &amp;&amp; pos &lt; s.length()) {
+            ret += &quot;: &#39;&quot; + s.charAt(pos) + &quot;&#39;&quot;;
+        }
+        return ret;
     }
 }
```

* [修正後の jmyparsec](https://bitbucket.org/7shi/jmyparsec/src/b2c76cef6965c5110998726d2c953d161bce2ab5/src/jmyparsec/?at=default)

先ほどと同じコードをテストして、エラーの変化を確認します。

```text:実行結果
[line 1, col 3] too short
[line 1, col 1] not satisfy: &#39;1&#39;
[line 1, col 1] not satisfy: &#39;a&#39;
[line 1, col 1] not satisfy: &#39;1&#39;
[line 1, col 2] not satisfy: &#39;b&#39;
[line 1, col 1] not satisfy: &#39;1&#39;
[line 1, col 1] not satisfy: &#39;!&#39;
[line 1, col 2] not satisfy: &#39;c&#39;
[line 1, col 2] not satisfy: &#39;c&#39;
[line 1, col 2] not satisfy: &#39;c&#39;
```

どの文字でエラーになったのかが分かるようになりました。

## 失敗の確定

失敗を確定させて指定したメッセージで例外を発生させる`left`を実装します。

※ 英語でrightは「右」の他に「正しい」という意味がありますが、その反対を意図して`left`と命名されました。ある種の言葉遊びで、英語としての単語に「誤り」という意味があるわけではありません。

`or`と`left`を組み合わせれば、エラーメッセージがカスタマイズできます。

差分を示します。

```diff
--- jmyparsec/Parsers.java
+++ jmyparsec/Parsers.java
@@ -27,19 +27,19 @@
     }
 
     public static final Parser&lt;Character&gt; char1(char ch) {
-        return satisfy(c -&gt; c == ch);
+        return or(satisfy(c -&gt; c == ch), left(&quot;not char &#39;&quot; + ch + &quot;&#39;&quot;));
     }
 
     public static final boolean isAlphaNum(char ch) {
         return Character.isAlphabetic(ch) || Character.isDigit(ch);
     }
 
-    public static final Parser&lt;Character&gt; digit = satisfy(Character::isDigit);
-    public static final Parser&lt;Character&gt; upper = satisfy(Character::isUpperCase);
-    public static final Parser&lt;Character&gt; lower = satisfy(Character::isLowerCase);
-    public static final Parser&lt;Character&gt; alpha = satisfy(Character::isAlphabetic);
-    public static final Parser&lt;Character&gt; alphaNum = satisfy(Parsers::isAlphaNum);
-    public static final Parser&lt;Character&gt; letter = satisfy(Character::isLetter);
+    public static final Parser&lt;Character&gt; digit    = or(satisfy(Character::isDigit)     , left(&quot;not digit&quot;   ));
+    public static final Parser&lt;Character&gt; upper    = or(satisfy(Character::isUpperCase) , left(&quot;not upper&quot;   ));
+    public static final Parser&lt;Character&gt; lower    = or(satisfy(Character::isLowerCase) , left(&quot;not lower&quot;   ));
+    public static final Parser&lt;Character&gt; alpha    = or(satisfy(Character::isAlphabetic), left(&quot;not alpha&quot;   ));
+    public static final Parser&lt;Character&gt; alphaNum = or(satisfy(Parsers  ::isAlphaNum)  , left(&quot;not alphaNum&quot;));
+    public static final Parser&lt;Character&gt; letter   = or(satisfy(Character::isLetter)    , left(&quot;not letter&quot;  ));
 
     public static final Parser&lt;String&gt; sequence(Parser... args) {
         return s -&gt; {
@@ -107,9 +107,15 @@
     public static final Parser&lt;String&gt; string(String str) {
         return s -&gt; {
             for (int i = 0; i &lt; str.length(); ++i) {
-                char1(str.charAt(i)).parse(s);
+                or(char1(str.charAt(i)), left(&quot;not string \&quot;&quot; + str + &quot;\&quot;&quot;)).parse(s);
             }
             return str;
         };
     }
+
+    public static final &lt;T&gt; Parser&lt;T&gt; left(String e) {
+        return s -&gt; {
+            throw new Exception(s.ex(e));
+        };
+    }
 }
```

* [修正後の jmyparsec](https://bitbucket.org/7shi/jmyparsec/src/5bb3e7d82f40f0c6389741d9927548c569a193f4/src/jmyparsec/?at=default)

先ほどと同じコードをテストして、エラーの変化を確認します。

```text:実行結果
[line 1, col 3] too short
[line 1, col 1] not char &#39;a&#39;: &#39;1&#39;
[line 1, col 1] not digit: &#39;a&#39;
[line 1, col 1] not letter: &#39;1&#39;
[line 1, col 2] not digit: &#39;b&#39;
[line 1, col 1] not letter: &#39;1&#39;
[line 1, col 1] not digit: &#39;!&#39;
[line 1, col 2] not char &#39;b&#39;: &#39;c&#39;
[line 1, col 2] not char &#39;b&#39;: &#39;c&#39;
[line 1, col 2] not string &quot;ab&quot;: &#39;c&#39;
```

エラーの種類が分かるようになりました。説明用にはこれくらいで十分でしょう。

## メソッドチェイン

`or`や`left`はよく使うので、`Parser`のデフォルトメソッドにします。こうすればメソッドチェインで書けるようになります。

```diff
--- jmyparsec/Parser.java
+++ jmyparsec/Parser.java
@@ -4,4 +4,26 @@
 public interface Parser&lt;T&gt; {
 
     T parse(Source s) throws Exception;
+
+    default Parser&lt;T&gt; or(Parser&lt;T&gt; p) {
+        return s -&gt; {
+            T ret;
+            Source bak = s.clone();
+            try {
+                ret = parse(s);
+            } catch (Exception e) {
+                if (!s.equals(bak)) {
+                    throw e;
+                }
+                ret = p.parse(s);
+            }
+            return ret;
+        };
+    }
+
+    default Parser&lt;T&gt; left(String e) {
+        return or(s -&gt; {
+            throw new Exception(s.ex(e));
+        });
+    }
 }
```
```diff
--- jmyparsec/Parsers.java
+++ jmyparsec/Parsers.java
@@ -27,19 +27,19 @@
     }
 
     public static final Parser&lt;Character&gt; char1(char ch) {
-        return or(satisfy(c -&gt; c == ch), left(&quot;not char &#39;&quot; + ch + &quot;&#39;&quot;));
+        return satisfy(c -&gt; c == ch).left(&quot;not char &#39;&quot; + ch + &quot;&#39;&quot;);
     }
 
     public static final boolean isAlphaNum(char ch) {
         return Character.isAlphabetic(ch) || Character.isDigit(ch);
     }
 
-    public static final Parser&lt;Character&gt; digit    = or(satisfy(Character::isDigit)     , left(&quot;not digit&quot;   ));
-    public static final Parser&lt;Character&gt; upper    = or(satisfy(Character::isUpperCase) , left(&quot;not upper&quot;   ));
-    public static final Parser&lt;Character&gt; lower    = or(satisfy(Character::isLowerCase) , left(&quot;not lower&quot;   ));
-    public static final Parser&lt;Character&gt; alpha    = or(satisfy(Character::isAlphabetic), left(&quot;not alpha&quot;   ));
-    public static final Parser&lt;Character&gt; alphaNum = or(satisfy(Parsers  ::isAlphaNum)  , left(&quot;not alphaNum&quot;));
-    public static final Parser&lt;Character&gt; letter   = or(satisfy(Character::isLetter)    , left(&quot;not letter&quot;  ));
+    public static final Parser&lt;Character&gt; digit    = satisfy(Character::isDigit     ).left(&quot;not digit&quot;   );
+    public static final Parser&lt;Character&gt; upper    = satisfy(Character::isUpperCase ).left(&quot;not upper&quot;   );
+    public static final Parser&lt;Character&gt; lower    = satisfy(Character::isLowerCase ).left(&quot;not lower&quot;   );
+    public static final Parser&lt;Character&gt; alpha    = satisfy(Character::isAlphabetic).left(&quot;not alpha&quot;   );
+    public static final Parser&lt;Character&gt; alphaNum = satisfy(Parsers  ::isAlphaNum  ).left(&quot;not alphaNum&quot;);
+    public static final Parser&lt;Character&gt; letter   = satisfy(Character::isLetter    ).left(&quot;not letter&quot;  );
 
     public static final Parser&lt;String&gt; sequence(Parser... args) {
         return s -&gt; {
@@ -75,19 +75,7 @@
     }
 
     public static final &lt;T&gt; Parser&lt;T&gt; or(Parser&lt;T&gt; p1, Parser&lt;T&gt; p2) {
-        return s -&gt; {
-            T ret;
-            Source bak = s.clone();
-            try {
-                ret = p1.parse(s);
-            } catch (Exception e) {
-                if (!s.equals(bak)) {
-                    throw e;
-                }
-                ret = p2.parse(s);
-            }
-            return ret;
-        };
+        return p1.or(p2);
     }
 
     public static final &lt;T&gt; Parser&lt;T&gt; tryp(Parser&lt;T&gt; p) {
@@ -107,7 +95,7 @@
     public static final Parser&lt;String&gt; string(String str) {
         return s -&gt; {
             for (int i = 0; i &lt; str.length(); ++i) {
-                or(char1(str.charAt(i)), left(&quot;not string \&quot;&quot; + str + &quot;\&quot;&quot;)).parse(s);
+                char1(str.charAt(i)).left(&quot;not string \&quot;&quot; + str + &quot;\&quot;&quot;).parse(s);
             }
             return str;
         };
```
```diff
--- Test.java
+++ Test.java
@@ -11,10 +11,10 @@
     static final Parser&lt;String&gt; test1 = sequence(anyChar, anyChar);
     static final Parser&lt;String&gt; test2 = sequence(test1, anyChar);
     static final Parser&lt;String&gt; test3 = sequence(letter, replicate(2, digit));
-    static final Parser&lt;Character&gt; test5 = or(letter, digit);
-    static final Parser&lt;String&gt; test7 = or(sequence(a, b), sequence(c, b));
-    static final Parser&lt;String&gt; test8 = or(sequence(a, b), sequence(a, c));
-    static final Parser&lt;String&gt; test11 = or(string(&quot;ab&quot;), string(&quot;ac&quot;));
+    static final Parser&lt;Character&gt; test5 = letter.or(digit);
+    static final Parser&lt;String&gt; test7 = sequence(a, b).or(sequence(c, b));
+    static final Parser&lt;String&gt; test8 = sequence(a, b).or(sequence(a, c));
+    static final Parser&lt;String&gt; test11 = string(&quot;ab&quot;).or(string(&quot;ac&quot;));
 
     public static void main(String[] args) {
         parseTest(test2     , &quot;12&quot; );  // NG
```

* [修正後の jmyparsec](https://bitbucket.org/7shi/jmyparsec/src/e106ff602890e230ff5e002e06e3da7dcb87c862/src/jmyparsec/?at=default)

実行結果は同じなので省略します。

メソッドチェインを使うかどうかは好みにもよりますが、考え方を示しておきます。

* `or(a, b)` より  `a.or(b)` の方が `a || b` の並べ方に近い。
* `a` に条件 `b` を付け足すとき、`or(a, b)`で全体を囲むより `a.or(b)` として付け足す方が書きやすい。

# おわりに

パーサコンビネータの動作イメージがつかめたでしょうか。

今回のようにテストだけではどう応用して良いのか分からないかもしれません。続編で四則演算器を作っているので、そちらも参考にしてください。

* [Java パーサコンビネータ 超入門 2](http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142) 2016.05.14
</textarea><input type="submit" name="commit" value="Save changes" data-disable-with="Save changes" /></form></div></section></div><div class="col-sm-3"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="Java パーサコンビネータ 超入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/68228e19552c271bea81" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="Java パーサコンビネータ 超入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/68228e19552c271bea81" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/68228e19552c271bea81" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/68228e19552c271bea81" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div><section class="itemsShowAuthorInfo" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><a href="/7shi"><img alt="" class="itemsShowAuthorInfo_userIcon" itemprop="image" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" /></a><div class="itemsShowAuthorInfo_profileStats"><strong class="itemsShowAuthorInfo_userName" itemprop="name"><a itemprop="url" href="/7shi">7shi</a></strong><div class="itemsShowAuthorInfo_contribution"><span class="itemsShowAuthorInfo_count">2522</span><span class="itemsShowAuthorInfo_unit">Contribution</span></div><div data-react-class="T.UserFollowButton" data-react-props="{&quot;url_name&quot;:&quot;7shi&quot;,&quot;initial_followed_by&quot;:false,&quot;size&quot;:&quot;btn-xs&quot;,&quot;position&quot;:&quot;author-info&quot;}"></div></div><section class="itemsShowAuthorPopularItems"><h5 class="itemsShowAuthorPopularItems_sectionTitle">Popular Posts</h5><ul class="itemsShowAuthorPopularItems_posts list-unstyled"><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/145f1234f8ec2af923ef">Haskell 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/547b6137d7a3c482fe68">モナド則がちょっと分かった？</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/cac7b3e9b90bf91b00cc">文字列で学ぶC++入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/85afd7bbd5d6c4115ad6">Haskell アクション 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/d1e5a0c22be6cf61d286">Haskell IDE Leksah 入門</a></li></ul></section></section><div class="scroll-chaser"><div class="google-adsense"><style>.test-text-responsible { width: 200px; height: 200px; }@media(min-width: 1200px) {  .test-text-responsible { width: 250px; height: 250px; }}@media(max-width: 979px) and (min-width: 768px) {  .test-text-responsible { width: 120px; height: 240px; }}@media(max-width: 767px) {  .test-text-responsible { width: 320px; height: 50px; }}</style><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle test-text-responsible" data-ad-client="ca-pub-8127218772604357" data-ad-slot="3880091879" style="display:inline-block"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div><div data-react-class="T.Toc" data-react-props="{&quot;body&quot;:&quot;\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%B3%E3%83%B3%E3%82%BB%E3%83%97%E3%83%88\&quot;\u003eコンセプト\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9F%BA%E7%A4%8E%E7%B7%A8\&quot;\u003e基礎編\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#1%E6%96%87%E5%AD%97%E5%8F%96%E5%BE%97\&quot;\u003e1文字取得\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%80%A3%E7%B6%9A%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97\&quot;\u003e連続呼び出し\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AF%E3%83%A9%E3%82%B9%E5%8C%96\&quot;\u003eクラス化\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%8C%96\&quot;\u003eメソッド化\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B\&quot;\u003e組み合わせ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%86%E3%82%B9%E3%83%88%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89\&quot;\u003eテストメソッド\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0%E5%9E%8B%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9\&quot;\u003e関数型インターフェース\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F%E5%8C%96\&quot;\u003eラムダ式化\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BE%8B%E5%A4%96\&quot;\u003e例外\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%9D%A1%E4%BB%B6%E5%8F%96%E5%BE%97\&quot;\u003e条件取得\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%85%B1%E9%80%9A%E5%8C%96\&quot;\u003e共通化\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2\&quot;\u003eファイル分割\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%96%87%E5%AD%97%E5%88%A4%E5%AE%9A\&quot;\u003e文字判定\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BA%8B%E5%89%8D%E5%AE%9A%E7%BE%A9\&quot;\u003e事前定義\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E5%88%A4%E5%AE%9A\&quot;\u003e組み合わせ判定\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%AE%E5%AE%9A%E7%BE%A9\&quot;\u003eコンビネータの定義\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%90%E5%90%88\&quot;\u003e結合\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97\&quot;\u003e繰り返し\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#many\&quot;\u003emany\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%BE%E3%81%A8%E3%82%81\&quot;\u003eまとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%81%B8%E6%8A%9E\&quot;\u003e選択\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%8D%98%E7%B4%94%E3%81%AA%E5%AE%9F%E8%A3%85\&quot;\u003e単純な実装\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#many%E3%81%A8%E3%81%AE%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B\&quot;\u003emanyとの組み合わせ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B5%90%E5%90%88%E3%81%A8%E9%81%B8%E6%8A%9E\&quot;\u003e結合と選択\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%A8%E3%83%A9%E3%83%BC%E5%8C%96\&quot;\u003eエラー化\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86\&quot;\u003e共通部分\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF\&quot;\u003eバックトラック\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#tryp\&quot;\u003etryp\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#string\&quot;\u003estring\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%BE%E3%81%A8%E3%82%81-1\&quot;\u003eまとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%A8%E3%83%A9%E3%83%BC%E8%A1%A8%E7%A4%BA\&quot;\u003eエラー表示\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%A2%BA%E8%AA%8D\&quot;\u003e確認\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BD%8D%E7%BD%AE\&quot;\u003e位置\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%AF%BE%E8%B1%A1%E3%81%AE%E6%96%87%E5%AD%97\&quot;\u003e対象の文字\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A4%B1%E6%95%97%E3%81%AE%E7%A2%BA%E5%AE%9A\&quot;\u003e失敗の確定\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%83%81%E3%82%A7%E3%82%A4%E3%83%B3\&quot;\u003eメソッドチェイン\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB\&quot;\u003eおわりに\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n&quot;,&quot;wrapper&quot;:&quot;#article-body-wrapper&quot;}"></div></div></div><div class="row"><div class="col-sm-9"><div class="ArticleFooter__menu"><div class="s-flex-align-center"><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:50,&quot;show_count&quot;:true,&quot;uuid&quot;:&quot;68228e19552c271bea81&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-footer&quot;}"></div><div class="ArticleFooter__userList"><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="knok"><a itemprop="url" href="/knok"><img alt="knok" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/31714/profile-images/1473685754" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="komlow"><a itemprop="url" href="/komlow"><img alt="komlow" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/7697/profile-images/1473680675" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="pogin503"><a itemprop="url" href="/pogin503"><img alt="pogin503" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/288/profile-images/1473683566" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="y_q1m"><a itemprop="url" href="/y_q1m"><img alt="y_q1m" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/102004/profile-images/1473708557" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="tomoki1207"><a itemprop="url" href="/tomoki1207"><img alt="tomoki1207" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/111100/profile-images/1473711451" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="hamu502"><a itemprop="url" href="/hamu502"><img alt="hamu502" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/38910/profile-images/1473687923" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="koher"><a itemprop="url" href="/koher"><img alt="koher" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/47085/profile-images/1473690868" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="hiroyukim"><a itemprop="url" href="/hiroyukim"><img alt="hiroyukim" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/31388/profile-images/1473685683" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="kimuraya"><a itemprop="url" href="/kimuraya"><img alt="kimuraya" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/18533/profile-images/1473682460" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="giantneco"><a itemprop="url" href="/giantneco"><img alt="giantneco" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/1655/profile-images/1473683754" /></a></div></div><div class="ArticleFooter__user"><a href="/7shi/items/68228e19552c271bea81/likers"><span class="fa fa-ellipsis-h"></span></a></div></div></div><div class="u-flex u-align-center"><div class="ArticleFooter__stock"><div class="js-stockbutton" data-position="footer_menu" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="ArticleFooter__editRequest"><a class="u-link-no-underline" data-toggle="tooltip" title="You can propose improvements about the article to the author 💪" href="/drafts/68228e19552c271bea81/edit"><span class="fa fa-send-o fa-lg"></span> <span>Edit request</span></a></div><div class="dropdown ArticleFooter__dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h"></span></a><ul class="dropdown-menu dropdown-menu-right"><li><a href="/7shi/items/68228e19552c271bea81.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><i class="fa fa-fw fa-flag"></i> Report article</a></li></ul></div></div></div><ul class="references js-referencesView"><li class="references_header"><i class="fa fa-fw fa-link"></i> Linked from these articles</li><a class="references_toggleOldReferences js-toggleOldReferences" href="#"><i class="fa fa-expand js-toggleOldReferencesIcon"></i><span class="js-toggleOldReferencesText">Show old 2 links</span></a><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/6a12160276a8db358e34#_reference-28b785f74e6669908671"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />C++11 パーサコンビネータ 超入門</a><time class="references_datetime js-dateTimeView" datetime="2016-05-12T05:26:50+00:00">10 months ago</time></li><li class="references_reference js-reference js-oldReference"><span>Linked from </span><a href="/7shi/items/b8c741e78a96ea2c10fe#_reference-086ea9ca2bd62e08949a"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell 構文解析 超入門</a><time class="references_datetime js-dateTimeView" datetime="2016-05-12T05:29:39+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/39a9ddffcc5bdf2c0142#_reference-a08878b25342aa3c057f"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Java パーサコンビネータ 超入門 2</a><time class="references_datetime js-dateTimeView" datetime="2016-05-13T16:54:03+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/f86f2f7ad68cfff1b399#_reference-36fe03d2df16951e3fcf"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />C++11 パーサコンビネータ 超入門 2</a><time class="references_datetime js-dateTimeView" datetime="2016-05-13T17:04:53+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/64261a67081d49f941e3#_reference-5da83fc474dcf3038086"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Java 再帰下降構文解析 超入門</a><time class="references_datetime js-dateTimeView" datetime="2016-05-16T05:36:32+00:00">10 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/04c2991239894687ef2f#_reference-cda7d4070f557fe023de"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />JSONパーサーを作る</a><time class="references_datetime js-dateTimeView" datetime="2016-12-26T13:38:03+00:00">2 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/KIchiro/items/6b676904802eff87b5da#_reference-4e9f7e34dc1aa2921d85"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/110035/profile-images/1473711079" />[Javaの小枝] 再帰下降構文解析のためのパーサコンビネータを作る(メモ化も行なう)</a><time class="references_datetime js-dateTimeView" datetime="2017-01-11T04:12:05+00:00">about 2 months ago</time></li></ul><div class="itemsShowBody_articleColumnFooter"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="Java パーサコンビネータ 超入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/68228e19552c271bea81" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="Java パーサコンビネータ 超入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/68228e19552c271bea81" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/68228e19552c271bea81" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/68228e19552c271bea81" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div></div><div class="itemsShowComment_wrapper" id="comments"><div data-react-class="T.CommentListContainer" data-react-props="{&quot;currentUser&quot;:null,&quot;initialComments&quot;:[],&quot;monthly_public_image_uploadable_size_limit&quot;:null,&quot;total_uploaded_public_image_size_in_current_month&quot;:null,&quot;item&quot;:{&quot;id&quot;:391912,&quot;uuid&quot;:&quot;68228e19552c271bea81&quot;,&quot;suspended&quot;:false,&quot;secret&quot;:false},&quot;owner&quot;:{&quot;url_name&quot;:&quot;7shi&quot;},&quot;is_team&quot;:false,&quot;is_project&quot;:false,&quot;logged_in&quot;:false,&quot;polling&quot;:false,&quot;mention_candidates&quot;:[{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}]}">Comments Loading...</div></div></div></div></div></article><div class="js-report-form modal fade reportForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Report article</h4></div><div class="modal-body"><form action="/reports" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="lX11iTy6znbyszzGYHFoEVB1Ac1YYfGldMj7HKxwK477/+7Rp5T3PQ1gidoQhNZIMDIlfs+lq1JIFvLnTX4lSA==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/68228e19552c271bea81" /><input type="hidden" name="item_uuid" id="item_uuid" value="68228e19552c271bea81" /><p>Help us understand the problem. What is going on with this item?</p><br /><div class="form-group"><ul class="list-unstyled"><li><label><input type="radio" name="report_type" id="report_type_spam" value="spam" required="required" /> It&#39;s spam </label></li><li><label><input type="radio" name="report_type" id="report_type_harassment" value="harassment" required="required" /> It&#39;s abusive or harmful </label></li><li><label><input type="radio" name="report_type" id="report_type_inappropriate_content" value="inappropriate_content" required="required" /> It contains inappropriate content </label></li></ul></div><div class="reportForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary reportForm_submitButton"><i class="fa fa-send"></i> Submit</button></div></form></div></div></div></div><script id="js-item" type="application/json">{ "url": "http://qiita.com/7shi/items/68228e19552c271bea81", "id": 391912, "uuid": "68228e19552c271bea81" }</script><script class="js-user" type="application/json">{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}</script><script language="JavaScript" src="//cdn.bigmining.com/private/js/qiita_bigmining.js" type="text/javascript"></script></div><footer class="footer"><div class="footer_inner"><div class="footer_container"><ul class="footer_links-left"><li class="footer_link"><a class="footer_copyright" href="http://increments.co.jp">© 2011-2017 Increments Inc.</a></li><li class="footer_link"><a href="http://qiita.com/terms">Terms</a></li><li class="footer_link"><a href="http://qiita.com/privacy">Privacy</a></li><li class="footer_link"><a href="http://help.qiita.com">Help</a></li><li class="footer_link"><a href="https://increments.zendesk.com/anonymous_requests/new">Contact</a></li></ul><ul class="footer_links-right"><li class="footer_link"><a href="http://qiita.com/about">About</a></li><li class="footer_link"><a href="/users">Users</a></li><li class="footer_link"><a href="/tags">Tags</a></li><li class="footer_link"><a href="http://blog.qiita.com">Blog</a></li><li class="footer_link"><a href="http://qiita.com/api/v2/docs">API</a></li><li class="footer_link"><a href="https://teams.qiita.com/">Team</a></li><li class="footer_link"><a href="http://kobito.qiita.com">Kobito</a></li><li class="footer_link"><a class="js-public-form-feedback-link" data-target=".js-feedback-form" data-toggle="modal" href=""><i class="fa fa-heart"></i> Feedback <i class="fa fa-caret-down"></i></a></li></ul></div></div></footer><div class="js-feedback-form modal fade feedbackForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Feedback</h4></div><div class="modal-body"><form class="js-feedback-form-form" action="/feedbacks" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="okPt67/SSrYxzAprl5SHn80hJx9F6biOk6K2zext3jfMwXazJPxz/c4fv3fnYTnGrWYDrNIt4nmvfL82DWPQ8Q==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/68228e19552c271bea81" /><div class="form-group"><textarea name="feedback[message]" id="feedback_message" class="form-control js-feedback-form-text-area" placeholder="Please give us any feedback about Qiita." required="required" rows="5">
</textarea></div><div class="feedbackForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary feedbackForm_submitButton"><i class="fa fa-send"></i> Submit</button><p class="feedbackForm_note">We don&#39;t reply to any feedback.<br />If you need help with Qiita, please send a support request from <a href="https://increments.zendesk.com/anonymous_requests/new">here</a>.</p></div><div style="position:fixed;top:-99999px;opacity:0.0001;"><input name="feedback[name]" type="text" /></div></form></div></div></div></div><script>// if (window.mixpanel instanceof Element) {
//   window.mixpanel = [];
// }
// (function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
// for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);</script><script src="http://cdn.qiita.com/assets/public-8c6201a66dc6db6f64a9017391c319bf.min.js"></script><script>
  (function () {
    var script = document.getElementsByTagName('script')[0];
    var load = function (src, id) {
      var el = document.createElement('script');
      el.async = true;
      el.src = src;
      el.id = id;
      script.parentNode.insertBefore(el, script);
    };
      // Optimizely
      load('//cdn.optimizely.com/js/52738645.js', 'optimizely-jssdk');
      // Google Analytics
      window._gaq = window._gaq || [];
      var isCareer = location.hostname.split('.')[0] == 'career';
      if (isCareer) {
        window._gaq.push(['_setAccount', 'UA-24675221-11']);
        window._gaq.push(['_setDomainName', 'qiita.com']);
      } else {
        window._gaq.push(['_setAccount', 'UA-24675221-1']);
      }
      window._gaq.push(['_setCustomVar', 1, 'logged_in', 'false', 2]);
      window._gaq.push(['_trackPageview']);
      var src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      load(src, 'google-analytics-jssdk');
    // Google Analytics - Universal Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-24675221-12', {
          
        });
        ga('set', 'dimension1', 'false');
        ga('set', 'dimension3', 'false');
      ga('require', 'displayfeatures');
      ga('set', 'forceSSL', true);
      ga('send', 'pageview');
    // Google Tag Manager
      (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-TBQWPN');
  })();
</script>
</body></html>