<!DOCTYPE html><html xmlns:og="http://ogp.me/ns#"><head><meta charset="UTF-8" /><title>Haskellで学ぶF#入門 - Qiita</title><meta content="width=device-width,initial-scale=1" name="viewport" /><meta content="Haskellと比較しながらF#を説明します。練習では再帰に慣れることに重点を置きます。再帰によるリスト処理の例として各種ソート（挿入ソート、バブルソート、マージソート、クイックソート）を紹介します。

※ 一応、Haskellは飛ばしてF#だけでも読めるようには配慮したつもりです。Haskellがよく分からなければ飛ばして読んでみてください。

この記事はHaskellの記事をベースにしています。



Haskell 超入門 2014.08.20


練習の解答例は..." name="description" /><meta content="summary" name="twitter:card" /><meta content="@Qiita" name="twitter:site" /><meta content="7shi" name="twitter:creator" /><meta content="Haskellで学ぶF#入門 - Qiita" property="og:title" /><meta content="article" property="og:type" /><meta content="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" property="og:url" /><meta content="http://cdn.qiita.com/assets/qiita-fb-2887e7b4aad86fd8c25cea84846f2236.png" property="og:image" /><meta content="Haskellと比較しながらF#を説明します。練習では再帰に慣れることに重点を置きます。再帰によるリスト処理の例として各種ソート（挿入ソート、バブルソート、マージソート、クイックソート）を紹介します。

※ 一応、Haskellは飛ば..." property="og:description" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><link rel="shortcut icon" type="image/x-icon" href="http://cdn.qiita.com/assets/favicons/public/production-4ff10c1e1e2b5fcb353ff9cafdd56c70.ico" /><link rel="apple-touch-icon" type="image/png" href="http://cdn.qiita.com/assets/favicons/public/apple-touch-icon-f9a6afad761ec2306e10db2736187c8b.png" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link rel="stylesheet" media="all" href="http://cdn.qiita.com/assets/public-e8d29e8ff1879118096f0f5877946857.min.css" /><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="HX4nQyxw4py9ajsyQSwbtcJQWQ53Dfz+Xp9UDb0Xcctz/Lwbt17b10K5ji4x2aXsohd9veDJpgliQV32XBl/DQ==" /></head><body class="without-js" id=""><noscript><iframe height="0" src="//www.googletagmanager.com/ns.html?id=GTM-TBQWPN" style="display:none;visibility:hidden" width="0"></iframe></noscript><script>
  document.body.className = document.body.className.replace('without-js', '') + ' with-js';
  window.Qiita = {"asset_host":"cdn.qiita.com","TLD":"com","controller_path":"public/items","controller_action":"public/items#show","controller":"items","action":"show","env":"production","flash":{},"is_landing_page":false,"is_team_page":false,"root_domain":"qiita.com","variant":null,"config":{"mixpanel":{"career":"dd35af27e959781713d63fd7ca898a8d","per_team":"c0a2116368b33b44b5029ebd2cc9b094","public":"be87616606b0e26a87689099aab2c4e5","team":"b7c0342acba2dbc8742484d98788efb3"},"default_locale":"ja","locale":"en"},"team":null,"user":null,"GIT_BRANCH":null,"DEBUG":false};

</script>
<div class="headerContainer headerContainer-public" role="navigation"><div data-react-class="T.HeaderContainer" data-react-props="{&quot;user&quot;:null,&quot;team&quot;:null,&quot;news&quot;:{&quot;type&quot;:&quot;募集&quot;,&quot;content&quot;:&quot;QiitaやQiita:Teamを良くしたいエンジニア&quot;,&quot;url&quot;:&quot;http://increments.co.jp/jobs/engineers?utm_source=qiita\u0026utm_medium=header_news&quot;},&quot;initial_unread_count&quot;:null,&quot;siteid_image&quot;:&quot;http://cdn.qiita.com/siteid-reverse.png&quot;,&quot;is_team_page&quot;:false,&quot;on_team_setting&quot;:false,&quot;show_post_menu&quot;:true,&quot;show_search_menu&quot;:true,&quot;is_fluid&quot;:false,&quot;locale&quot;:&quot;en&quot;}"></div></div><div id="main"><ol class="itemBreadcrumbs" itemscope="" itemtype="http://schema.org/BreadcrumbList"><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/"><span itemprop="name">Qiita</span></a><meta content="1" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/items"><span itemprop="name">Items</span></a><meta content="2" itemprop="position" /></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="/tags/F%23"><span itemprop="name">F#</span></a><meta content="3" itemprop="position" /></li></ol><article itemscope="" itemtype="http://schema.org/Article"><div class="ArticleMainHeader "><div class="container"></div><div class="container"><div class="row s-flex-align-center"><div class="col-sm-9"><h1 class="ArticleMainHeader__title">Haskellで学ぶF#入門</h1><ul class="TagList"><li class="TagList__item" data-count="160"><a class="u-link-unstyled TagList__label" href="/tags/F%23"><img alt="F#" class="TagList__icon" src="https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/ba95a660afc4ec92093e69afbd0b70d04e51245b/medium.jpg?1395581508" /><span>F#</span></a></li><li class="TagList__item" data-count="1345"><a class="u-link-unstyled TagList__label" href="/tags/Haskell"><img alt="Haskell" class="TagList__icon" src="https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/373b3b0595a92712b2a45616f53dae97bc1a04e5/medium.jpg?1387913155" /><span>Haskell</span></a></li></ul></div><div class="col-sm-3"><div class="itemsShowHeaderStock"><ul class="list-unstyled itemsShowHeaderStock_statusList"><li><div class="itemsShowHeaderStock_count stock"><span class="fa fa-thumbs-up"></span><span class="js-likecount">6</span></div><div class="itemsShowHeaderStock_countText">Like</div></li><li><div class="itemsShowHeaderStock_count" content="0 UserComments" itemprop="interactionCount"><span class="fa fa-comment"></span>0</div><div class="itemsShowHeaderStock_countText">Comment</div></li></ul></div><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:6,&quot;uuid&quot;:&quot;1d3750ba17f5a88b8405&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-header&quot;}"></div><ul class="list-inline ArticleMainHeader__users"><li class="js-hovercard" data-hovercard-target-name="chocolamint"><a itemprop="url" href="/chocolamint"><img alt="chocolamint" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/11978/profile-images/1473682231" /></a></li><li class="js-hovercard" data-hovercard-target-name="knknkn1162"><a itemprop="url" href="/knknkn1162"><img alt="knknkn1162" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/133922/profile-images/1473719133" /></a></li><li class="js-hovercard" data-hovercard-target-name="ozwk"><a itemprop="url" href="/ozwk"><img alt="ozwk" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/72075/profile-images/1473699037" /></a></li><li class="js-hovercard" data-hovercard-target-name="Mizunashi_Mana"><a itemprop="url" href="/Mizunashi_Mana"><img alt="Mizunashi_Mana" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/138118/profile-images/1483788351" /></a></li><li class="js-hovercard" data-hovercard-target-name="tgok"><a itemprop="url" href="/tgok"><img alt="tgok" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/40485/profile-images/1473688453" /></a></li><li class="js-hovercard" data-hovercard-target-name="akumavideo"><a itemprop="url" href="/akumavideo"><img alt="akumavideo" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/31675/profile-images/1478447306" /></a></li></ul></div></div></div></div><div class="ArticleAsideHeader"><div class="container"><div class="u-flex u-space-between"><div class="u-flex u-flex-wrap"><div class="u-flex u-align-center s-pdv-5 u-flex-wrap"><div class="ArticleAsideHeader__author"><a href="/7shi"><img class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" alt="1473685823" /></a> <a class="u-link-unstyled" href="/7shi">7shi</a> </div><div class="ArticleAsideHeader__date"><span data-toggle="tooltip" title="posted at 2017-01-11">Edited at <time datetime="2017-01-11T18:47:55+09:00" itemprop="dateModified">2017-01-11</time></span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"><div class="ArticleAsideHeader__revision"> <a data-toggle="tooltip" title="Revisions" href="/7shi/items/1d3750ba17f5a88b8405/revisions"><span class="fa fa-history"></span></a><span class="ArticleAsideHeader__revisionCount">2</span></div></div><div class="u-flex u-align-center s-pdv-5 mobile-hidden"></div></div><div class="u-flex u-align-center s-flex-justiry-between s-pdv-5 u-shrink-0"><div class="ArticleAsideHeader__stock"><div class="js-stockbutton" data-position="top" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h fa-lg"></span></a><ul class="dropdown-menu dropdown-menu-right"><li class="dropdown__item--mobile"><a href="/7shi/items/1d3750ba17f5a88b8405/revisions"><span class="fa fa-fw fa-history"></span> Revisions<span>(2)</span></a></li><li><a href="/7shi/items/1d3750ba17f5a88b8405.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><span class="fa fa-fw fa-flag"></span> Report article</a></li></ul></div></div></div></div></div><div class="container"><div class="row" id="article-body-wrapper"><div class="col-sm-9"><section class="markdownContent markdownContent-headingEnabled js-task-list-container clearfix position-relative" id="item-1d3750ba17f5a88b8405" itemprop="articleBody"><p>Haskellと比較しながらF#を説明します。練習では再帰に慣れることに重点を置きます。再帰によるリスト処理の例として各種ソート（挿入ソート、バブルソート、マージソート、クイックソート）を紹介します。</p>

<p>※ 一応、Haskellは飛ばしてF#だけでも読めるようには配慮したつもりです。Haskellがよく分からなければ飛ばして読んでみてください。</p>

<p>この記事はHaskellの記事をベースにしています。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/145f1234f8ec2af923ef" id="reference-00c8d661f6137bc6c0c2">Haskell 超入門</a> 2014.08.20</li>
</ul>

<p>練習の解答例は別記事に掲載します。</p>

<ul>
<li><a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc" id="reference-cb69102bde082ad5402c">【解答例】Haskellで学ぶF#入門</a></li>
</ul>

<p>この記事には姉妹編があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/ff746903680ae8d0d7ce" id="reference-7bb14d4b8db714b3b354">C#/JavaScriptで学ぶF#入門</a> 2017.01.04</li>
</ul>

<p>この記事には関連記事があります。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/92139286a4e9b5620d69" id="reference-878afa4aa3903188c416">doブロックとコンピュテーション式</a> 2016.07.01</li>
<li>
<a href="http://qiita.com/7shi/items/7f490819e818dd7aa37c" id="reference-9ea280960401214e1796">functionのインデント</a> 2016.12.14</li>
</ul>

<p>F#を手っ取り早く試すために、私が常用している環境を紹介します。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/5fc7d6477d96bbd7a71d" id="reference-0d03017a9de4c3b61212">F#開発環境の紹介</a> 2016.12.30</li>
</ul>

<h1>
<span id="ハローワールド" class="fragment"></span><a href="#%E3%83%8F%E3%83%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89"><i class="fa fa-link"></i></a>ハローワールド</h1>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    putStrLn "Hello, World!"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "Hello, World!"
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
Hello, World!
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
Hello, World!
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="エントリーポイント" class="fragment"></span><a href="#%E3%82%A8%E3%83%B3%E3%83%88%E3%83%AA%E3%83%BC%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88"><i class="fa fa-link"></i></a>エントリーポイント</h2>

<p>F#は処理をいきなり書き始めることができるため、<code>main</code>は必須ではありません。もし必要であれば<code>[&lt;EntryPoint&gt;]</code>属性を添えて関数を書きます。関数名は任意で<code>main</code>でなくても構いませんが、引数と戻り値は必須です。C言語と比較します。</p>

<table>
<tr>
<th>C言語</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    printf("Hello, World!\n");
    return 0;
}
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
[&lt;EntryPoint&gt;]
let main args =
    printfn "Hello, World!"
    0
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
Hello, World!
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
Hello, World!
</pre></div></div>
</td>
</tr>
</table>

<p>F#は<code>[&lt;EntryPoint&gt;]</code>に<code>do</code>ブロックを組み合わせることで、引数や戻り値が省略可能です。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="o">[&lt;</span><span class="n">EntryPoint</span><span class="o">&gt;]</span>
<span class="k">do</span>
    <span class="n">printfn</span> <span class="s">"Hello, World!"</span>
</pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
Hello, World!
</pre></div>
</div>

<p>簡単のため、以後の例ではエントリーポイントなしで処理を書きます。</p>

<h2>
<span id="do" class="fragment"></span><a href="#do"><i class="fa fa-link"></i></a>do</h2>

<p>Haskellは<code>do</code>ブロック内では文法が変わりますが、F#の<code>do</code>ではそういったことはありません。F#の<code>do</code>はC言語などの<code>{}</code>と同じようにブロックを表します。</p>

<p>F#でHaskellの<code>do</code>ブロックに相当するのはコンピュテーション式です。詳細は次の記事を参照してください。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/92139286a4e9b5620d69">doブロックとコンピュテーション式</a> 2016.07.01</li>
</ul>

<p>Haskellでは連続出力に<code>do</code>が必須ですが、F#ではそういった制約はありません。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    putStrLn "Hello, World!"
    putStrLn "Hello, World!"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "Hello, World!"
printfn "Hello, World!"
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
Hello, World!
Hello, World!
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
Hello, World!
Hello, World!
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="printf" class="fragment"></span><a href="#printf"><i class="fa fa-link"></i></a>printf</h2>

<p>Haskellの<code>print</code>はShowのインスタンスを受け付けます。F#ではフォーマットに<code>%A</code>を指定すれば任意の型を受け付けます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print 1
    print "abc"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" 1
printfn "%A" "abc"
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
"abc"
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
"abc"
</pre></div></div>
</td>
</tr>
</table>

<p>F#では<code>%d</code>などの型に紐付けられたフォーマットを指定すればコンパイラで型がチェックされるため、フォーマットでサポートされている型は個別に指定した方が無難です。</p>

<h1>
<span id="束縛" class="fragment"></span><a href="#%E6%9D%9F%E7%B8%9B"><i class="fa fa-link"></i></a>束縛</h1>

<p>F#の変数（識別子）は後で別の値を再代入することができません。そのため代入ではなく<strong>束縛</strong>という用語を使います。</p>

<h2>
<span id="let" class="fragment"></span><a href="#let"><i class="fa fa-link"></i></a>let</h2>

<p>F#ではトップレベルやローカルの区別なく、束縛には常に<code>let</code>が必要です。</p>

<p>※ Haskellの<code>where</code>に相当するキーワードはありません。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
a = 1
b = 2

main = do
    let c = a + b
    print c
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1
let b = 2

do
    let c = a + b
    printfn "%d" c
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
3
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
3
</pre></div></div>
</td>
</tr>
</table>

<h1>
<span id="関数" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>関数</h1>

<p>数学の $f(x)=x+1$ や $f(1)$ の括弧がない版だとイメージしてください。C言語の<code>return</code>に相当するキーワードは使いません。</p>

<p>※ <code>return</code>は存在しますが別の意味です。詳細は<a href="http://qiita.com/7shi/items/92139286a4e9b5620d69">doブロックとコンピュテーション式</a>を参照してください。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
f x = x + 1
a = f 1

main = do
    print a
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let f x = x + 1
let a = f 1

printfn "%d" a
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
</pre></div></div>
</td>
</tr>
</table>

<p><code>a</code>を経由せずに<code>printfn</code>に直接<code>f 1</code>を渡すには、括弧で囲みます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
f x = x + 1

main = do
    print (f 1)
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let f x = x + 1

printfn "%d" (f 1)
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="パイプライン演算子" class="fragment"></span><a href="#%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E6%BC%94%E7%AE%97%E5%AD%90"><i class="fa fa-link"></i></a>パイプライン演算子</h2>

<p>閉じ括弧の省略にはパイプライン演算子<code>&lt;|</code>が使えます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print (f 1)
    print $ f 1
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" (f 1)
printfn "%d" &lt;| f 1
</pre></div></div></td>
</tr>
</table>

<p>連続で使用した場合、<code>&lt;|</code>はHaskellの<code>$</code>とは挙動が異なるので注意が必要です。F#でHaskellの挙動を真似するには<code>&lt;&lt;</code>による関数合成と併用する必要があります。対応を示します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ abs $ 3 - 5
    let a = atan2 (sqrt 2) (sqrt 3)
    print a
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" &lt;&lt; abs &lt;| 3 - 5
let a = atan2 &lt;| sqrt 2. &lt;| sqrt 3.
printfn "%f" a
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
0.684719203002283
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
0.684719
</pre></div></div>
</td>
</tr>
</table>

<p>逆向きの <code>|&gt;</code> もあります。連続して使用すれば、関数の多重ネストをシェルのパイプのように記述できます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%d"</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">5</span><span class="o">))</span>
<span class="mi">3</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">|&gt;</span> <span class="n">abs</span> <span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s">"%d"</span>
</pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
2
2
</pre></div>
</div>

<h2>
<span id="関数の演算子化" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E3%81%AE%E6%BC%94%E7%AE%97%E5%AD%90%E5%8C%96"><i class="fa fa-link"></i></a>関数の演算子化</h2>

<p>F#ではHaskellのように関数を演算子として使うことはできません。</p>

<div class="code-frame" data-lang="hs">
<div class="code-lang"><span class="bold">Haskell</span></div>
<div class="highlight"><pre>
<span class="nf">add</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span>
    <span class="n">print</span> <span class="o">$</span> <span class="mi">1</span> <span class="p">`</span><span class="n">add</span><span class="p">`</span> <span class="mi">2</span>  <span class="c1">-- 関数の演算子化</span>
</pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
3
3
</pre></div>
</div>

<h2>
<span id="演算子の関数化" class="fragment"></span><a href="#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E9%96%A2%E6%95%B0%E5%8C%96"><i class="fa fa-link"></i></a>演算子の関数化</h2>

<p>中置演算子を<code>()</code>で囲むと関数として使用できます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ 1 + 2
    print $ (+) 1 2
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" &lt;| 1 + 2
printfn "%d" &lt;| (+) 1 2
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
3
3
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
3
3
</pre></div></div>
</td>
</tr>
</table>

<h1>
<span id="四則演算" class="fragment"></span><a href="#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97"><i class="fa fa-link"></i></a>四則演算</h1>

<p>F#で割り算で小数点以下を扱う場合は、オペランドを明示的に浮動小数点数で記述します。Haskellのような <code>/</code> と <code>div</code> の区別はありません。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ 5 + 2
    print $ 5 - 2
    print $ 5 * 2
    print $ 5 / 2
    print $ div 5 2
    print $ mod 5 2
    print $ 5 `div` 2
    print $ 5 `mod` 2
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" &lt;| 5 + 2
printfn "%d" &lt;| 5 - 2
printfn "%d" &lt;| 5 * 2
printfn "%f" &lt;| 5. / 2.
printfn "%d" &lt;| (/) 5 2
printfn "%d" &lt;| (%) 5 2
printfn "%d" &lt;| 5 / 2
printfn "%d" &lt;| 5 % 2
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
7
3
10
2.5
2
1
2
1
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
7
3
10
2.500000
2
1
2
1
</pre></div></div>
</td>
</tr>
</table>

<h1>
<span id="命名規則" class="fragment"></span><a href="#%E5%91%BD%E5%90%8D%E8%A6%8F%E5%89%87"><i class="fa fa-link"></i></a>命名規則</h1>

<p>Haskellとは異なり変数や関数を大文字で始めてもエラーにはなりませんが、慣習的に小文字で始めます。</p>

<h1>
<span id="if---then---else" class="fragment"></span><a href="#if---then---else"><i class="fa fa-link"></i></a>if - then - else</h1>

<p>まず、一行で書いてみます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
a = 1

main = do
    if a == 1 then print "1" else print "?"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1

if a = 1 then printfn "1" else printfn "?"
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
"1"
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
</pre></div></div>
</td>
</tr>
</table>

<p>※ 「等しい」は<code>=</code>、「等しくない」は<code>&lt;&gt;</code>です。</p>

<p>複数行で書く場合のインデントにはある程度のバリエーションがありますが、よく使われるパターンを示します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
a = 1

main = do
    if a == 1
        then print "1"
        else print "?"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1

if a = 1 then
    printfn "1"
else
    printfn "?"
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
"1"
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
</pre></div></div>
</td>
</tr>
</table>

<p>※ F#の<code>else</code>はインデントで特別なルールがありますが、書き方が複数あると混乱するため説明を省略します。</p>

<h2>
<span id="値を返す" class="fragment"></span><a href="#%E5%80%A4%E3%82%92%E8%BF%94%E3%81%99"><i class="fa fa-link"></i></a>値を返す</h2>

<p><code>if</code>は値を返すため、C言語の三項演算子のように使えます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
a = 1

main = do
    print $ if a == 1 then "1" else "?"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let a = 1

printfn "%s" &lt;| if a = 1 then "1" else "?"
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
"1"
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
</pre></div></div>
</td>
</tr>
</table>

<p>関数の定義と組み合わせた例です。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
f a = if a == 1 then "1" else "?"

main = do
    print $ f 0
    print $ f 1
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let f a = if a = 1 then "1" else "?"

printfn "%s" &lt;| f 0
printfn "%s" &lt;| f 1
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
"?"
"1"
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
?
1
</pre></div></div>
</td>
</tr>
</table>

<h1>
<span id="関数のパターンマッチ" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81"><i class="fa fa-link"></i></a>関数のパターンマッチ</h1>

<p>関数内の全体を<code>if</code>で切り分ける代わりに、<code>function</code>キーワードで引数を振り分けられます。このような書き方を<strong>パターンマッチ</strong>と呼びます。</p>

<p>※ Haskellのように関数を複数定義するような形にはしません。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
f 1 = "1"
f a = "?"

main = do
    print $ f 0
    print $ f 1
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let f = function
| 1 -&gt; "1"
| a -&gt; "?"

printfn "%s" &lt;| f 0
printfn "%s" &lt;| f 1
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
"?"
"1"
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
?
1
</pre></div></div>
</td>
</tr>
</table>

<p>値を無視する引数は<code>_</code>と書くことで、値を無視していることを明示します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
f 1 = "1"
f _ = "?"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let f = function
| 1 -&gt; "1"
| _ -&gt; "?"
</pre></div></div></td>
</tr>
</table>

<p>これは独特な書き方のため、慣れが必要です。</p>

<h2>
<span id="階乗" class="fragment"></span><a href="#%E9%9A%8E%E4%B9%97"><i class="fa fa-link"></i></a>階乗</h2>

<p>例としてよく引き合いに出されます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
fact 0 = 1
fact n = n * fact (n - 1)

main = do
    print $ fact 5
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let rec fact = function
| 0 -&gt; 1
| n -&gt; n * fact (n - 1)

printfn "%d" &lt;| fact 5
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
120
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
120
</pre></div></div>
</td>
</tr>
</table>

<p><code>fact</code>の中で<code>fact</code>を呼んでいます。このような流れを<strong>再帰</strong>と言います。再帰関数には<code>rec</code>キーワードを付けます。<code>rec</code>を付けなければ自分が参照できずにエラーになります。</p>

<p>※ デフォルトで再帰可能になっていないのは、同名の変数で覆い隠すシャドウイングを考慮した言語設計のようです。F#の元になったOCamlについての記事を紹介します。</p>

<ul>
<li>
<a href="https://twitter.com/camlspotter" rel="nofollow noopener" target="_blank">@camlspotter</a>: <a href="http://d.hatena.ne.jp/camlspotter/20110509/1304933919" rel="nofollow noopener" target="_blank">OCaml の let と let rec はなぜ別扱いになっているのか、決定版、もしくは OCaml 暦十何年だったか忘れたけど仕事で Haskell を一年使ってみた - Oh, you `re no (fun _ → more)</a> 2011.05.09</li>
</ul>

<p>再帰は往復で処理されるため往路と復路に分けて考えます。</p>

<p>再帰の往路をトレースします。</p>

<ol>
<li><code>| 5 -&gt; 5 * fact 4</code></li>
<li><code>| 4 -&gt; 4 * fact 3</code></li>
<li><code>| 3 -&gt; 3 * fact 2</code></li>
<li><code>| 2 -&gt; 2 * fact 1</code></li>
<li><code>| 1 -&gt; 1 * fact 0</code></li>
<li><code>| 0 -&gt; 1</code></li>
</ol>

<p><code>| 0 -&gt; 1</code>が折り返し点となり、反転して復路に入ります。</p>

<ol>
<li><code>| 1 -&gt; 1 * fact 0 = 1 * 1 = 1</code></li>
<li><code>| 2 -&gt; 2 * fact 1 = 2 * 1 = 2</code></li>
<li><code>| 3 -&gt; 3 * fact 2 = 3 * 2 = 6</code></li>
<li><code>| 4 -&gt; 4 * fact 3 = 4 * 6 = 24</code></li>
<li><code>| 5 -&gt; 5 * fact 4 = 5 * 24 = 120</code></li>
</ol>

<p>※ 往路だけで復路のない末尾再帰もありますが、今回の範囲を超えるため省略します。</p>

<h3>
<span id="簡約" class="fragment"></span><a href="#%E7%B0%A1%E7%B4%84"><i class="fa fa-link"></i></a>簡約</h3>

<p>往路をインライン展開すると次のように捉えることができます。</p>

<ol>
<li><code>fact 5</code></li>
<li><code>5 * fact 4</code></li>
<li><code>5 * 4 * fact 3</code></li>
<li><code>5 * 4 * 3 * fact 2</code></li>
<li><code>5 * 4 * 3 * 2 * fact 1</code></li>
<li><code>5 * 4 * 3 * 2 * 1 * fact 0</code></li>
<li><code>5 * 4 * 3 * 2 * 1 * 1</code></li>
<li><code>120</code></li>
</ol>

<p>このような式変形を<strong>簡約</strong>と呼びます。</p>

<h3>
<span id="基底部再帰部" class="fragment"></span><a href="#%E5%9F%BA%E5%BA%95%E9%83%A8%E5%86%8D%E5%B8%B0%E9%83%A8"><i class="fa fa-link"></i></a>基底部・再帰部</h3>

<p>折り返し点となる定義を基底部、自分自身を呼び出している定義を再帰部と呼びます。</p>

<ul>
<li>基底部: <code>| 0 -&gt; 1</code>
</li>
<li>再帰部: <code>| n -&gt; n * fact (n - 1)</code>
</li>
</ul>

<h2>
<span id="コツ" class="fragment"></span><a href="#%E3%82%B3%E3%83%84"><i class="fa fa-link"></i></a>コツ</h2>

<p>再帰の取り扱いにはパターンがあります。そこを意識するのがコツです。</p>

<h3>
<span id="作り方のコツ" class="fragment"></span><a href="#%E4%BD%9C%E3%82%8A%E6%96%B9%E3%81%AE%E3%82%B3%E3%83%84"><i class="fa fa-link"></i></a>作り方のコツ</h3>

<ol>
<li>基底部を定義</li>
<li>具体例に当てはめて一般化する</li>
</ol>

<p>まず基底部を定義します。自然数を指定するタイプでは値が減少しながら再帰を繰り返すのが定石で、これ以上減少できない最小値が基底部となります。</p>

<p>階乗について考えます。マイナスの階乗が定義されていないため、計算可能な最小の階乗は $0!$ です。このことから基底部を定義します。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">基底部</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">rec</span> <span class="n">fact</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
</pre></div>
</div>

<p>再帰部は具体例を通して考えるのがコツです。たとえば5の階乗を考えます。</p>

<div class="code-frame" data-lang="math">
<div class="code-lang"><span class="bold">具体例</span></div>
<div class="highlight"><pre>
5! = 5 × 4 × 3 × 2 × 1
</pre></div>
</div>

<p>再帰は引数を5から0に向かって減少させて処理します。1つ小さい引数（この場合は4）の結果を利用するのが定石です。このパターンで表すため、5の階乗を4の階乗で表せないか考えます。</p>

<div class="code-frame" data-lang="math">
<div class="code-lang"><span class="bold">式変形</span></div>
<div class="highlight"><pre>
5! = 5 × (4 × 3 × 2 × 1) = 5 × 4!
</pre></div>
</div>

<p>特定の数（この場合は5）での関係が得られました。これを一般化して5を$n$に置き換えます。4は$n-1$です。このように隣接する項目との関係で表された式を<a href="http://ja.wikipedia.org/wiki/%E6%BC%B8%E5%8C%96%E5%BC%8F" rel="nofollow noopener" target="_blank">漸化式</a>と呼びます。</p>

<div class="code-frame" data-lang="math">
<div class="code-lang"><span class="bold">漸化式</span></div>
<div class="highlight"><pre>
n! = n × (n-1)!
</pre></div>
</div>

<p>漸化式をコード化すれば再帰部が得られます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fact再帰部</span></div>
<div class="highlight"><pre>
<span class="o">|</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>

<p>このように基底部と再帰部は順を追って別々に作ることになるため、パターンマッチで分岐する書き方と相性が良いです。</p>

<p>※ 数学の問題であれば得られた式を<a href="http://ja.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%9A%84%E5%B8%B0%E7%B4%8D%E6%B3%95" rel="nofollow noopener" target="_blank">数学的帰納法</a>で証明することが求められますが、今回はプログラミングの練習が目的なので、いくつか具体例で動作確認して済ませます。</p>

<h3>
<span id="確認のコツ" class="fragment"></span><a href="#%E7%A2%BA%E8%AA%8D%E3%81%AE%E3%82%B3%E3%83%84"><i class="fa fa-link"></i></a>確認のコツ</h3>

<p>一旦書き上げたプログラムを確認するコツです。既存のコードを読むときにも使えます。</p>

<p>再帰の流れは追わずに、結果が信頼できるものと見なして具体例で考えます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">fact再帰部</span></div>
<div class="highlight"><pre>
<span class="o">|</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>

<ol>
<li><code>| 5 -&gt; 5 * fact 4</code></li>
<li>
<code>fact 4</code>は定義より<code>4! = 24</code>が返されると考えます。</li>
<li><code>5 * 24 = 120</code></li>
</ol>

<p>次に再帰を使った練習問題をやるので、この方法を試してみてください。</p>

<h2>
<span id="練習" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92"><i class="fa fa-link"></i></a>練習</h2>

<p>フィボナッチ数は<code>0, 1</code>が初期値として与えられ、それ以降は前2つの数字を合計して得られる数列です。</p>

<ul>
<li>0, 1, 1, 2, 3, 5, 8, 13, 21, ...</li>
</ul>

<p>【問1】任意のn番目のフィボナッチ数を計算する関数<code>fib</code>をパターンマッチで実装してください。最初の0は0番目とします。</p>

<p>ヒント: 基底部は1つとは限りません。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h1>
<span id="ガード" class="fragment"></span><a href="#%E3%82%AC%E3%83%BC%E3%83%89"><i class="fa fa-link"></i></a>ガード</h1>

<p>パターンマッチに<code>when</code>で条件を付加するガードという書き方があります。</p>

<p>上で実装した<code>fact</code>に負の数を渡すと無限ループになります。対策としてガードを追加して引数を制限します。</p>

<p>※ マイナスの階乗は数学的に定義されていないので、弾いても問題ありません。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
fact 0 = 1
fact n | n &gt; 0 = n * fact (n - 1)

main = do
    print $ fact 5
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let rec fact = function
| 0 -&gt; 1
| n when n &gt; 0 -&gt; n * fact (n - 1)

printfn "%d" &lt;| fact 5
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
120
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
120
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="例外" class="fragment"></span><a href="#%E4%BE%8B%E5%A4%96"><i class="fa fa-link"></i></a>例外</h2>

<p>先ほどのコードは Imcomplete patter matches と警告されます。マイナスのときの処理が抜けているためです。</p>

<p>警告を消すため、残り全部の意味で <code>_</code>で受けて<code>failwith</code>で例外を発生させます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">rec</span> <span class="n">fact</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
<span class="o">|</span> <span class="n">n</span> <span class="k">when</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s">"&lt; 0"</span>
</pre></div>
</div>

<p>※ Haskellでは例外を使用するには構造を変える必要があるため、対応コードは省略します。Haskellで例外を使わずに処理する方法については<a href="http://qiita.com/7shi/items/c7d7eec066af0fe0688d#guard" id="reference-8aeeb5d60b98ee52e2ff">Haskell Maybeモナド 超入門</a>を参照してください。</p>

<h2>
<span id="練習-1" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-1"><i class="fa fa-link"></i></a>練習</h2>

<p>【問2】問1で実装した関数に、無限ループを防ぐためのガードを追加してください。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%82%AC%E3%83%BC%E3%83%89" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h1>
<span id="match" class="fragment"></span><a href="#match"><i class="fa fa-link"></i></a>match</h1>

<p>関数の中でパターンマッチを行うには <code>match</code> - <code>with</code> を使います。</p>

<p>※ Haskellとは異なり、F#では<code>function</code>も<code>match</code>も<code>-&gt;</code>を使います。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
fact n = case n of
    0 -&gt; 1
    _ | n &gt; 0 -&gt; n * fact (n - 1)

main = do
    print $ fact 5
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let rec fact n =
    match n with
    | 0 -&gt; 1
    | _ when n &gt; 0 -&gt; n * fact (n - 1)
    | _ -&gt; failwith "&lt; 0"

printfn "%d" &lt;| fact 5
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
120
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
120
</pre></div></div>
</td>
</tr>
</table>

<p>※ 引数で<code>n</code>として受けているため、<code>match</code>中のパターンマッチでは<code>_</code>として受け流しています。</p>

<p><code>function</code>は関数レベルの分岐のためインデントしませんでしたが、<code>match</code>は関数の中のためインデントが必須です。詳細は次の記事を参照してください。</p>

<ul>
<li>
<a href="http://qiita.com/7shi/items/7f490819e818dd7aa37c">functionのインデント</a> 2016.12.14</li>
</ul>

<h2>
<span id="練習-2" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-2"><i class="fa fa-link"></i></a>練習</h2>

<p>【問3】問2で実装した関数を<code>match</code>で書き直してください。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#match" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h1>
<span id="リスト" class="fragment"></span><a href="#%E3%83%AA%E3%82%B9%E3%83%88"><i class="fa fa-link"></i></a>リスト</h1>

<p>他言語の配列と似たようなものです。F#では要素は <code>;</code> で区切ります。慣れるまで間違えやすいので注意してください。</p>

<p>※ F#では <code>,</code> で区切ると意味が変わり、大抵の場合はエラーとなります。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print [1, 2, 3, 4, 5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" [1; 2; 3; 4; 5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5]
</pre></div></div>
</td>
</tr>
</table>

<p>※ F#ではリストとは別に配列もあります。今回はリストの使い方に慣れることを目的とするため、配列については省略します。</p>

<p>要素は改行によっても区切られます。実際には改行の方が基本で、改行せずに区切るのが <code>;</code> です。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%A"</span> <span class="o">[</span>
    <span class="mi">1</span>
    <span class="mi">2</span>
    <span class="mi">3</span>
    <span class="mi">4</span>
    <span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[1; 2; 3; 4; 5]
</pre></div>
</div>

<h2>
<span id="要素の取り出し" class="fragment"></span><a href="#%E8%A6%81%E7%B4%A0%E3%81%AE%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%97"><i class="fa fa-link"></i></a>要素の取り出し</h2>

<p>リストから要素を取り出すには<code>.[]</code>を使います。先頭の要素は0番目です。</p>

<p>※ 他の言語に慣れていると <code>.</code> が異様に映りますが、<code>[]</code>もオブジェクトのメソッドだということを示しています。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ [1, 2, 3, 4, 5] !! 3
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" [1; 2; 3; 4; 5].[3]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
4
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
4
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="連番" class="fragment"></span><a href="#%E9%80%A3%E7%95%AA"><i class="fa fa-link"></i></a>連番</h2>

<p>連番リストを生成する専用の書き方があります。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print [1..5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" [1..5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5]
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="連結" class="fragment"></span><a href="#%E9%80%A3%E7%B5%90"><i class="fa fa-link"></i></a>連結</h2>

<p><code>@</code>によりリスト同士を結合できます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ [1, 2, 3] ++ [4, 5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| [1; 2; 3] @ [4; 5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5]
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="" class="fragment"></span><a href="#"><i class="fa fa-link"></i></a>::</h2>

<p><code>::</code>によりリストの先頭に要素を挿入できます。</p>

<p>※ Haskellとは<code>:</code>と<code>::</code>の意味が逆なのに注意が必要です。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ 1:[2..5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| 1::[2..5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5]
</pre></div></div>
</td>
</tr>
</table>

<p>複数の先頭要素を連ねることもできます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ 1:2:[3..5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| 1::2::[3..5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5]
</pre></div></div>
</td>
</tr>
</table>

<p><code>::</code>では末尾に追加できないため<code>@</code>を使用します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ [1..4] ++ [5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| [1..4] @ [5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5]
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="文字列" class="fragment"></span><a href="#%E6%96%87%E5%AD%97%E5%88%97"><i class="fa fa-link"></i></a>文字列</h2>

<p>Haskellでは文字列は文字のリストとして扱われますが、F#では別物です。文字列の連結は<code>+</code>で、<code>@</code>や<code>::</code>は使えません。</p>

<p>F#で文字列をリストに変換するには<code>List.ofSeq</code>を使用します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ "abcde"
    print $ ['a', 'b', 'c', 'd', 'e']
    print $ ['a'..'e']
    print $ 'a':"bcde"
    print $ 'a':'b':"cde"
    print $ "abc" ++ "de"
    print $ "abcde" !! 3
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| "abcde"
printfn "%A" &lt;| ['a'; 'b'; 'c'; 'd'; 'e']
printfn "%A" &lt;| ['a'..'e']
printfn "%A" &lt;| 'a'::List.ofSeq "bcde"
printfn "%A" &lt;| 'a'::'b'::List.ofSeq "cde"
printfn "%A" &lt;| "abc" + "de"
printfn "%A" &lt;| "abcde".[3]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
"abcde"
"abcde"
"abcde"
"abcde"
"abcde"
"abcde"
'd'
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
"abcde"
['a'; 'b'; 'c'; 'd'; 'e']
['a'; 'b'; 'c'; 'd'; 'e']
['a'; 'b'; 'c'; 'd'; 'e']
['a'; 'b'; 'c'; 'd'; 'e']
"abcde"
'd'
</pre></div></div>
</td>
</tr>
</table>

<p>文字のリストから文字列への変換は次のようにします。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="o">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'f'</span><span class="o">]</span>
<span class="k">let</span> <span class="nv">s</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">ofList</span> <span class="n">a</span> <span class="o">|&gt;</span> <span class="nn">System</span><span class="p">.</span><span class="nn">String</span><span class="p">.</span><span class="n">Concat</span>
<span class="n">printfn</span> <span class="s">"%A -&gt; %A"</span> <span class="n">a</span> <span class="n">s</span>
</pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
['a'; 'b'; 'c'; 'd'; 'e'; 'f'] -&gt; "abcdef"
</pre></div>
</div>

<h2>
<span id="パターンマッチ" class="fragment"></span><a href="#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81"><i class="fa fa-link"></i></a>パターンマッチ</h2>

<p>パターンマッチでリストの先頭要素を取り出せます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
first (x:xs) = x

main = do
    print $ first [1..5]
    print $ first "abcdef"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let first = function
| x::xs -&gt; x
| _ -&gt; failwith "empty"

printfn "%A" &lt;| first [1..5]
printfn "%A" &lt;| first (List.ofSeq "abcdef")
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
'a'
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
'a'
</pre></div></div>
</td>
</tr>
</table>

<p><code>x::xs</code>で先頭<code>x</code>とその後ろのリスト<code>xs</code>に分割して受け取ります。<code>xs</code>は<code>x</code>の複数形を意図しています。これらの名前には文法的な意味はなく、あくまで慣習です。</p>

<p>この例では<code>xs</code>を使っていないため<code>_</code>で未使用を明示した方が無難です。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
first (x:_) = x
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
| x::_ -&gt; x
</pre></div></div></td>
</tr>
</table>

<p>先頭要素は複数を連ねることもできます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
second (_:x:_) = x

main = do
    print $ second [1..5]
    print $ second "abcdef"
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let second = function
| _::x::_ -&gt; x
| _ -&gt; failwith "too short"

printfn "%A" &lt;| second [1..5]
printfn "%A" &lt;| second (List.ofSeq "abcdef")
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
'b'
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
2
'b'
</pre></div></div>
</td>
</tr>
</table>

<h1>
<span id="リスト関係の関数" class="fragment"></span><a href="#%E3%83%AA%E3%82%B9%E3%83%88%E9%96%A2%E4%BF%82%E3%81%AE%E9%96%A2%E6%95%B0"><i class="fa fa-link"></i></a>リスト関係の関数</h1>

<p>F#では<code>List</code>のメソッドという扱いです（<code>List.ofSeq</code> など）。</p>

<p><code>List.</code>は省略できません。これは冗長な印象を受けますが、いくつかメリットがあります。</p>

<ul>
<li>F#では型推論を優先する言語設計のため、関数のオーバーロードができません。モジュールのメソッドであれば、配列・リスト・シーケンスなど互換性のない型に対して、同じ名前のメソッドが提供できます。</li>
<li>インテリセンスのサポートがある環境では、<code>List.</code>と打てばメソッド名の候補が補完されます。</li>
</ul>

<h2>
<span id="length" class="fragment"></span><a href="#length"><i class="fa fa-link"></i></a>length</h2>

<p>リストの要素数を取得します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ length [1, 2, 3]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" &lt;| List.length [1; 2; 3]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
3
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
3
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="sum" class="fragment"></span><a href="#sum"><i class="fa fa-link"></i></a>sum</h2>

<p>リストの要素をすべて足します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ sum [1..5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" &lt;| List.sum [1..5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
15
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
15
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="rev" class="fragment"></span><a href="#rev"><i class="fa fa-link"></i></a>rev</h2>

<p>リストの要素を逆に並べます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print $ reverse [1..5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| List.rev [1..5]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[5,4,3,2,1]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[5; 4; 3; 2; 1]
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="練習-3" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-3"><i class="fa fa-link"></i></a>練習</h2>

<p><code>length</code>と同じ機能の関数を再実装する例です。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">rec</span> <span class="n">length</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="bp">[]</span>    <span class="o">-&gt;</span> <span class="mi">0</span>
<span class="o">|</span> <span class="o">_::</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="n">xs</span>

<span class="n">printfn</span> <span class="s">"%d"</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;|</span> <span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
3
</pre></div>
</div>

<p>【問4】<code>sum</code>, <code>rev</code>と同じ機能の関数を再実装してください。<code>sum</code>の掛け算版<code>product</code>も実装してください。</p>

<p>ヒント: リストを再帰で処理するパターンは<code>| x::xs -&gt; x ... f xs</code>です。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E5%86%8D%E5%AE%9F%E8%A3%85" id="reference-cb69102bde082ad5402c">解答例</a></p>

<p>【問5】<code>product</code>を使って<code>fact</code>（階乗）を実装してください。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E9%9A%8E%E4%B9%97" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h1>
<span id="タプル" class="fragment"></span><a href="#%E3%82%BF%E3%83%97%E3%83%AB"><i class="fa fa-link"></i></a>タプル</h1>

<p>関数で複数の値を返すことができます。括弧で複数の値を囲んだ部分を<strong>タプル</strong>と呼びます。</p>

<p>※ F#ではタプルの括弧を省略できますが、この記事では混乱を避けるため省略しません。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
addsub x y = (x + y, x - y)

main = do
    print $ addsub 1 2
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let addsub x y = (x + y, x - y)

printfn "%A" &lt;| addsub 1 2
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
(3,-1)
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
(3, -1)
</pre></div></div>
</td>
</tr>
</table>

<p>タプルは全体でも分割でも受け取れます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
addsub x y = (x + y, x - y)
a = addsub 1 2
(a1, a2) = addsub 1 2

main = do
    print a
    print a1
    print a2
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let addsub x y = (x + y, x - y)
let a = addsub 1 2
let (a1, a2) = addsub 1 2

printfn "%A" a
printfn "%d" a1
printfn "%d" a2
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
(3,-1)
3
-1
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
(3, -1)
3
-1
</pre></div></div>
</td>
</tr>
</table>

<p>数学の座標をイメージすると良いでしょう。</p>

<ul>
<li>$P=(1,2)$</li>
<li>$(x,y)=(1,2)$ ⇔ $x=1,y=2$</li>
</ul>

<h2>
<span id="リストとの比較" class="fragment"></span><a href="#%E3%83%AA%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83"><i class="fa fa-link"></i></a>リストとの比較</h2>

<ul>
<li>リストの項目数は任意ですが、タプルでは固定です。</li>
<li>リストの要素はすべて同じ型でないといけませんが、タプルでは任意です。

<ul>
<li>× <code>[1; "a"]</code>
</li>
<li>○ <code>(1, "a")</code>
</li>
</ul>
</li>
</ul>

<h2>
<span id="関数-1" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0-1"><i class="fa fa-link"></i></a>関数</h2>

<p>要素が2つのタプルから値を取り出す関数<code>fst</code>, <code>snd</code>があります。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    let p2 = (1, 2)
    print $ fst p2
    print $ snd p2
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let p2 = (1, 2)
printfn "%d" &lt;| fst p2
printfn "%d" &lt;| snd p2
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
2
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
1
2
</pre></div></div>
</td>
</tr>
</table>

<p>要素が3つ以上のタプルからは変数経由で値を取り出します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    let p3 = (1, 2, 3)
    print p3
    let (_, _, p3z) = p3
    print p3z
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let p3 = (1, 2, 3)
printfn "%A" p3
let (_, _, p3z) = p3
printfn "%d" p3z
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
(1,2,3)
3
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
(1, 2, 3)
3
</pre></div></div>
</td>
</tr>
</table>

<p>※ リストのように<code>.[]</code>で値を取り出すことはできません。</p>

<h2>
<span id="練習-4" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-4"><i class="fa fa-link"></i></a>練習</h2>

<p>【問6】点 $(p, q)$ から直線 $ax + by = c$ に下した垂線の交点を求める関数<code>perpPoint</code>を作成してください。aとbが両方ゼロになると解なしですが、チェックせずに無視してください。</p>

<p>具体的には次のコードが動くようにしてください。<code>0.</code>などは浮動小数点数（<code>float</code>）のリテラルです。</p>

<div class="code-frame" data-lang="fsharp"><div class="highlight"><pre>
<span class="n">printfn</span> <span class="s">"%A"</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;|</span> <span class="n">perpPoint</span> <span class="o">(</span><span class="mi">0</span><span class="o">.,</span> <span class="mi">2</span><span class="o">.)</span> <span class="o">(</span><span class="mi">1</span><span class="o">.,</span> <span class="o">-</span><span class="mi">1</span><span class="o">.,</span> <span class="mi">0</span><span class="o">.)</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
(1.0, 1.0)
</pre></div>
</div>

<p>ヒント: $ax + by = c$ の傾きは $-\frac{a}{b}$ です。直交する直線の傾きとの積が $-1$ となることから、垂線は $bx - ay = d$ と表せます。連立方程式を解けば交点が求まります。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E5%9E%82%E7%B7%9A%E3%81%AE%E4%BA%A4%E7%82%B9" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h1>
<span id="キャスト" class="fragment"></span><a href="#%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88"><i class="fa fa-link"></i></a>キャスト</h1>

<p><code>int</code>などの基本的な型は、型名を関数として扱うことでキャストできます。</p>

<p>キャストを使用して、文字コードを取得したり、文字コードを文字に変換したりする例です。</p>

<p>※ Haskellでは専用の関数をインポートして使用します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
import Data.Char

main = do
    print $ ord 'A'
    print $ chr 65
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%d" &lt;| int 'A'
printfn "%c" &lt;| char 65
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
65
'A'
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
65
A
</pre></div></div>
</td>
</tr>
</table>

<h2>
<span id="練習-5" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-5"><i class="fa fa-link"></i></a>練習</h2>

<p>【問7】<a href="http://ja.wikipedia.org/wiki/ROT13" rel="nofollow noopener" target="_blank">ROT13</a>を実装してください。</p>

<p>具体的には次のコードが動くようにしてください。</p>

<div class="code-frame" data-lang="fsharp"><div class="highlight"><pre>
<span class="k">let</span> <span class="nv">hello13</span> <span class="o">=</span> <span class="n">rot13</span> <span class="s">"Hello, World!"</span>
<span class="n">printfn</span> <span class="s">"%s"</span> <span class="n">hello13</span>
<span class="n">printfn</span> <span class="s">"%s"</span> <span class="o">&lt;|</span> <span class="n">rot13</span> <span class="n">hello13</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
Uryyb, Jbeyq!
Hello, World!
</pre></div>
</div>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#rot13" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h1>
<span id="ソート" class="fragment"></span><a href="#%E3%82%BD%E3%83%BC%E3%83%88"><i class="fa fa-link"></i></a>ソート</h1>

<p>挿入ソートの実装例を示します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
insert x [] = [x]
insert x (y:ys)
    | x &lt; y     = x:y:ys
    | otherwise = y : insert x ys

isort []     = []
isort (x:xs) = insert x (isort xs)

main = do
    let t = [4, 6, 9, 8, 3, 5, 1, 7, 2]
    print $ isort t
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let rec insert x = function
| [] -&gt; [x]
| y::ys when x &lt; y -&gt; x::y::ys
| y::ys -&gt; y :: insert x ys

let rec isort = function
| [] -&gt; []
| x::xs -&gt; insert x (isort xs)

let t = [4; 6; 9; 8; 3; 5; 1; 7; 2]
printfn "%A" &lt;| isort t
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5,6,7,8,9]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5; 6; 7; 8; 9]
</pre></div></div>
</td>
</tr>
</table>

<p>処理の流れを説明します。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">rec</span> <span class="n">isort</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
<span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">(</span><span class="n">isort</span> <span class="n">xs</span><span class="o">)</span>
</pre></div>
</div>

<p>リストの先頭の要素を取り出しながら再帰することで、リストの要素を順番に挿入して行きます。</p>

<p>リスト<code>[4; 6; 9; 8; 3; 5; 1; 7; 2]</code>の往路をトレースします。</p>

<ol>
<li><code>| [4; 6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 4 (isort [6; 9; 8; 3; 5; 1; 7; 2])</code></li>
<li><code>| [6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 6 (isort [9; 8; 3; 5; 1; 7; 2])</code></li>
<li><code>| [9; 8; 3; 5; 1; 7; 2] -&gt; insert 9 (isort [8; 3; 5; 1; 7; 2])</code></li>
<li><code>| [8; 3; 5; 1; 7; 2] -&gt; insert 8 (isort [3; 5; 1; 7; 2])</code></li>
<li><code>| [3; 5; 1; 7; 2] -&gt; insert 3 (isort [5; 1; 7; 2])</code></li>
<li><code>| [5; 1; 7; 2] -&gt; insert 5 (isort [1; 7; 2])</code></li>
<li><code>| [1; 7; 2] -&gt; insert 1 (isort [7; 2])</code></li>
<li><code>| [7; 2] -&gt; insert 7 (isort [2])</code></li>
<li><code>| [2] -&gt; insert 2 (isort [])</code></li>
<li><code>| [] -&gt; []</code></li>
</ol>

<p><code>insert</code>の第2引数は必ず<code>isort</code>でソートされたリストが渡されます。</p>

<p>挿入先のリストはソート済みであることを前提にできるため、挿入箇所の判定は後続要素との比較だけで済みます。</p>

<p>再帰により挿入先のリストの要素と順番に比較していきます。末尾に達すると<code>ys = []</code>となるため、そこに挿入します。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
<span class="o">|</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="k">when</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::</span><span class="n">ys</span>
<span class="o">|</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>
</pre></div>
</div>

<p>例を示します。</p>

<ol>
<li>
<code>insert 3 [1; 2; 5; 7]</code> 次へ</li>
<li>
<code>1::insert 3 [2; 5; 7]</code> 次へ</li>
<li>
<code>1::2::insert 3 [5; 7]</code> ここへ挿入</li>
<li><code>1::2::3::[5; 7]</code></li>
<li><code>[1; 2; 3; 5; 7]</code></li>
</ol>

<p><code>isort</code>の復路をトレースします。</p>

<ol>
<li><code>| [2] -&gt; insert 2 []</code></li>
<li><code>| [7; 2] -&gt; insert 7 [2]</code></li>
<li><code>| [1; 7; 2] -&gt; insert 1 [2; 7]</code></li>
<li><code>| [5; 1; 7; 2] -&gt; insert 5 [1; 2; 7]</code></li>
<li><code>| [3; 5; 1; 7; 2] -&gt; insert 3 [1; 2; 5; 7]</code></li>
<li><code>| [8; 3; 5; 1; 7; 2] -&gt; insert 8 [1; 2; 3; 5; 7]</code></li>
<li><code>| [9; 8; 3; 5; 1; 7; 2] -&gt; insert 9 [1; 2; 3; 5; 7; 8]</code></li>
<li><code>| [6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 6 [1; 2; 3; 5; 7; 8; 9]</code></li>
<li><code>| [4; 6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 4 [1; 2; 3; 5; 6; 7; 8; 9]</code></li>
<li><code>[1; 2; 3; 4; 5; 6; 7; 8; 9]</code></li>
</ol>

<p>このように要素を1つずつソートされたリストに挿入しています。</p>

<h2>
<span id="確認のコツ-1" class="fragment"></span><a href="#%E7%A2%BA%E8%AA%8D%E3%81%AE%E3%82%B3%E3%83%84-1"><i class="fa fa-link"></i></a>確認のコツ</h2>

<p>再帰の確認のコツを説明しましたが、挿入ソートに適用してみます。具体例を使って、結果が信頼できるものと見なします。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">isort再帰部</span></div>
<div class="highlight"><pre>
<span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">(</span><span class="n">isort</span> <span class="n">xs</span><span class="o">)</span>
</pre></div>
</div>

<ol>
<li><code>| [3; 5; 1; 7; 2] -&gt; insert 3 (isort [5; 1; 7; 2])</code></li>
<li>
<code>| [5; 1; 7; 2]</code>は定義よりソート済みの<code>[1; 2; 5; 7]</code>が返されると考えます。</li>
<li><code>insert 3 [1; 2; 5; 7] = [1; 2; 3; 5; 7]</code></li>
</ol>

<h2>
<span id="デバッグ" class="fragment"></span><a href="#%E3%83%87%E3%83%90%E3%83%83%E3%82%B0"><i class="fa fa-link"></i></a>デバッグ</h2>

<p>F#ではHaskellのように副作用の分離が強制されないため、通常の<code>printf</code>デバッグが可能です。</p>

<p>挿入ソートをトレースしてみます。</p>

<div class="code-frame" data-lang="fsharp">
<div class="code-lang"><span class="bold">F#</span></div>
<div class="highlight"><pre>
<span class="k">let</span> <span class="nv">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
<span class="o">|</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="k">when</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::</span><span class="n">ys</span>
<span class="o">|</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>

<span class="k">let</span> <span class="nv">rec</span> <span class="n">isort</span> <span class="o">=</span> <span class="k">function</span>
<span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
<span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span>
    <span class="n">printfn</span> <span class="s">"isort %A = insert %d (isort %A)"</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">x</span> <span class="n">xs</span>
    <span class="k">let</span> <span class="nv">xs</span><span class="k">'</span> <span class="o">=</span> <span class="n">isort</span> <span class="n">xs</span>
    <span class="k">let</span> <span class="nv">ret</span> <span class="o">=</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">xs'</span>
    <span class="n">printfn</span> <span class="s">"insert %d %A = %A"</span> <span class="n">x</span> <span class="n">xs'</span> <span class="n">ret</span>
    <span class="n">ret</span>

<span class="k">let</span> <span class="nv">t</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">2</span><span class="o">]</span>
<span class="n">printfn</span> <span class="s">"%A"</span> <span class="o">&lt;|</span> <span class="n">isort</span> <span class="n">t</span>
</pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
isort [4; 6; 9; 8; 3; 5; 1; 7; 2] = insert 4 (isort [6; 9; 8; 3; 5; 1; 7; 2])
isort [6; 9; 8; 3; 5; 1; 7; 2] = insert 6 (isort [9; 8; 3; 5; 1; 7; 2])
isort [9; 8; 3; 5; 1; 7; 2] = insert 9 (isort [8; 3; 5; 1; 7; 2])
isort [8; 3; 5; 1; 7; 2] = insert 8 (isort [3; 5; 1; 7; 2])
isort [3; 5; 1; 7; 2] = insert 3 (isort [5; 1; 7; 2])
isort [5; 1; 7; 2] = insert 5 (isort [1; 7; 2])
isort [1; 7; 2] = insert 1 (isort [7; 2])
isort [7; 2] = insert 7 (isort [2])
isort [2] = insert 2 (isort [])
insert 2 [] = [2]
insert 7 [2] = [2; 7]
insert 1 [2; 7] = [1; 2; 7]
insert 5 [1; 2; 7] = [1; 2; 5; 7]
insert 3 [1; 2; 5; 7] = [1; 2; 3; 5; 7]
insert 8 [1; 2; 3; 5; 7] = [1; 2; 3; 5; 7; 8]
insert 9 [1; 2; 3; 5; 7; 8] = [1; 2; 3; 5; 7; 8; 9]
insert 6 [1; 2; 3; 5; 7; 8; 9] = [1; 2; 3; 5; 6; 7; 8; 9]
insert 4 [1; 2; 3; 5; 6; 7; 8; 9] = [1; 2; 3; 4; 5; 6; 7; 8; 9]
[1; 2; 3; 4; 5; 6; 7; 8; 9]
</pre></div>
</div>

<p><code>printfn</code>を2回使うことで、往路と復路が確認できるように表示しています。</p>

<h2>
<span id="練習-6" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-6"><i class="fa fa-link"></i></a>練習</h2>

<p>【問8】<a href="http://www.ics.kagoshima-u.ac.jp/%7Efuchida/edu/algorithm/sort-algorithm/bubble-sort.html" rel="nofollow noopener" target="_blank">バブルソート</a>を実装してください。</p>

<p>ヒント: 交換する関数とソートする関数を分離して実装します。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/1e2a66bf8e8c7f0bd70f" id="reference-a2b16cd8f03c77664363">詳細説明</a>, <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%83%90%E3%83%96%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88" id="reference-cb69102bde082ad5402c">解答例</a></p>

<p>【問9】<a href="http://www.ics.kagoshima-u.ac.jp/%7Efuchida/edu/algorithm/sort-algorithm/merge-sort.html" rel="nofollow noopener" target="_blank">マージソート</a>を実装してください。</p>

<p>ヒント: リストを分割する関数を実装します。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h1>
<span id="リスト内包表記" class="fragment"></span><a href="#%E3%83%AA%E3%82%B9%E3%83%88%E5%86%85%E5%8C%85%E8%A1%A8%E8%A8%98"><i class="fa fa-link"></i></a>リスト内包表記</h1>

<p>リストの要素すべてに同じ処理を施した別のリストを作成します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
fact 0 = 1
fact n | n &gt; 0 = n * fact (n - 1)

main = do
    print [1, 2, 3, 4, 5]
    print [fact 1, fact 2, fact 3, fact 4, fact 5]
    print [fact x | x &lt;- [1..5]]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
let rec fact = function
| 0 -&gt; 1
| n when n &gt; 0 -&gt; n * fact (n - 1)
| _ -&gt; failwith "&lt; 0"

printfn "%A" &lt;| [1; 2; 3; 4; 5]
printfn "%A" &lt;| [fact 1; fact 2; fact 3; fact 4; fact 5]
printfn "%A" &lt;| [for x in 1..5 -&gt; fact x]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4,5]
[1,2,6,24,120]
[1,2,6,24,120]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4; 5]
[1; 2; 6; 24; 120]
[1; 2; 6; 24; 120]
</pre></div></div>
</td>
</tr>
</table>

<p><code>1..5</code>の要素を1つずつ<code>x</code>として取り出して、<code>fact x</code>として処理したリストを作成しています。</p>

<p>※ 同じことができる<code>map</code>という関数もありますが、詳細は省略します。</p>

<h2>
<span id="条件" class="fragment"></span><a href="#%E6%9D%A1%E4%BB%B6"><i class="fa fa-link"></i></a>条件</h2>

<p>要素を取り出す際に条件を指定する例を示します。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print [x | x &lt;- [1..9], x &lt; 5]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| [for x in 1..9 do if x &lt; 5 then yield x]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1,2,3,4]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[1; 2; 3; 4]
</pre></div></div>
</td>
</tr>
</table>

<p><code>1..9</code>のうち<code>x &lt; 5</code>を満たすものだけでリストを作成しています。</p>

<p>※ 同じことができる<code>filter</code>という関数もありますが、詳細は省略します。</p>

<h3>
<span id="練習-7" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-7"><i class="fa fa-link"></i></a>練習</h3>

<p>Haskellの特徴を示す例として、クイックソートがよく引き合いに出されます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre>
<span class="nf">qsort</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">qsort</span> <span class="p">(</span><span class="n">n</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">qsort</span> <span class="n">lt</span> <span class="o">++</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="n">gteq</span>
    <span class="kr">where</span>
        <span class="n">lt</span>   <span class="ow">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span>  <span class="n">n</span><span class="p">]</span>
        <span class="n">gteq</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">print</span> <span class="o">$</span> <span class="n">qsort</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre>
[1,2,3,4,5,6,7,8,9]
</pre></div>
</div>

<p>【問10】動きを考えて、F#に移植してください。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88" id="reference-cb69102bde082ad5402c">解答例</a></p>

<h2>
<span id="多重ループ" class="fragment"></span><a href="#%E5%A4%9A%E9%87%8D%E3%83%AB%E3%83%BC%E3%83%97"><i class="fa fa-link"></i></a>多重ループ</h2>

<p>リスト内包表記で多重ループを使った例を示します。</p>

<p>複数のリストから値を取り出すこともできます。多重ループのようにすべての組み合わせが得られます。</p>

<table>
<tr>
<th>Haskell</th>
<th>F#</th>
</tr>
<tr>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
main = do
    print [(x, y) | x &lt;- [1..3], y &lt;- "abc"]
</pre></div></div></td>
<td><div class="code-frame" data-lang="text"><div class="highlight"><pre>
printfn "%A" &lt;| [
    for x in 1..3 do
    for y in "abc" -&gt; (x, y)]
</pre></div></div></td>
</tr>
<tr>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),
 (3,'a'),(3,'b'),(3,'c')]
</pre></div></div>
</td>
<td>実行結果<div class="code-frame" data-lang="text"><div class="highlight"><pre>
[(1, 'a'); (1, 'b'); (1, 'c'); (2, 'a'); (2, 'b');
 (2, 'c'); (3, 'a'); (3, 'b'); (3, 'c')]

</pre></div></div>
</td>
</tr>
</table>

<h3>
<span id="練習-8" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92-8"><i class="fa fa-link"></i></a>練習</h3>

<p>【問11】三辺の長さが各20以下の整数で構成される直角三角形を列挙してください。並び順による重複を排除する必要はありません。</p>

<p>ヒント: 直角三角形の成立条件は三平方（ピタゴラス）の定理です。</p>

<p>⇒ <a href="http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2%E3%81%AE%E4%B8%89%E8%BE%BA" id="reference-cb69102bde082ad5402c">解答例</a></p>
<div class="hidden"><form class="js-task-list-update" action="/7shi/items/1d3750ba17f5a88b8405" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="_method" value="patch" /><input type="hidden" name="authenticity_token" value="wzV7yze1YC5fpplBirDfHpeM3f2Q/4w4mTSmHwc0DuStt+CTrJtZZaB1LF36RWFH98v5Tgc71s+l6q/k5joAIg==" /><input type="hidden" name="updated_at_confirmation_in_unixtime" id="updated_at_confirmation_in_unixtime" value="1484128075" class="js-task-list-updated-at" /><textarea name="raw_body" id="raw_body" class="js-task-list-field">
Haskellと比較しながらF#を説明します。練習では再帰に慣れることに重点を置きます。再帰によるリスト処理の例として各種ソート（挿入ソート、バブルソート、マージソート、クイックソート）を紹介します。

※ 一応、Haskellは飛ばしてF#だけでも読めるようには配慮したつもりです。Haskellがよく分からなければ飛ばして読んでみてください。

この記事はHaskellの記事をベースにしています。

* [Haskell 超入門](http://qiita.com/7shi/items/145f1234f8ec2af923ef) 2014.08.20

練習の解答例は別記事に掲載します。

* [【解答例】Haskellで学ぶF#入門](http://qiita.com/7shi/items/b174d1c50aab9350dafc)

この記事には姉妹編があります。

* [C#/JavaScriptで学ぶF#入門](http://qiita.com/7shi/items/ff746903680ae8d0d7ce) 2017.01.04

この記事には関連記事があります。

* [doブロックとコンピュテーション式](http://qiita.com/7shi/items/92139286a4e9b5620d69) 2016.07.01
* [functionのインデント](http://qiita.com/7shi/items/7f490819e818dd7aa37c) 2016.12.14

F#を手っ取り早く試すために、私が常用している環境を紹介します。

* [F#開発環境の紹介](http://qiita.com/7shi/items/5fc7d6477d96bbd7a71d) 2016.12.30

# ハローワールド

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    putStrLn &quot;Hello, World!&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;Hello, World!&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
Hello, World!
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
Hello, World!
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## エントリーポイント

F#は処理をいきなり書き始めることができるため、`main`は必須ではありません。もし必要であれば`[&lt;EntryPoint&gt;]`属性を添えて関数を書きます。関数名は任意で`main`でなくても構いませんが、引数と戻り値は必須です。C言語と比較します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;C言語&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
#include &amp;lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    printf(&quot;Hello, World!\n&quot;);
    return 0;
}
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
[&amp;lt;EntryPoint&gt;]
let main args =
    printfn &quot;Hello, World!&quot;
    0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
Hello, World!
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
Hello, World!
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#は`[&lt;EntryPoint&gt;]`に`do`ブロックを組み合わせることで、引数や戻り値が省略可能です。

```fsharp:F#
[&lt;EntryPoint&gt;]
do
    printfn &quot;Hello, World!&quot;
```
```text:実行結果
Hello, World!
```

簡単のため、以後の例ではエントリーポイントなしで処理を書きます。

## do

Haskellは`do`ブロック内では文法が変わりますが、F#の`do`ではそういったことはありません。F#の`do`はC言語などの`{}`と同じようにブロックを表します。

F#でHaskellの`do`ブロックに相当するのはコンピュテーション式です。詳細は次の記事を参照してください。

* [doブロックとコンピュテーション式](http://qiita.com/7shi/items/92139286a4e9b5620d69) 2016.07.01

Haskellでは連続出力に`do`が必須ですが、F#ではそういった制約はありません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    putStrLn &quot;Hello, World!&quot;
    putStrLn &quot;Hello, World!&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;Hello, World!&quot;
printfn &quot;Hello, World!&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
Hello, World!
Hello, World!
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
Hello, World!
Hello, World!
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## printf

Haskellの`print`はShowのインスタンスを受け付けます。F#ではフォーマットに`%A`を指定すれば任意の型を受け付けます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print 1
    print &quot;abc&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; 1
printfn &quot;%A&quot; &quot;abc&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
&quot;abc&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
&quot;abc&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

F#では`%d`などの型に紐付けられたフォーマットを指定すればコンパイラで型がチェックされるため、フォーマットでサポートされている型は個別に指定した方が無難です。

# 束縛

F#の変数（識別子）は後で別の値を再代入することができません。そのため代入ではなく**束縛**という用語を使います。

## let

F#ではトップレベルやローカルの区別なく、束縛には常に`let`が必要です。

※ Haskellの`where`に相当するキーワードはありません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
a = 1
b = 2

main = do
    let c = a + b
    print c
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1
let b = 2

do
    let c = a + b
    printfn &quot;%d&quot; c
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
3
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# 関数

数学の $f(x)=x+1$ や $f(1)$ の括弧がない版だとイメージしてください。C言語の`return`に相当するキーワードは使いません。

※ `return`は存在しますが別の意味です。詳細は[doブロックとコンピュテーション式](http://qiita.com/7shi/items/92139286a4e9b5620d69)を参照してください。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
f x = x + 1
a = f 1

main = do
    print a
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let f x = x + 1
let a = f 1

printfn &quot;%d&quot; a
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`a`を経由せずに`printfn`に直接`f 1`を渡すには、括弧で囲みます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
f x = x + 1

main = do
    print (f 1)
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let f x = x + 1

printfn &quot;%d&quot; (f 1)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## パイプライン演算子

閉じ括弧の省略にはパイプライン演算子`&lt;|`が使えます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print (f 1)
    print $ f 1
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; (f 1)
printfn &quot;%d&quot; &amp;lt;| f 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

連続で使用した場合、`&lt;|`はHaskellの`$`とは挙動が異なるので注意が必要です。F#でHaskellの挙動を真似するには`&lt;&lt;`による関数合成と併用する必要があります。対応を示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ abs $ 3 - 5
    let a = atan2 (sqrt 2) (sqrt 3)
    print a
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; &amp;lt;&amp;lt; abs &amp;lt;| 3 - 5
let a = atan2 &amp;lt;| sqrt 2. &amp;lt;| sqrt 3.
printfn &quot;%f&quot; a
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
0.684719203002283
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
0.684719
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

逆向きの `|&gt;` もあります。連続して使用すれば、関数の多重ネストをシェルのパイプのように記述できます。

```fsharp:F#
printfn &quot;%d&quot; (abs (3 - 5))
3 - 5 |&gt; abs |&gt; printfn &quot;%d&quot;
```
```text:実行結果
2
2
```

## 関数の演算子化

F#ではHaskellのように関数を演算子として使うことはできません。

```hs:Haskell
add x y = x + y

main = do
    print $ add 1 2
    print $ 1 `add` 2  -- 関数の演算子化
```
```text:実行結果
3
3
```

## 演算子の関数化

中置演算子を`()`で囲むと関数として使用できます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ 1 + 2
    print $ (+) 1 2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; &amp;lt;| 1 + 2
printfn &quot;%d&quot; &amp;lt;| (+) 1 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
3
3
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
3
3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# 四則演算

F#で割り算で小数点以下を扱う場合は、オペランドを明示的に浮動小数点数で記述します。Haskellのような `/` と `div` の区別はありません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ 5 + 2
    print $ 5 - 2
    print $ 5 * 2
    print $ 5 / 2
    print $ div 5 2
    print $ mod 5 2
    print $ 5 `div` 2
    print $ 5 `mod` 2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; &amp;lt;| 5 + 2
printfn &quot;%d&quot; &amp;lt;| 5 - 2
printfn &quot;%d&quot; &amp;lt;| 5 * 2
printfn &quot;%f&quot; &amp;lt;| 5. / 2.
printfn &quot;%d&quot; &amp;lt;| (/) 5 2
printfn &quot;%d&quot; &amp;lt;| (%) 5 2
printfn &quot;%d&quot; &amp;lt;| 5 / 2
printfn &quot;%d&quot; &amp;lt;| 5 % 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
7
3
10
2.5
2
1
2
1
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
7
3
10
2.500000
2
1
2
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# 命名規則

Haskellとは異なり変数や関数を大文字で始めてもエラーにはなりませんが、慣習的に小文字で始めます。

# if - then - else

まず、一行で書いてみます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
a = 1

main = do
    if a == 1 then print &quot;1&quot; else print &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1

if a = 1 then printfn &quot;1&quot; else printfn &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
&quot;1&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ 「等しい」は`=`、「等しくない」は`&lt;&gt;`です。

複数行で書く場合のインデントにはある程度のバリエーションがありますが、よく使われるパターンを示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
a = 1

main = do
    if a == 1
        then print &quot;1&quot;
        else print &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1

if a = 1 then
    printfn &quot;1&quot;
else
    printfn &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
&quot;1&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ F#の`else`はインデントで特別なルールがありますが、書き方が複数あると混乱するため説明を省略します。

## 値を返す

`if`は値を返すため、C言語の三項演算子のように使えます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
a = 1

main = do
    print $ if a == 1 then &quot;1&quot; else &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let a = 1

printfn &quot;%s&quot; &amp;lt;| if a = 1 then &quot;1&quot; else &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
&quot;1&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

関数の定義と組み合わせた例です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
f a = if a == 1 then &quot;1&quot; else &quot;?&quot;

main = do
    print $ f 0
    print $ f 1
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let f a = if a = 1 then &quot;1&quot; else &quot;?&quot;

printfn &quot;%s&quot; &amp;lt;| f 0
printfn &quot;%s&quot; &amp;lt;| f 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
&quot;?&quot;
&quot;1&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
?
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# 関数のパターンマッチ

関数内の全体を`if`で切り分ける代わりに、`function`キーワードで引数を振り分けられます。このような書き方を**パターンマッチ**と呼びます。

※ Haskellのように関数を複数定義するような形にはしません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
f 1 = &quot;1&quot;
f a = &quot;?&quot;

main = do
    print $ f 0
    print $ f 1
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let f = function
| 1 -&gt; &quot;1&quot;
| a -&gt; &quot;?&quot;

printfn &quot;%s&quot; &amp;lt;| f 0
printfn &quot;%s&quot; &amp;lt;| f 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
&quot;?&quot;
&quot;1&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
?
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

値を無視する引数は`_`と書くことで、値を無視していることを明示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
f 1 = &quot;1&quot;
f _ = &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let f = function
| 1 -&gt; &quot;1&quot;
| _ -&gt; &quot;?&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

これは独特な書き方のため、慣れが必要です。

## 階乗

例としてよく引き合いに出されます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
fact 0 = 1
fact n = n * fact (n - 1)

main = do
    print $ fact 5
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let rec fact = function
| 0 -&gt; 1
| n -&gt; n * fact (n - 1)

printfn &quot;%d&quot; &amp;lt;| fact 5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
120
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
120
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`fact`の中で`fact`を呼んでいます。このような流れを**再帰**と言います。再帰関数には`rec`キーワードを付けます。`rec`を付けなければ自分が参照できずにエラーになります。

※ デフォルトで再帰可能になっていないのは、同名の変数で覆い隠すシャドウイングを考慮した言語設計のようです。F#の元になったOCamlについての記事を紹介します。

* [@camlspotter](https://twitter.com/camlspotter): [OCaml の let と let rec はなぜ別扱いになっているのか、決定版、もしくは OCaml 暦十何年だったか忘れたけど仕事で Haskell を一年使ってみた - Oh, you `re no (fun _ → more)](http://d.hatena.ne.jp/camlspotter/20110509/1304933919) 2011.05.09

再帰は往復で処理されるため往路と復路に分けて考えます。

再帰の往路をトレースします。

1. `| 5 -&gt; 5 * fact 4`
1. `| 4 -&gt; 4 * fact 3`
1. `| 3 -&gt; 3 * fact 2`
1. `| 2 -&gt; 2 * fact 1`
1. `| 1 -&gt; 1 * fact 0`
1. `| 0 -&gt; 1`

`| 0 -&gt; 1`が折り返し点となり、反転して復路に入ります。

1. `| 1 -&gt; 1 * fact 0 = 1 * 1 = 1`
1. `| 2 -&gt; 2 * fact 1 = 2 * 1 = 2`
1. `| 3 -&gt; 3 * fact 2 = 3 * 2 = 6`
1. `| 4 -&gt; 4 * fact 3 = 4 * 6 = 24`
1. `| 5 -&gt; 5 * fact 4 = 5 * 24 = 120`

※ 往路だけで復路のない末尾再帰もありますが、今回の範囲を超えるため省略します。

### 簡約

往路をインライン展開すると次のように捉えることができます。

1. `fact 5`
1. `5 * fact 4`
1. `5 * 4 * fact 3`
1. `5 * 4 * 3 * fact 2`
1. `5 * 4 * 3 * 2 * fact 1`
1. `5 * 4 * 3 * 2 * 1 * fact 0`
1. `5 * 4 * 3 * 2 * 1 * 1`
1. `120`

このような式変形を**簡約**と呼びます。

### 基底部・再帰部

折り返し点となる定義を基底部、自分自身を呼び出している定義を再帰部と呼びます。

* 基底部: `| 0 -&gt; 1`
* 再帰部: `| n -&gt; n * fact (n - 1)`

## コツ

再帰の取り扱いにはパターンがあります。そこを意識するのがコツです。

### 作り方のコツ

1. 基底部を定義
2. 具体例に当てはめて一般化する

まず基底部を定義します。自然数を指定するタイプでは値が減少しながら再帰を繰り返すのが定石で、これ以上減少できない最小値が基底部となります。

階乗について考えます。マイナスの階乗が定義されていないため、計算可能な最小の階乗は $0!$ です。このことから基底部を定義します。

```fsharp:基底部
let rec fact = function
| 0 -&gt; 1
```

再帰部は具体例を通して考えるのがコツです。たとえば5の階乗を考えます。

```math:具体例
5! = 5 × 4 × 3 × 2 × 1
```

再帰は引数を5から0に向かって減少させて処理します。1つ小さい引数（この場合は4）の結果を利用するのが定石です。このパターンで表すため、5の階乗を4の階乗で表せないか考えます。

```math:式変形
5! = 5 × (4 × 3 × 2 × 1) = 5 × 4!
```

特定の数（この場合は5）での関係が得られました。これを一般化して5を$n$に置き換えます。4は$n-1$です。このように隣接する項目との関係で表された式を[漸化式](http://ja.wikipedia.org/wiki/%E6%BC%B8%E5%8C%96%E5%BC%8F)と呼びます。

```math:漸化式
n! = n × (n-1)!
```

漸化式をコード化すれば再帰部が得られます。

```fsharp:fact再帰部
| n -&gt; n * fact (n - 1)
```

このように基底部と再帰部は順を追って別々に作ることになるため、パターンマッチで分岐する書き方と相性が良いです。

※ 数学の問題であれば得られた式を[数学的帰納法](http://ja.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%9A%84%E5%B8%B0%E7%B4%8D%E6%B3%95)で証明することが求められますが、今回はプログラミングの練習が目的なので、いくつか具体例で動作確認して済ませます。

### 確認のコツ

一旦書き上げたプログラムを確認するコツです。既存のコードを読むときにも使えます。

再帰の流れは追わずに、結果が信頼できるものと見なして具体例で考えます。

```fsharp:fact再帰部
| n -&gt; n * fact (n - 1)
```

1. `| 5 -&gt; 5 * fact 4`
2. `fact 4`は定義より`4! = 24`が返されると考えます。
3. `5 * 24 = 120`

次に再帰を使った練習問題をやるので、この方法を試してみてください。

## 練習

フィボナッチ数は`0, 1`が初期値として与えられ、それ以降は前2つの数字を合計して得られる数列です。

* 0, 1, 1, 2, 3, 5, 8, 13, 21, ...

【問1】任意のn番目のフィボナッチ数を計算する関数`fib`をパターンマッチで実装してください。最初の0は0番目とします。

ヒント: 基底部は1つとは限りません。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0)

# ガード

パターンマッチに`when`で条件を付加するガードという書き方があります。

上で実装した`fact`に負の数を渡すと無限ループになります。対策としてガードを追加して引数を制限します。

※ マイナスの階乗は数学的に定義されていないので、弾いても問題ありません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
fact 0 = 1
fact n | n &gt; 0 = n * fact (n - 1)

main = do
    print $ fact 5
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let rec fact = function
| 0 -&gt; 1
| n when n &gt; 0 -&gt; n * fact (n - 1)

printfn &quot;%d&quot; &amp;lt;| fact 5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
120
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
120
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 例外

先ほどのコードは Imcomplete patter matches と警告されます。マイナスのときの処理が抜けているためです。

警告を消すため、残り全部の意味で `_`で受けて`failwith`で例外を発生させます。

```fsharp:F#
let rec fact = function
| 0 -&gt; 1
| n when n &gt; 0 -&gt; n * fact (n - 1)
| _ -&gt; failwith &quot;&lt; 0&quot;
```

※ Haskellでは例外を使用するには構造を変える必要があるため、対応コードは省略します。Haskellで例外を使わずに処理する方法については[Haskell Maybeモナド 超入門](http://qiita.com/7shi/items/c7d7eec066af0fe0688d#guard)を参照してください。

## 練習

【問2】問1で実装した関数に、無限ループを防ぐためのガードを追加してください。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%82%AC%E3%83%BC%E3%83%89)

# match

関数の中でパターンマッチを行うには `match` - `with` を使います。

※ Haskellとは異なり、F#では`function`も`match`も`-&gt;`を使います。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
fact n = case n of
    0 -&gt; 1
    _ | n &gt; 0 -&gt; n * fact (n - 1)

main = do
    print $ fact 5
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let rec fact n =
    match n with
    | 0 -&gt; 1
    | _ when n &gt; 0 -&gt; n * fact (n - 1)
    | _ -&gt; failwith &quot;&lt; 0&quot;

printfn &quot;%d&quot; &amp;lt;| fact 5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
120
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
120
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ 引数で`n`として受けているため、`match`中のパターンマッチでは`_`として受け流しています。

`function`は関数レベルの分岐のためインデントしませんでしたが、`match`は関数の中のためインデントが必須です。詳細は次の記事を参照してください。

* [functionのインデント](http://qiita.com/7shi/items/7f490819e818dd7aa37c) 2016.12.14

## 練習

【問3】問2で実装した関数を`match`で書き直してください。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#match)

# リスト

他言語の配列と似たようなものです。F#では要素は `;` で区切ります。慣れるまで間違えやすいので注意してください。

※ F#では `,` で区切ると意味が変わり、大抵の場合はエラーとなります。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print [1, 2, 3, 4, 5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; [1; 2; 3; 4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ F#ではリストとは別に配列もあります。今回はリストの使い方に慣れることを目的とするため、配列については省略します。

要素は改行によっても区切られます。実際には改行の方が基本で、改行せずに区切るのが `;` です。

```fsharp:F#
printfn &quot;%A&quot; [
    1
    2
    3
    4
    5]
```
```text:実行結果
[1; 2; 3; 4; 5]
```

## 要素の取り出し

リストから要素を取り出すには`.[]`を使います。先頭の要素は0番目です。

※ 他の言語に慣れていると `.` が異様に映りますが、`[]`もオブジェクトのメソッドだということを示しています。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ [1, 2, 3, 4, 5] !! 3
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; [1; 2; 3; 4; 5].[3]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
4
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 連番

連番リストを生成する専用の書き方があります。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print [1..5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; [1..5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 連結

`@`によりリスト同士を結合できます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ [1, 2, 3] ++ [4, 5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| [1; 2; 3] @ [4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## ::

`::`によりリストの先頭に要素を挿入できます。

※ Haskellとは`:`と`::`の意味が逆なのに注意が必要です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ 1:[2..5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| 1::[2..5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

複数の先頭要素を連ねることもできます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ 1:2:[3..5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| 1::2::[3..5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`::`では末尾に追加できないため`@`を使用します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ [1..4] ++ [5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| [1..4] @ [5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 文字列

Haskellでは文字列は文字のリストとして扱われますが、F#では別物です。文字列の連結は`+`で、`@`や`::`は使えません。

F#で文字列をリストに変換するには`List.ofSeq`を使用します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ &quot;abcde&quot;
    print $ [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
    print $ [&#39;a&#39;..&#39;e&#39;]
    print $ &#39;a&#39;:&quot;bcde&quot;
    print $ &#39;a&#39;:&#39;b&#39;:&quot;cde&quot;
    print $ &quot;abc&quot; ++ &quot;de&quot;
    print $ &quot;abcde&quot; !! 3
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| &quot;abcde&quot;
printfn &quot;%A&quot; &amp;lt;| [&#39;a&#39;; &#39;b&#39;; &#39;c&#39;; &#39;d&#39;; &#39;e&#39;]
printfn &quot;%A&quot; &amp;lt;| [&#39;a&#39;..&#39;e&#39;]
printfn &quot;%A&quot; &amp;lt;| &#39;a&#39;::List.ofSeq &quot;bcde&quot;
printfn &quot;%A&quot; &amp;lt;| &#39;a&#39;::&#39;b&#39;::List.ofSeq &quot;cde&quot;
printfn &quot;%A&quot; &amp;lt;| &quot;abc&quot; + &quot;de&quot;
printfn &quot;%A&quot; &amp;lt;| &quot;abcde&quot;.[3]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
&quot;abcde&quot;
&quot;abcde&quot;
&quot;abcde&quot;
&quot;abcde&quot;
&quot;abcde&quot;
&quot;abcde&quot;
&#39;d&#39;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
&quot;abcde&quot;
[&#39;a&#39;; &#39;b&#39;; &#39;c&#39;; &#39;d&#39;; &#39;e&#39;]
[&#39;a&#39;; &#39;b&#39;; &#39;c&#39;; &#39;d&#39;; &#39;e&#39;]
[&#39;a&#39;; &#39;b&#39;; &#39;c&#39;; &#39;d&#39;; &#39;e&#39;]
[&#39;a&#39;; &#39;b&#39;; &#39;c&#39;; &#39;d&#39;; &#39;e&#39;]
&quot;abcde&quot;
&#39;d&#39;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

文字のリストから文字列への変換は次のようにします。

```fsharp:F#
let a = [&#39;a&#39;..&#39;f&#39;]
let s = Array.ofList a |&gt; System.String.Concat
printfn &quot;%A -&gt; %A&quot; a s
```
```text:実行結果
[&#39;a&#39;; &#39;b&#39;; &#39;c&#39;; &#39;d&#39;; &#39;e&#39;; &#39;f&#39;] -&gt; &quot;abcdef&quot;
```

## パターンマッチ

パターンマッチでリストの先頭要素を取り出せます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
first (x:xs) = x

main = do
    print $ first [1..5]
    print $ first &quot;abcdef&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let first = function
| x::xs -&gt; x
| _ -&gt; failwith &quot;empty&quot;

printfn &quot;%A&quot; &amp;lt;| first [1..5]
printfn &quot;%A&quot; &amp;lt;| first (List.ofSeq &quot;abcdef&quot;)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
&#39;a&#39;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
&#39;a&#39;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`x::xs`で先頭`x`とその後ろのリスト`xs`に分割して受け取ります。`xs`は`x`の複数形を意図しています。これらの名前には文法的な意味はなく、あくまで慣習です。

この例では`xs`を使っていないため`_`で未使用を明示した方が無難です。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
first (x:_) = x
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
| x::_ -&gt; x
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

先頭要素は複数を連ねることもできます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
second (_:x:_) = x

main = do
    print $ second [1..5]
    print $ second &quot;abcdef&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let second = function
| _::x::_ -&gt; x
| _ -&gt; failwith &quot;too short&quot;

printfn &quot;%A&quot; &amp;lt;| second [1..5]
printfn &quot;%A&quot; &amp;lt;| second (List.ofSeq &quot;abcdef&quot;)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
&#39;b&#39;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
2
&#39;b&#39;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

# リスト関係の関数

F#では`List`のメソッドという扱いです（`List.ofSeq` など）。

`List.`は省略できません。これは冗長な印象を受けますが、いくつかメリットがあります。

* F#では型推論を優先する言語設計のため、関数のオーバーロードができません。モジュールのメソッドであれば、配列・リスト・シーケンスなど互換性のない型に対して、同じ名前のメソッドが提供できます。
* インテリセンスのサポートがある環境では、`List.`と打てばメソッド名の候補が補完されます。

## length

リストの要素数を取得します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ length [1, 2, 3]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; &amp;lt;| List.length [1; 2; 3]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
3
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## sum

リストの要素をすべて足します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ sum [1..5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; &amp;lt;| List.sum [1..5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
15
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
15
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## rev

リストの要素を逆に並べます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print $ reverse [1..5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| List.rev [1..5]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[5,4,3,2,1]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[5; 4; 3; 2; 1]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 練習

`length`と同じ機能の関数を再実装する例です。

```fsharp:F#
let rec length = function
| []    -&gt; 0
| _::xs -&gt; 1 + length xs

printfn &quot;%d&quot; &amp;lt;| length [1; 2; 3]
```
```text:実行結果
3
```

【問4】`sum`, `rev`と同じ機能の関数を再実装してください。`sum`の掛け算版`product`も実装してください。

ヒント: リストを再帰で処理するパターンは`| x::xs -&gt; x ... f xs`です。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E5%86%8D%E5%AE%9F%E8%A3%85)

【問5】`product`を使って`fact`（階乗）を実装してください。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E9%9A%8E%E4%B9%97)

# タプル

関数で複数の値を返すことができます。括弧で複数の値を囲んだ部分を**タプル**と呼びます。

※ F#ではタプルの括弧を省略できますが、この記事では混乱を避けるため省略しません。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
addsub x y = (x + y, x - y)

main = do
    print $ addsub 1 2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let addsub x y = (x + y, x - y)

printfn &quot;%A&quot; &amp;lt;| addsub 1 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
(3,-1)
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
(3, -1)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

タプルは全体でも分割でも受け取れます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
addsub x y = (x + y, x - y)
a = addsub 1 2
(a1, a2) = addsub 1 2

main = do
    print a
    print a1
    print a2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let addsub x y = (x + y, x - y)
let a = addsub 1 2
let (a1, a2) = addsub 1 2

printfn &quot;%A&quot; a
printfn &quot;%d&quot; a1
printfn &quot;%d&quot; a2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
(3,-1)
3
-1
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
(3, -1)
3
-1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

数学の座標をイメージすると良いでしょう。

* $P=(1,2)$
* $(x,y)=(1,2)$ ⇔ $x=1,y=2$

## リストとの比較

* リストの項目数は任意ですが、タプルでは固定です。
* リストの要素はすべて同じ型でないといけませんが、タプルでは任意です。
    * × `[1; &quot;a&quot;]`
    * ○ `(1, &quot;a&quot;)`

## 関数

要素が2つのタプルから値を取り出す関数`fst`, `snd`があります。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    let p2 = (1, 2)
    print $ fst p2
    print $ snd p2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let p2 = (1, 2)
printfn &quot;%d&quot; &amp;lt;| fst p2
printfn &quot;%d&quot; &amp;lt;| snd p2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
1
2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

要素が3つ以上のタプルからは変数経由で値を取り出します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    let p3 = (1, 2, 3)
    print p3
    let (_, _, p3z) = p3
    print p3z
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let p3 = (1, 2, 3)
printfn &quot;%A&quot; p3
let (_, _, p3z) = p3
printfn &quot;%d&quot; p3z
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
(1,2,3)
3
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
(1, 2, 3)
3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

※ リストのように`.[]`で値を取り出すことはできません。

## 練習

【問6】点 $(p, q)$ から直線 $ax + by = c$ に下した垂線の交点を求める関数`perpPoint`を作成してください。aとbが両方ゼロになると解なしですが、チェックせずに無視してください。

具体的には次のコードが動くようにしてください。`0.`などは浮動小数点数（`float`）のリテラルです。

```fsharp
printfn &quot;%A&quot; &amp;lt;| perpPoint (0., 2.) (1., -1., 0.)
```
```text:実行結果
(1.0, 1.0)
```

ヒント: $ax + by = c$ の傾きは $-\frac{a}{b}$ です。直交する直線の傾きとの積が $-1$ となることから、垂線は $bx - ay = d$ と表せます。連立方程式を解けば交点が求まります。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E5%9E%82%E7%B7%9A%E3%81%AE%E4%BA%A4%E7%82%B9)

# キャスト

`int`などの基本的な型は、型名を関数として扱うことでキャストできます。

キャストを使用して、文字コードを取得したり、文字コードを文字に変換したりする例です。

※ Haskellでは専用の関数をインポートして使用します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
import Data.Char

main = do
    print $ ord &#39;A&#39;
    print $ chr 65
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%d&quot; &amp;lt;| int &#39;A&#39;
printfn &quot;%c&quot; &amp;lt;| char 65
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
65
&#39;A&#39;
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
65
A
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

## 練習

【問7】[ROT13](http://ja.wikipedia.org/wiki/ROT13)を実装してください。

具体的には次のコードが動くようにしてください。

```fsharp
let hello13 = rot13 &quot;Hello, World!&quot;
printfn &quot;%s&quot; hello13
printfn &quot;%s&quot; &lt;| rot13 hello13
```
```text:実行結果
Uryyb, Jbeyq!
Hello, World!
```

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#rot13)

# ソート

挿入ソートの実装例を示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
insert x [] = [x]
insert x (y:ys)
    | x &amp;lt; y     = x:y:ys
    | otherwise = y : insert x ys

isort []     = []
isort (x:xs) = insert x (isort xs)

main = do
    let t = [4, 6, 9, 8, 3, 5, 1, 7, 2]
    print $ isort t
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let rec insert x = function
| [] -&gt; [x]
| y::ys when x &amp;lt; y -&gt; x::y::ys
| y::ys -&gt; y :: insert x ys

let rec isort = function
| [] -&gt; []
| x::xs -&gt; insert x (isort xs)

let t = [4; 6; 9; 8; 3; 5; 1; 7; 2]
printfn &quot;%A&quot; &amp;lt;| isort t
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5,6,7,8,9]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5; 6; 7; 8; 9]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

処理の流れを説明します。

```fsharp:F#
let rec isort = function
| [] -&gt; []
| x::xs -&gt; insert x (isort xs)
```

リストの先頭の要素を取り出しながら再帰することで、リストの要素を順番に挿入して行きます。

リスト`[4; 6; 9; 8; 3; 5; 1; 7; 2]`の往路をトレースします。

1. `| [4; 6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 4 (isort [6; 9; 8; 3; 5; 1; 7; 2])`
1. `| [6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 6 (isort [9; 8; 3; 5; 1; 7; 2])`
1. `| [9; 8; 3; 5; 1; 7; 2] -&gt; insert 9 (isort [8; 3; 5; 1; 7; 2])`
1. `| [8; 3; 5; 1; 7; 2] -&gt; insert 8 (isort [3; 5; 1; 7; 2])`
1. `| [3; 5; 1; 7; 2] -&gt; insert 3 (isort [5; 1; 7; 2])`
1. `| [5; 1; 7; 2] -&gt; insert 5 (isort [1; 7; 2])`
1. `| [1; 7; 2] -&gt; insert 1 (isort [7; 2])`
1. `| [7; 2] -&gt; insert 7 (isort [2])`
1. `| [2] -&gt; insert 2 (isort [])`
1. `| [] -&gt; []`

`insert`の第2引数は必ず`isort`でソートされたリストが渡されます。

挿入先のリストはソート済みであることを前提にできるため、挿入箇所の判定は後続要素との比較だけで済みます。

再帰により挿入先のリストの要素と順番に比較していきます。末尾に達すると`ys = []`となるため、そこに挿入します。

```fsharp:F#
let rec insert x = function
| [] -&gt; [x]
| y::ys when x &lt; y -&gt; x::y::ys
| y::ys -&gt; y :: insert x ys
```

例を示します。

1. `insert 3 [1; 2; 5; 7]` 次へ
1. `1::insert 3 [2; 5; 7]` 次へ
1. `1::2::insert 3 [5; 7]` ここへ挿入
1. `1::2::3::[5; 7]`
1. `[1; 2; 3; 5; 7]`

`isort`の復路をトレースします。

1. `| [2] -&gt; insert 2 []`
1. `| [7; 2] -&gt; insert 7 [2]`
1. `| [1; 7; 2] -&gt; insert 1 [2; 7]`
1. `| [5; 1; 7; 2] -&gt; insert 5 [1; 2; 7]`
1. `| [3; 5; 1; 7; 2] -&gt; insert 3 [1; 2; 5; 7]`
1. `| [8; 3; 5; 1; 7; 2] -&gt; insert 8 [1; 2; 3; 5; 7]`
1. `| [9; 8; 3; 5; 1; 7; 2] -&gt; insert 9 [1; 2; 3; 5; 7; 8]`
1. `| [6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 6 [1; 2; 3; 5; 7; 8; 9]`
1. `| [4; 6; 9; 8; 3; 5; 1; 7; 2] -&gt; insert 4 [1; 2; 3; 5; 6; 7; 8; 9]`
1. `[1; 2; 3; 4; 5; 6; 7; 8; 9]`

このように要素を1つずつソートされたリストに挿入しています。

## 確認のコツ

再帰の確認のコツを説明しましたが、挿入ソートに適用してみます。具体例を使って、結果が信頼できるものと見なします。

```fsharp:isort再帰部
| x::xs -&gt; insert x (isort xs)
```

1. `| [3; 5; 1; 7; 2] -&gt; insert 3 (isort [5; 1; 7; 2])`
2. `| [5; 1; 7; 2]`は定義よりソート済みの`[1; 2; 5; 7]`が返されると考えます。
3. `insert 3 [1; 2; 5; 7] = [1; 2; 3; 5; 7]`

## デバッグ

F#ではHaskellのように副作用の分離が強制されないため、通常の`printf`デバッグが可能です。

挿入ソートをトレースしてみます。

```fsharp:F#
let rec insert x = function
| [] -&gt; [x]
| y::ys when x &lt; y -&gt; x::y::ys
| y::ys -&gt; y :: insert x ys

let rec isort = function
| [] -&gt; []
| x::xs -&gt;
    printfn &quot;isort %A = insert %d (isort %A)&quot; (x::xs) x xs
    let xs&#39; = isort xs
    let ret = insert x xs&#39;
    printfn &quot;insert %d %A = %A&quot; x xs&#39; ret
    ret

let t = [4; 6; 9; 8; 3; 5; 1; 7; 2]
printfn &quot;%A&quot; &lt;| isort t
```
```text:実行結果
isort [4; 6; 9; 8; 3; 5; 1; 7; 2] = insert 4 (isort [6; 9; 8; 3; 5; 1; 7; 2])
isort [6; 9; 8; 3; 5; 1; 7; 2] = insert 6 (isort [9; 8; 3; 5; 1; 7; 2])
isort [9; 8; 3; 5; 1; 7; 2] = insert 9 (isort [8; 3; 5; 1; 7; 2])
isort [8; 3; 5; 1; 7; 2] = insert 8 (isort [3; 5; 1; 7; 2])
isort [3; 5; 1; 7; 2] = insert 3 (isort [5; 1; 7; 2])
isort [5; 1; 7; 2] = insert 5 (isort [1; 7; 2])
isort [1; 7; 2] = insert 1 (isort [7; 2])
isort [7; 2] = insert 7 (isort [2])
isort [2] = insert 2 (isort [])
insert 2 [] = [2]
insert 7 [2] = [2; 7]
insert 1 [2; 7] = [1; 2; 7]
insert 5 [1; 2; 7] = [1; 2; 5; 7]
insert 3 [1; 2; 5; 7] = [1; 2; 3; 5; 7]
insert 8 [1; 2; 3; 5; 7] = [1; 2; 3; 5; 7; 8]
insert 9 [1; 2; 3; 5; 7; 8] = [1; 2; 3; 5; 7; 8; 9]
insert 6 [1; 2; 3; 5; 7; 8; 9] = [1; 2; 3; 5; 6; 7; 8; 9]
insert 4 [1; 2; 3; 5; 6; 7; 8; 9] = [1; 2; 3; 4; 5; 6; 7; 8; 9]
[1; 2; 3; 4; 5; 6; 7; 8; 9]
```

`printfn`を2回使うことで、往路と復路が確認できるように表示しています。

## 練習

【問8】[バブルソート](http://www.ics.kagoshima-u.ac.jp/~fuchida/edu/algorithm/sort-algorithm/bubble-sort.html)を実装してください。

ヒント: 交換する関数とソートする関数を分離して実装します。

⇒ [詳細説明](http://qiita.com/7shi/items/1e2a66bf8e8c7f0bd70f), [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%83%90%E3%83%96%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88)

【問9】[マージソート](http://www.ics.kagoshima-u.ac.jp/~fuchida/edu/algorithm/sort-algorithm/merge-sort.html)を実装してください。

ヒント: リストを分割する関数を実装します。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88)

# リスト内包表記

リストの要素すべてに同じ処理を施した別のリストを作成します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
fact 0 = 1
fact n | n &gt; 0 = n * fact (n - 1)

main = do
    print [1, 2, 3, 4, 5]
    print [fact 1, fact 2, fact 3, fact 4, fact 5]
    print [fact x | x &amp;lt;- [1..5]]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
let rec fact = function
| 0 -&gt; 1
| n when n &gt; 0 -&gt; n * fact (n - 1)
| _ -&gt; failwith &quot;&lt; 0&quot;

printfn &quot;%A&quot; &amp;lt;| [1; 2; 3; 4; 5]
printfn &quot;%A&quot; &amp;lt;| [fact 1; fact 2; fact 3; fact 4; fact 5]
printfn &quot;%A&quot; &amp;lt;| [for x in 1..5 -&gt; fact x]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4,5]
[1,2,6,24,120]
[1,2,6,24,120]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4; 5]
[1; 2; 6; 24; 120]
[1; 2; 6; 24; 120]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`1..5`の要素を1つずつ`x`として取り出して、`fact x`として処理したリストを作成しています。

※ 同じことができる`map`という関数もありますが、詳細は省略します。

## 条件

要素を取り出す際に条件を指定する例を示します。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print [x | x &amp;lt;- [1..9], x &amp;lt; 5]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| [for x in 1..9 do if x &amp;lt; 5 then yield x]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1,2,3,4]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[1; 2; 3; 4]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

`1..9`のうち`x &lt; 5`を満たすものだけでリストを作成しています。

※ 同じことができる`filter`という関数もありますが、詳細は省略します。

### 練習

Haskellの特徴を示す例として、クイックソートがよく引き合いに出されます。

```hs
qsort []     = []
qsort (n:xs) = qsort lt ++ [n] ++ qsort gteq
    where
        lt   = [x | x &lt;- xs, x &lt;  n]
        gteq = [x | x &lt;- xs, x &gt;= n]

main = do
    print $ qsort [4, 6, 9, 8, 3, 5, 1, 7, 2]
```
```text:実行結果
[1,2,3,4,5,6,7,8,9]
```

【問10】動きを考えて、F#に移植してください。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88)

## 多重ループ

リスト内包表記で多重ループを使った例を示します。

複数のリストから値を取り出すこともできます。多重ループのようにすべての組み合わせが得られます。

&lt;table&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;/th&gt;&lt;th&gt;F#&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;
main = do
    print [(x, y) | x &amp;lt;- [1..3], y &amp;lt;- &quot;abc&quot;]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;
printfn &quot;%A&quot; &amp;lt;| [
    for x in 1..3 do
    for y in &quot;abc&quot; -&gt; (x, y)]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;実行結果&lt;pre&gt;
[(1,&#39;a&#39;),(1,&#39;b&#39;),(1,&#39;c&#39;),(2,&#39;a&#39;),(2,&#39;b&#39;),(2,&#39;c&#39;),
 (3,&#39;a&#39;),(3,&#39;b&#39;),(3,&#39;c&#39;)]
&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;実行結果&lt;pre&gt;
[(1, &#39;a&#39;); (1, &#39;b&#39;); (1, &#39;c&#39;); (2, &#39;a&#39;); (2, &#39;b&#39;);
 (2, &#39;c&#39;); (3, &#39;a&#39;); (3, &#39;b&#39;); (3, &#39;c&#39;)]

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

### 練習

【問11】三辺の長さが各20以下の整数で構成される直角三角形を列挙してください。並び順による重複を排除する必要はありません。

ヒント: 直角三角形の成立条件は三平方（ピタゴラス）の定理です。

⇒ [解答例](http://qiita.com/7shi/items/b174d1c50aab9350dafc#%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2%E3%81%AE%E4%B8%89%E8%BE%BA)
</textarea><input type="submit" name="commit" value="Save changes" data-disable-with="Save changes" /></form></div></section></div><div class="col-sm-3"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="Haskellで学ぶF#入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="Haskellで学ぶF#入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/1d3750ba17f5a88b8405" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div><section class="itemsShowAuthorInfo" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><a href="/7shi"><img alt="" class="itemsShowAuthorInfo_userIcon" itemprop="image" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" /></a><div class="itemsShowAuthorInfo_profileStats"><strong class="itemsShowAuthorInfo_userName" itemprop="name"><a itemprop="url" href="/7shi">7shi</a></strong><div class="itemsShowAuthorInfo_contribution"><span class="itemsShowAuthorInfo_count">2522</span><span class="itemsShowAuthorInfo_unit">Contribution</span></div><div data-react-class="T.UserFollowButton" data-react-props="{&quot;url_name&quot;:&quot;7shi&quot;,&quot;initial_followed_by&quot;:false,&quot;size&quot;:&quot;btn-xs&quot;,&quot;position&quot;:&quot;author-info&quot;}"></div></div><section class="itemsShowAuthorPopularItems"><h5 class="itemsShowAuthorPopularItems_sectionTitle">Popular Posts</h5><ul class="itemsShowAuthorPopularItems_posts list-unstyled"><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/145f1234f8ec2af923ef">Haskell 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/547b6137d7a3c482fe68">モナド則がちょっと分かった？</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/cac7b3e9b90bf91b00cc">文字列で学ぶC++入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/85afd7bbd5d6c4115ad6">Haskell アクション 超入門</a></li><li itemscope="" itemtype="http://schema.org/Article"> <a itemprop="url" track="click" data-label="AuthorPopularItemsAtSidebar" href="/7shi/items/d1e5a0c22be6cf61d286">Haskell IDE Leksah 入門</a></li></ul></section></section><div class="scroll-chaser"><div class="google-adsense"><style>.test-text-responsible { width: 200px; height: 200px; }@media(min-width: 1200px) {  .test-text-responsible { width: 250px; height: 250px; }}@media(max-width: 979px) and (min-width: 768px) {  .test-text-responsible { width: 120px; height: 240px; }}@media(max-width: 767px) {  .test-text-responsible { width: 320px; height: 50px; }}</style><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle test-text-responsible" data-ad-client="ca-pub-8127218772604357" data-ad-slot="3880091879" style="display:inline-block"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div><div data-react-class="T.Toc" data-react-props="{&quot;body&quot;:&quot;\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%8F%E3%83%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89\&quot;\u003eハローワールド\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%A8%E3%83%B3%E3%83%88%E3%83%AA%E3%83%BC%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88\&quot;\u003eエントリーポイント\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#include-stdioh\&quot;\u003einclude \u0026lt;stdio.h\u0026gt;\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#do\&quot;\u003edo\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#printf\&quot;\u003eprintf\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%9D%9F%E7%B8%9B\&quot;\u003e束縛\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#let\&quot;\u003elet\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0\&quot;\u003e関数\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E6%BC%94%E7%AE%97%E5%AD%90\&quot;\u003eパイプライン演算子\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0%E3%81%AE%E6%BC%94%E7%AE%97%E5%AD%90%E5%8C%96\&quot;\u003e関数の演算子化\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E9%96%A2%E6%95%B0%E5%8C%96\&quot;\u003e演算子の関数化\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97\&quot;\u003e四則演算\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%91%BD%E5%90%8D%E8%A6%8F%E5%89%87\&quot;\u003e命名規則\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#if---then---else\&quot;\u003eif - then - else\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%80%A4%E3%82%92%E8%BF%94%E3%81%99\&quot;\u003e値を返す\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81\&quot;\u003e関数のパターンマッチ\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%9A%8E%E4%B9%97\&quot;\u003e階乗\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B0%A1%E7%B4%84\&quot;\u003e簡約\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%9F%BA%E5%BA%95%E9%83%A8%E5%86%8D%E5%B8%B0%E9%83%A8\&quot;\u003e基底部・再帰部\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%B3%E3%83%84\&quot;\u003eコツ\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BD%9C%E3%82%8A%E6%96%B9%E3%81%AE%E3%82%B3%E3%83%84\&quot;\u003e作り方のコツ\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%A2%BA%E8%AA%8D%E3%81%AE%E3%82%B3%E3%83%84\&quot;\u003e確認のコツ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AC%E3%83%BC%E3%83%89\&quot;\u003eガード\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E4%BE%8B%E5%A4%96\&quot;\u003e例外\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-1\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#match\&quot;\u003ematch\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-2\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%AA%E3%82%B9%E3%83%88\&quot;\u003eリスト\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E8%A6%81%E7%B4%A0%E3%81%AE%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%97\&quot;\u003e要素の取り出し\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%80%A3%E7%95%AA\&quot;\u003e連番\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%80%A3%E7%B5%90\&quot;\u003e連結\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#\&quot;\u003e::\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%96%87%E5%AD%97%E5%88%97\&quot;\u003e文字列\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81\&quot;\u003eパターンマッチ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%AA%E3%82%B9%E3%83%88%E9%96%A2%E4%BF%82%E3%81%AE%E9%96%A2%E6%95%B0\&quot;\u003eリスト関係の関数\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#length\&quot;\u003elength\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#sum\&quot;\u003esum\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#rev\&quot;\u003erev\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-3\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%BF%E3%83%97%E3%83%AB\&quot;\u003eタプル\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%AA%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83\&quot;\u003eリストとの比較\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E9%96%A2%E6%95%B0-1\&quot;\u003e関数\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-4\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88\&quot;\u003eキャスト\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-5\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%82%BD%E3%83%BC%E3%83%88\&quot;\u003eソート\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%A2%BA%E8%AA%8D%E3%81%AE%E3%82%B3%E3%83%84-1\&quot;\u003e確認のコツ\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%87%E3%83%90%E3%83%83%E3%82%B0\&quot;\u003eデバッグ\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-6\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E3%83%AA%E3%82%B9%E3%83%88%E5%86%85%E5%8C%85%E8%A1%A8%E8%A8%98\&quot;\u003eリスト内包表記\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E6%9D%A1%E4%BB%B6\&quot;\u003e条件\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-7\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E5%A4%9A%E9%87%8D%E3%83%AB%E3%83%BC%E3%83%97\&quot;\u003e多重ループ\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\&quot;#%E7%B7%B4%E7%BF%92-8\&quot;\u003e練習\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n&quot;,&quot;wrapper&quot;:&quot;#article-body-wrapper&quot;}"></div></div></div><div class="row"><div class="col-sm-9"><div class="ArticleFooter__menu"><div class="s-flex-align-center"><div class="js-likebutton" data-props="{&quot;like_status&quot;:false,&quot;like_count&quot;:6,&quot;show_count&quot;:true,&quot;uuid&quot;:&quot;1d3750ba17f5a88b8405&quot;,&quot;likable_type&quot;:&quot;Article&quot;,&quot;position&quot;:&quot;article-footer&quot;}"></div><div class="ArticleFooter__userList"><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="chocolamint"><a itemprop="url" href="/chocolamint"><img alt="chocolamint" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/11978/profile-images/1473682231" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="knknkn1162"><a itemprop="url" href="/knknkn1162"><img alt="knknkn1162" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/133922/profile-images/1473719133" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="ozwk"><a itemprop="url" href="/ozwk"><img alt="ozwk" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/72075/profile-images/1473699037" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="Mizunashi_Mana"><a itemprop="url" href="/Mizunashi_Mana"><img alt="Mizunashi_Mana" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/138118/profile-images/1483788351" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="tgok"><a itemprop="url" href="/tgok"><img alt="tgok" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/40485/profile-images/1473688453" /></a></div></div><div class="ArticleFooter__user"><div class="js-hovercard" data-hovercard-target-name="akumavideo"><a itemprop="url" href="/akumavideo"><img alt="akumavideo" class="thumb thumb--xs" src="https://qiita-image-store.s3.amazonaws.com/0/31675/profile-images/1478447306" /></a></div></div></div></div><div class="u-flex u-align-center"><div class="ArticleFooter__stock"><div class="js-stockbutton" data-position="footer_menu" data-props="{&quot;stock_status&quot;:false}"></div></div><div class="ArticleFooter__editRequest"><a class="u-link-no-underline" data-toggle="tooltip" title="You can propose improvements about the article to the author 💪" href="/drafts/1d3750ba17f5a88b8405/edit"><span class="fa fa-send-o fa-lg"></span> <span>Edit request</span></a></div><div class="dropdown ArticleFooter__dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#"><span class="fa fa-ellipsis-h"></span></a><ul class="dropdown-menu dropdown-menu-right"><li><a href="/7shi/items/1d3750ba17f5a88b8405.md"><span class="fa fa-fw fa-file-text-o"></span> Show article as Markdown</a></li><li><a data-target=".js-report-form" data-toggle="modal" href="#"><i class="fa fa-fw fa-flag"></i> Report article</a></li></ul></div></div></div><ul class="references js-referencesView"><li class="references_header"><i class="fa fa-fw fa-link"></i> Linked from these articles</li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/b174d1c50aab9350dafc#_reference-8c0e9c66e9165eabc94a"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />【解答例】Haskellで学ぶF#入門</a><time class="references_datetime js-dateTimeView" datetime="2017-01-11T09:44:54+00:00">about 2 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/ff746903680ae8d0d7ce#_reference-6a3cfa99698502105270"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />C#/JavaScriptで学ぶF#入門</a><time class="references_datetime js-dateTimeView" datetime="2017-01-11T09:49:20+00:00">about 2 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/145f1234f8ec2af923ef#_reference-d1f9ca38728162064c74"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />Haskell 超入門</a><time class="references_datetime js-dateTimeView" datetime="2017-01-11T09:52:55+00:00">about 2 months ago</time></li><li class="references_reference js-reference"><span>Linked from </span><a href="/7shi/items/4fb60dacad46cb8e63b3#_reference-958644f8040d00454b40"><img alt="" width="18" height="18" src="https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823" />多項式の積を計算</a><time class="references_datetime js-dateTimeView" datetime="2017-01-13T17:31:58+00:00">about 2 months ago</time></li></ul><div class="itemsShowBody_articleColumnFooter"><div class="socialButtons"><div class="socialButtons_twitter"><a class="twitter-share-button" data-text="Haskellで学ぶF#入門 by @7shi on @Qiita" data-url="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" href="https://twitter.com/share">Tweet</a></div><div class="socialButtons_hatebu"><a class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" data-hatena-bookmark-title="Haskellで学ぶF#入門" href="http://b.hatena.ne.jp/entry/http://qiita.com/7shi/items/1d3750ba17f5a88b8405" title="Add to Hatena Bookmark"><img alt="Add to Hatena Bookmark" height="20" src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" style="border: none;" width="20" /></a><script async="async" charset="utf-8" src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript"></script></div><div class="socialButtons_googlePlus"><div class="g-plusone" data-href="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" data-size="medium"></div></div><div class="socialButtons_facebook"><div class="fb-like" data-action="like" data-href="http://qiita.com/7shi/items/1d3750ba17f5a88b8405" data-layout="button_count" data-share="false" data-show-faces="false"></div></div><div class="socialButtons_pocket"><a class="pocket-btn" data-lang="en" data-pocket-count="horizontal" data-pocket-label="pocket"></a></div></div></div><div class="itemsShowComment_wrapper" id="comments"><div data-react-class="T.CommentListContainer" data-react-props="{&quot;currentUser&quot;:null,&quot;initialComments&quot;:[],&quot;monthly_public_image_uploadable_size_limit&quot;:null,&quot;total_uploaded_public_image_size_in_current_month&quot;:null,&quot;item&quot;:{&quot;id&quot;:459352,&quot;uuid&quot;:&quot;1d3750ba17f5a88b8405&quot;,&quot;suspended&quot;:false,&quot;secret&quot;:false},&quot;owner&quot;:{&quot;url_name&quot;:&quot;7shi&quot;},&quot;is_team&quot;:false,&quot;is_project&quot;:false,&quot;logged_in&quot;:false,&quot;polling&quot;:false,&quot;mention_candidates&quot;:[{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}]}">Comments Loading...</div></div></div></div></div></article><div class="js-report-form modal fade reportForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Report article</h4></div><div class="modal-body"><form action="/reports" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="LQL9AzThtQahCSe13MfzbsbZeIR1AeQHuwt+qfz+GaZDgGZbr8+MTV7akqmsMk03pp5cN+LFvvCH1XdSHfAXYA==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/1d3750ba17f5a88b8405" /><input type="hidden" name="item_uuid" id="item_uuid" value="1d3750ba17f5a88b8405" /><p>Help us understand the problem. What is going on with this item?</p><br /><div class="form-group"><ul class="list-unstyled"><li><label><input type="radio" name="report_type" id="report_type_spam" value="spam" required="required" /> It&#39;s spam </label></li><li><label><input type="radio" name="report_type" id="report_type_harassment" value="harassment" required="required" /> It&#39;s abusive or harmful </label></li><li><label><input type="radio" name="report_type" id="report_type_inappropriate_content" value="inappropriate_content" required="required" /> It contains inappropriate content </label></li></ul></div><div class="reportForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary reportForm_submitButton"><i class="fa fa-send"></i> Submit</button></div></form></div></div></div></div><script id="js-item" type="application/json">{ "url": "http://qiita.com/7shi/items/1d3750ba17f5a88b8405", "id": 459352, "uuid": "1d3750ba17f5a88b8405" }</script><script class="js-user" type="application/json">{&quot;id&quot;:32057,&quot;url_name&quot;:&quot;7shi&quot;,&quot;profile_image_url&quot;:&quot;https://qiita-image-store.s3.amazonaws.com/0/32057/profile-images/1473685823&quot;}</script><script language="JavaScript" src="//cdn.bigmining.com/private/js/qiita_bigmining.js" type="text/javascript"></script></div><footer class="footer"><div class="footer_inner"><div class="footer_container"><ul class="footer_links-left"><li class="footer_link"><a class="footer_copyright" href="http://increments.co.jp">© 2011-2017 Increments Inc.</a></li><li class="footer_link"><a href="http://qiita.com/terms">Terms</a></li><li class="footer_link"><a href="http://qiita.com/privacy">Privacy</a></li><li class="footer_link"><a href="http://help.qiita.com">Help</a></li><li class="footer_link"><a href="https://increments.zendesk.com/anonymous_requests/new">Contact</a></li></ul><ul class="footer_links-right"><li class="footer_link"><a href="http://qiita.com/about">About</a></li><li class="footer_link"><a href="/users">Users</a></li><li class="footer_link"><a href="/tags">Tags</a></li><li class="footer_link"><a href="http://blog.qiita.com">Blog</a></li><li class="footer_link"><a href="http://qiita.com/api/v2/docs">API</a></li><li class="footer_link"><a href="https://teams.qiita.com/">Team</a></li><li class="footer_link"><a href="http://kobito.qiita.com">Kobito</a></li><li class="footer_link"><a class="js-public-form-feedback-link" data-target=".js-feedback-form" data-toggle="modal" href=""><i class="fa fa-heart"></i> Feedback <i class="fa fa-caret-down"></i></a></li></ul></div></div></footer><div class="js-feedback-form modal fade feedbackForm"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button name="button" type="submit" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">Feedback</h4></div><div class="modal-body"><form class="js-feedback-form-form" action="/feedbacks" accept-charset="UTF-8" method="post"><input name="utf8" type="hidden" value="&#x2713;" /><input type="hidden" name="authenticity_token" value="5dHP8mM6plxGShSrruoEzVOjcFWRix+UDTS4ZyMUuVGLU1Sq+BSfF7mZobfeH7qUM+RU5gZPRWMx6rGcwhq3lw==" /><input type="hidden" name="redirect_path" id="redirect_path" value="/7shi/items/1d3750ba17f5a88b8405" /><div class="form-group"><textarea name="feedback[message]" id="feedback_message" class="form-control js-feedback-form-text-area" placeholder="Please give us any feedback about Qiita." required="required" rows="5">
</textarea></div><div class="feedbackForm_submitButtonContainer"><button name="button" type="submit" class="btn btn-primary feedbackForm_submitButton"><i class="fa fa-send"></i> Submit</button><p class="feedbackForm_note">We don&#39;t reply to any feedback.<br />If you need help with Qiita, please send a support request from <a href="https://increments.zendesk.com/anonymous_requests/new">here</a>.</p></div><div style="position:fixed;top:-99999px;opacity:0.0001;"><input name="feedback[name]" type="text" /></div></form></div></div></div></div><script>// if (window.mixpanel instanceof Element) {
//   window.mixpanel = [];
// }
// (function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
// for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);</script><script src="http://cdn.qiita.com/assets/public-8c6201a66dc6db6f64a9017391c319bf.min.js"></script><script>
  (function () {
    var script = document.getElementsByTagName('script')[0];
    var load = function (src, id) {
      var el = document.createElement('script');
      el.async = true;
      el.src = src;
      el.id = id;
      script.parentNode.insertBefore(el, script);
    };
      // Optimizely
      load('//cdn.optimizely.com/js/52738645.js', 'optimizely-jssdk');
      // Google Analytics
      window._gaq = window._gaq || [];
      var isCareer = location.hostname.split('.')[0] == 'career';
      if (isCareer) {
        window._gaq.push(['_setAccount', 'UA-24675221-11']);
        window._gaq.push(['_setDomainName', 'qiita.com']);
      } else {
        window._gaq.push(['_setAccount', 'UA-24675221-1']);
      }
      window._gaq.push(['_setCustomVar', 1, 'logged_in', 'false', 2]);
      window._gaq.push(['_trackPageview']);
      var src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      load(src, 'google-analytics-jssdk');
    // Google Analytics - Universal Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-24675221-12', {
          
        });
        ga('set', 'dimension1', 'false');
        ga('set', 'dimension3', 'false');
      ga('require', 'displayfeatures');
      ga('set', 'forceSSL', true);
      ga('send', 'pageview');
    // Google Tag Manager
      (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-TBQWPN');
  })();
</script>
</body></html>